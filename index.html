<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Chat Widget</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;500;600&family=Crimson+Text:wght@400;600&family=DM+Sans:wght@400;500;600&family=Fira+Code:wght@400;500&family=Fira+Sans:wght@400;500;600&family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&family=Lato:wght@400;700&family=Lexend:wght@400;500;600&family=Libre+Baskerville:wght@400;700&family=Lora:wght@400;500;600&family=Manrope:wght@400;500;600&family=Merriweather:wght@400;700&family=Montserrat:wght@400;500;600&family=Nunito:wght@400;600;700&family=Open+Sans:wght@400;600&family=Outfit:wght@400;500;600&family=Playfair+Display:wght@400;500;600&family=Plus+Jakarta+Sans:wght@400;500;600&family=Poppins:wght@400;500;600&family=Quicksand:wght@400;500;600&family=Raleway:wght@400;500;600&family=Righteous&family=Roboto:wght@400;500&family=Rubik:wght@400;500;600&family=Source+Code+Pro:wght@400;500&family=Source+Sans+Pro:wght@400;600&family=Ubuntu:wght@400;500;700&family=Work+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Adaptive Cards Library -->
    <script src="https://unpkg.com/adaptivecards@3.0.2/dist/adaptivecards.min.js"></script>
    
    <script src="dist/chat-sdk-bundle.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            min-height: 100vh; 
            overflow: hidden;
            position: relative;
        }
        
        /* Background screenshot image */
        #demoBackground {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background-size: 100% auto;
            background-position: top center;
            background-repeat: no-repeat;
            background-color: #f5f5f5;
            display: none;
        }
        #demoBackground.active {
            display: block;
        }
        
        /* Elegant pulse animation */
        @keyframes elegantPulse {
            0% {
                box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4), 
                            0 0 0 0 rgba(102, 126, 234, 0.4);
            }
            50% {
                box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4), 
                            0 0 0 12px rgba(102, 126, 234, 0);
            }
            100% {
                box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4), 
                            0 0 0 0 rgba(102, 126, 234, 0);
            }
        }
        
        /* Chat launcher with elegant pulse */
        .chat-launcher {
            position: fixed; bottom: 24px; right: 24px; width: 60px; height: 60px;
            border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none; cursor: pointer; box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
            transition: transform 0.3s ease, box-shadow 0.3s ease; z-index: 1000; 
            display: flex; align-items: center; justify-content: center;
            animation: elegantPulse 2.5s ease-in-out infinite;
        }
        .chat-launcher:hover { 
            transform: scale(1.1); 
            box-shadow: 0 6px 30px rgba(102, 126, 234, 0.6);
            animation: none; /* Stop pulse on hover */
        }
        .chat-launcher.open {
            animation: none; /* Stop pulse when chat is open */
        }
        .chat-launcher svg { width: 28px; height: 28px; fill: white; }
        /* Show/hide icons based on state */
        .chat-launcher .chat-icon { display: block; }
        .chat-launcher .close-icon { display: none; }
        .chat-launcher.open .chat-icon { display: none; }
        .chat-launcher.open .close-icon { display: block; }
        
        .chat-badge {
            position: absolute; top: -4px; right: -4px; background: #ff4757; color: white;
            font-size: 11px; font-weight: 700; min-width: 20px; height: 20px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center; opacity: 0; transform: scale(0);
            transition: all 0.2s ease;
        }
        .chat-badge.show { opacity: 1; transform: scale(1); }

        /* TALLER chat container */
        .chat-container {
            position: fixed; bottom: 100px; right: 24px; width: 400px; height: 700px;
            max-height: calc(100vh - 120px);
            background: white; border-radius: 16px; box-shadow: 0 10px 50px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; overflow: hidden; opacity: 0;
            transform: translateY(20px) scale(0.95); transition: all 0.3s ease; pointer-events: none; z-index: 999;
        }
        .chat-container.open { opacity: 1; transform: translateY(0) scale(1); pointer-events: all; }

        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 16px 20px; display: flex; align-items: center; gap: 12px; position: relative;
        }
        .header-avatar {
            width: 44px; height: 44px; border-radius: 50%; background: rgba(255,255,255,0.2);
            display: flex; align-items: center; justify-content: center; overflow: hidden;
            border: 2px solid rgba(255,255,255,0.5);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15), 0 0 0 2px rgba(255,255,255,0.1);
        }
        .header-avatar svg { width: 26px; height: 26px; fill: white; }
        .header-avatar img { width: 100%; height: 100%; object-fit: cover; }
        .header-info { flex: 1; }
        .header-title { color: white; font-weight: 600; font-size: 16px; }
        .header-status { color: rgba(255,255,255,0.8); font-size: 12px; margin-top: 2px; }
        .header-actions { display: flex; gap: 8px; }
        .header-btn {
            background: rgba(255,255,255,0.2); border: none; width: 32px; height: 32px;
            border-radius: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: background 0.2s;
        }
        .header-btn:hover { background: rgba(255,255,255,0.3); }
        .header-btn svg { width: 18px; height: 18px; fill: white; }
        .header-btn.active { background: #48bb78; }
        .header-btn.active:hover { background: #38a169; }
        .header-btn.disabled { opacity: 0.4; pointer-events: none; }
        .header-btn.sound-off svg { opacity: 0.5; }
        .header-btn.sound-off::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 20px;
            background: white;
            transform: rotate(45deg);
            border-radius: 1px;
        }
        .header-btn { position: relative; }

        /* Incoming Call Notification */
        .incoming-call-notification {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 12px 16px;
            z-index: 1000;
            animation: slideDown 0.3s ease-out;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        @keyframes slideDown {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .incoming-call-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .incoming-call-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .incoming-call-icon {
            width: 44px;
            height: 44px;
            min-width: 44px;
            min-height: 44px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 15px rgba(72, 187, 120, 0.4);
        }
        
        .incoming-call-icon svg {
            width: 22px;
            height: 22px;
            fill: white;
            flex-shrink: 0;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .incoming-call-info {
            flex: 1;
        }
        
        .incoming-call-title {
            font-size: 15px;
            font-weight: 600;
            color: white;
            margin-bottom: 2px;
        }
        
        .incoming-call-subtitle {
            font-size: 13px;
            color: rgba(255,255,255,0.9);
        }
        
        .incoming-call-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }
        
        .accept-call-btn,
        .accept-video-btn,
        .decline-call-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            justify-content: center;
        }
        
        .accept-video-btn {
            background: #4299e1;
            color: white;
        }
        
        .accept-video-btn:hover {
            background: #3182ce;
            transform: scale(1.05);
        }
        
        .accept-video-btn svg {
            fill: white;
        }
        
        .accept-call-btn {
            background: #48bb78;
            color: white;
        }
        
        .accept-call-btn:hover {
            background: #38a169;
            transform: scale(1.05);
        }
        
        .accept-call-btn svg {
            fill: white;
        }
        
        .decline-call-btn {
            background: #f56565;
            color: white;
        }
        
        .decline-call-btn:hover {
            background: #e53e3e;
            transform: scale(1.05);
        }
        
        .decline-call-btn svg {
            width: 18px;
            height: 18px;
            fill: white;
        }
        
        /* Voice/Video Call Container */
        .call-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a202c;
            z-index: 100;
            display: none;
            flex-direction: column;
        }
        .call-container.active { display: flex; }
        
        .call-header {
            padding: 16px 20px;
            background: rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .call-info {
            color: white;
        }
        .call-status {
            font-size: 14px;
            font-weight: 600;
        }
        .call-duration {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 4px;
        }
        
        .call-video-area {
            flex: 1;
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .remote-video,
        .local-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .local-video {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 120px;
            height: 160px;
            border-radius: 12px;
            border: 2px solid white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        
        .call-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 48px;
            font-weight: 600;
            border: 3px solid rgba(255,255,255,0.4);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3), 0 0 0 4px rgba(255,255,255,0.1);
        }
        
        .call-controls {
            padding: 24px 20px;
            background: rgba(0,0,0,0.5);
            display: flex;
            gap: 16px;
            justify-content: center;
        }
        
        .call-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            background: rgba(255,255,255,0.2);
        }
        .call-btn svg {
            width: 24px;
            height: 24px;
            fill: white;
        }
        .call-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }
        .call-btn.muted {
            background: rgba(239, 68, 68, 0.8);
        }
        .call-btn.end-call {
            background: #ef4444;
            width: 64px;
            height: 64px;
        }
        .call-btn.end-call:hover {
            background: #dc2626;
        }
        
        .call-connecting {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            color: white;
        }
        .call-connecting .spinner {
            border-color: rgba(255,255,255,0.2);
            border-top-color: white;
        }

        .chat-body { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }
        .prechat-form {
            padding: 24px; display: flex; flex-direction: column; gap: 16px; flex: 1; justify-content: center;
        }
        .prechat-form.hidden { display: none; }
        .form-title { font-size: 20px; font-weight: 600; color: #2d3748; text-align: center; margin-bottom: 8px; }
        .form-subtitle { font-size: 14px; color: #718096; text-align: center; margin-bottom: 16px; }
        .form-group { display: flex; flex-direction: column; gap: 6px; }
        .form-group label { font-size: 13px; font-weight: 500; color: #4a5568; }
        .form-group input, .form-group textarea {
            padding: 12px; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 14px;
            transition: border-color 0.2s, box-shadow 0.2s; font-family: inherit;
        }
        .form-group input:focus, .form-group textarea:focus {
            outline: none; border-color: #667eea; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .form-group textarea { resize: none; min-height: 80px; }
        .start-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; border: none; padding: 14px; border-radius: 8px; font-size: 15px;
            font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; margin-top: 8px;
        }
        .start-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); }
        .start-btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }

        .connecting-view, .chat-ended {
            display: none; flex-direction: column; align-items: center; justify-content: center;
            flex: 1; gap: 16px; padding: 24px; text-align: center;
        }
        .connecting-view.active, .chat-ended.active { display: flex; }
        .spinner {
            width: 48px; height: 48px; border: 3px solid #e2e8f0; border-top-color: #667eea;
            border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .connecting-text { color: #4a5568; font-size: 14px; }
        .ended-icon { font-size: 48px; }
        .ended-title { font-size: 18px; font-weight: 600; color: #2d3748; }
        .ended-text { font-size: 14px; color: #718096; }
        .new-chat-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 14px;
            font-weight: 600; cursor: pointer; margin-top: 8px;
        }

        .chat-messages {
            display: none; flex-direction: column; flex: 1; overflow-y: auto; padding: 16px;
            gap: 12px; background: #f8fafc; scroll-behavior: smooth;
        }
        .chat-messages.active { display: flex; }

        /* FIXED: Message wrapper with VERTICALLY CENTERED avatar */
        .message-wrapper { 
            display: flex; 
            gap: 10px; 
            max-width: 85%; 
            animation: fadeIn 0.3s ease;
            align-items: flex-start; /* Avatar at top, aligned with sender name */
        }
        .message-wrapper.user { flex-direction: row-reverse; align-self: flex-end; }
        .message-wrapper.agent { align-self: flex-start; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .message-avatar {
            width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center;
            justify-content: center; font-weight: 600; font-size: 13px; flex-shrink: 0; overflow: hidden;
            margin-top: 18px; /* Align with message bubble center */
            border: 2px solid transparent;
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .message-avatar:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.18);
        }
        .message-avatar.agent { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: white; 
            border-color: rgba(102, 126, 234, 0.3);
        }
        .message-avatar.bot { 
            background: linear-gradient(135deg, #00b4d8 0%, #0077b6 100%); 
            color: white; 
            border-color: rgba(0, 180, 216, 0.3);
        }
        .message-avatar.user { 
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); 
            color: white; 
            border-color: rgba(17, 153, 142, 0.3);
        }
        .message-avatar img { 
            width: 100%; height: 100%; object-fit: cover; 
            border-radius: 50%;
        }

        .message-content { display: flex; flex-direction: column; gap: 4px; min-width: 0; }
        .message-sender { font-size: 12px; font-weight: 600; color: #64748b; padding: 0 4px; }
        .message-wrapper.user .message-sender { text-align: right; }

        .message {
            padding: 12px 16px; border-radius: 16px; font-size: 14px; line-height: 1.5;
            word-wrap: break-word; white-space: pre-wrap;
        }
        .message.agent { background: white; color: #2d3748; border-bottom-left-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
        .message.user { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-bottom-right-radius: 4px; }
        .message.system {
            align-self: center; background: #e2e8f0; color: #64748b; font-size: 12px;
            padding: 6px 12px; border-radius: 12px; max-width: none;
        }

        .message-time { font-size: 10px; color: #94a3b8; padding: 0 4px; }
        .message-wrapper.user .message-time { text-align: right; }

        /* Image message styles */
        .message-image-container { display: flex; flex-direction: column; gap: 4px; }
        .message-image {
            max-width: 200px; max-height: 200px; border-radius: 12px; cursor: pointer;
            transition: transform 0.2s; object-fit: contain;
        }
        .message-image:hover { transform: scale(1.02); }
        .message-file-info { font-size: 11px; color: #64748b; padding: 0 4px; }

        .typing-indicator { display: none; padding: 8px 0; align-items: center; gap: 8px; }
        .typing-indicator.active { display: flex; }
        .typing-dots { display: flex; gap: 4px; padding: 12px 16px; background: white; border-radius: 16px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); margin-left: 46px; }
        .typing-dots span {
            width: 8px; height: 8px; background: #a0aec0; border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out;
        }
        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }

        /* Input area */
        .chat-input-area {
            display: none; padding: 12px 16px 16px; background: white;
            border-top: 1px solid #e2e8f0; flex-direction: column; gap: 10px;
        }
        .chat-input-area.active { display: flex; }

        .chat-input-wrapper { display: flex; flex-direction: column; gap: 10px; }

        .message-input {
            width: 100%; min-height: 60px; max-height: 120px; padding: 12px 14px;
            border: 1px solid #e2e8f0; border-radius: 12px; font-size: 14px;
            resize: none; font-family: inherit; line-height: 1.4; overflow-y: auto;
        }
        .message-input:focus { outline: none; border-color: #667eea; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); }
        .message-input::placeholder { color: #a0aec0; }

        .input-bottom-row { display: flex; align-items: center; justify-content: space-between; }

        .input-actions { display: flex; gap: 4px; }
        .action-btn {
            width: 36px; height: 36px; border: none; background: transparent;
            border-radius: 8px; cursor: pointer; display: flex; align-items: center;
            justify-content: center; color: #64748b; transition: all 0.2s;
        }
        .action-btn:hover { background: #f1f5f9; color: #667eea; }
        .action-btn svg { width: 20px; height: 20px; fill: currentColor; }
        /* Voice button active state */
        .action-btn.recording { background: #fee2e2; color: #ef4444; }
        .action-btn.recording svg { animation: pulse-mic 1s infinite; }
        @keyframes pulse-mic { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        /* SUBTLE MODERN Send button */
        .send-btn {
            width: 40px; height: 40px; border-radius: 10px;
            background: transparent; border: none; cursor: pointer; 
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s ease; color: #667eea;
        }
        .send-btn:hover { background: rgba(102, 126, 234, 0.1); }
        .send-btn:active { transform: scale(0.95); }
        .send-btn svg { width: 22px; height: 22px; fill: currentColor; }

        /* Emoji picker */
        .emoji-picker {
            position: absolute; bottom: 100%; left: 12px; width: 300px; max-height: 250px;
            background: white; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 12px; display: none; z-index: 100; overflow: hidden;
        }
        .emoji-picker.show { display: block; }
        .emoji-grid { 
            display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; 
            max-height: 200px; overflow-y: auto; padding-right: 4px;
        }
        .emoji-item {
            width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; border-radius: 6px; font-size: 20px; transition: background 0.2s;
        }
        .emoji-item:hover { background: #f1f5f9; transform: scale(1.1); }

        /* Voice recording indicator - IMPROVED visibility */
        .voice-recording {
            position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
            background: #ef4444; color: white; padding: 10px 20px; border-radius: 24px;
            display: none; align-items: center; gap: 10px; font-size: 14px; font-weight: 500;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
        }
        .voice-recording.show { display: flex; animation: slideDown 0.3s ease; }
        @keyframes slideDown { from { opacity: 0; transform: translateX(-50%) translateY(10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
        .voice-dot { width: 10px; height: 10px; background: white; border-radius: 50%; animation: pulse-dot 1s infinite; }
        @keyframes pulse-dot { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(0.8); } }
        .voice-waveform { display: flex; gap: 2px; align-items: center; }
        .voice-waveform span { width: 3px; background: white; border-radius: 2px; animation: wave 0.6s infinite ease-in-out; }
        .voice-waveform span:nth-child(1) { height: 8px; animation-delay: 0s; }
        .voice-waveform span:nth-child(2) { height: 16px; animation-delay: 0.1s; }
        .voice-waveform span:nth-child(3) { height: 12px; animation-delay: 0.2s; }
        .voice-waveform span:nth-child(4) { height: 20px; animation-delay: 0.3s; }
        .voice-waveform span:nth-child(5) { height: 12px; animation-delay: 0.4s; }
        @keyframes wave { 0%, 100% { transform: scaleY(1); } 50% { transform: scaleY(0.5); } }
        .stop-voice-btn {
            background: rgba(255,255,255,0.2); border: none; padding: 6px 12px;
            border-radius: 6px; color: white; cursor: pointer; font-size: 12px; font-weight: 500;
            transition: background 0.2s;
        }
        .stop-voice-btn:hover { background: rgba(255,255,255,0.3); }

        /* Confirm modal */
        .confirm-modal {
            position: absolute; inset: 0; background: rgba(0,0,0,0.5); display: none;
            align-items: center; justify-content: center; z-index: 200;
        }
        .confirm-modal.show { display: flex; }
        .confirm-content {
            background: white; padding: 24px; border-radius: 16px; text-align: center;
            max-width: 280px; margin: 20px;
        }
        .confirm-title { font-size: 16px; font-weight: 600; color: #2d3748; margin-bottom: 8px; }
        .confirm-text { font-size: 14px; color: #64748b; margin-bottom: 20px; }
        .confirm-buttons { display: flex; gap: 12px; justify-content: center; }
        .confirm-btn {
            padding: 10px 24px; border-radius: 8px; font-size: 14px; font-weight: 500;
            cursor: pointer; transition: all 0.2s; border: none;
        }
        .confirm-btn.cancel { background: #e2e8f0; color: #4a5568; }
        .confirm-btn.cancel:hover { background: #cbd5e1; }
        .confirm-btn.end { background: #ef4444; color: white; }
        .confirm-btn.end:hover { background: #dc2626; }
        
        /* Adaptive Card Styles */
        .ac-container {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 16px;
            margin: 4px 0;
            font-family: inherit;
        }
        .ac-container .ac-textBlock {
            margin-bottom: 12px;
            color: #2d3748;
            line-height: 1.5;
        }
        .ac-container .ac-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 14px;
            font-family: inherit;
            transition: border-color 0.2s;
        }
        .ac-container .ac-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .ac-container .ac-input.ac-multichoiceInput {
            padding: 8px 12px;
        }
        .ac-container label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #4a5568;
            margin-bottom: 6px;
        }
        .ac-container .ac-pushButton {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            margin-top: 8px;
        }
        .ac-container .ac-pushButton:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        .ac-container .ac-pushButton:active {
            transform: translateY(0);
        }
        .ac-container .ac-actionSet {
            margin-top: 12px;
            display: flex !important;
            flex-direction: column !important;
            flex-wrap: wrap !important;
            gap: 8px;
        }
        .ac-container .ac-actionSet > div {
            display: flex !important;
            flex-direction: column !important;
            width: 100% !important;
            gap: 8px;
        }
        .ac-container .ac-actionSet .ac-pushButton {
            margin-top: 0;
            margin-right: 0 !important;
            flex: none !important;
        }
        .ac-container select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 14px;
            font-family: inherit;
            background: white;
            cursor: pointer;
        }
        .ac-container select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        /* Hero Card Styles */
        .hero-card-carousel {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding: 8px 4px;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: #cbd5e0 transparent;
        }
        .hero-card-carousel::-webkit-scrollbar {
            height: 6px;
        }
        .hero-card-carousel::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 3px;
        }
        .hero-card {
            flex: 0 0 auto;
            width: 220px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
            scroll-snap-align: start;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .hero-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
        }
        .hero-card-image {
            width: 100%;
            height: 160px;
            object-fit: cover;
            background: #f0f4f8;
        }
        .hero-card-content {
            padding: 12px;
        }
        .hero-card-title {
            font-size: 14px;
            font-weight: 600;
            color: #1a202c;
            margin-bottom: 4px;
            line-height: 1.3;
        }
        .hero-card-subtitle {
            font-size: 12px;
            color: #64748b;
            margin-bottom: 8px;
            line-height: 1.4;
        }
        .hero-card-text {
            font-size: 13px;
            color: #4a5568;
            margin-bottom: 8px;
            line-height: 1.4;
        }
        .hero-card-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .hero-card-button {
            padding: 8px 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        .hero-card-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        .hero-card-button:active {
            transform: translateY(0);
        }
        /* Suggested Actions (PVA-style quick reply buttons) */
        .suggested-actions-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
            padding-top: 8px;
        }
        .suggested-action-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 18px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .suggested-action-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.4);
        }
        .suggested-action-btn:active {
            transform: translateY(0);
        }
        .suggested-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        /* Single hero card (no carousel) */
        .hero-card-single {
            max-width: 280px;
        }
        .hero-card-single .hero-card {
            width: 100%;
        }
        /* Image-only hero card */
        .hero-card-image-only {
            border-radius: 12px;
            overflow: hidden;
            max-width: 280px;
        }
        .hero-card-image-only img {
            width: 100%;
            display: block;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .hero-card-image-only img:hover {
            transform: scale(1.02);
        }
        /* Carousel wrapper with navigation */
        .hero-card-carousel-wrapper {
            position: relative;
            width: 100%;
        }
        .hero-card-carousel {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding: 8px 4px;
            scroll-snap-type: x mandatory;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .hero-card-carousel::-webkit-scrollbar {
            display: none;
        }
        .carousel-nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: white;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.2s;
            opacity: 0.9;
        }
        .carousel-nav-btn:hover {
            background: #f8f9fa;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            opacity: 1;
        }
        .carousel-nav-btn:active {
            transform: translateY(-50%) scale(0.95);
        }
        .carousel-nav-btn.prev {
            left: -8px;
        }
        .carousel-nav-btn.next {
            right: -8px;
        }
        .carousel-nav-btn svg {
            width: 16px;
            height: 16px;
            fill: #4a5568;
        }
        .carousel-nav-btn:disabled {
            opacity: 0.3;
            cursor: default;
        }
    </style>
</head>
<body>
    <!-- Background screenshot -->
    <div id="demoBackground"></div>

    <button class="chat-launcher" id="chatLauncher">
        <span class="chat-badge" id="chatBadge">0</span>
        <svg class="chat-icon" viewBox="0 0 24 24"><path d="M9.56158 3C5.41944 3 2.06158 6.35786 2.06158 10.5C2.06158 11.6329 2.31325 12.7088 2.76423 13.6734C2.5102 14.6714 2.22638 15.7842 2.03999 16.5147C1.80697 17.428 2.6294 18.2588 3.54374 18.039C4.29396 17.8587 5.44699 17.5819 6.47447 17.337C7.41678 17.7631 8.46241 18 9.56158 18C13.7037 18 17.0616 14.6421 17.0616 10.5C17.0616 6.35786 13.7037 3 9.56158 3ZM3.56158 10.5C3.56158 7.18629 6.24787 4.5 9.56158 4.5C12.8753 4.5 15.5616 7.18629 15.5616 10.5C15.5616 13.8137 12.8753 16.5 9.56158 16.5C8.60084 16.5 7.69487 16.2748 6.89161 15.8749L6.6482 15.7537L6.38368 15.8167C5.46095 16.0363 4.39489 16.2919 3.59592 16.4838C3.79467 15.7047 4.05784 14.6724 4.28601 13.7757L4.35619 13.4998L4.22568 13.2468C3.80145 12.4246 3.56158 11.4914 3.56158 10.5ZM14.5616 21.0001C12.5922 21.0001 10.8001 20.241 9.46191 18.9995C9.49511 18.9999 9.52835 19.0001 9.56163 19.0001C10.2796 19.0001 10.9768 18.911 11.6427 18.7434C12.5067 19.2254 13.5021 19.5001 14.5616 19.5001C15.5223 19.5001 16.4283 19.2748 17.2316 18.8749L17.475 18.7537L17.7395 18.8167C18.6611 19.0361 19.7046 19.2625 20.4787 19.4262C20.3037 18.6757 20.065 17.6711 19.8372 16.7757L19.767 16.4999L19.8975 16.2469C20.3217 15.4247 20.5616 14.4915 20.5616 13.5001C20.5616 11.3853 19.4676 9.52617 17.8146 8.45761C17.6363 7.73435 17.3653 7.04756 17.015 6.41052C19.9523 7.42684 22.0616 10.2171 22.0616 13.5001C22.0616 14.6332 21.8098 15.7094 21.3586 16.6741C21.6117 17.6821 21.8679 18.774 22.0304 19.4773C22.2348 20.3623 21.4554 21.1633 20.563 20.9768C19.8358 20.8248 18.6933 20.581 17.6495 20.3367C16.707 20.763 15.6611 21.0001 14.5616 21.0001Z"/></svg>
        <svg class="close-icon" viewBox="0 0 24 24"><path d="m4.21 4.387.083-.094a1 1 0 0 1 1.32-.083l.094.083L12 10.585l6.293-6.292a1 1 0 1 1 1.414 1.414L13.415 12l6.292 6.293a1 1 0 0 1 .083 1.32l-.083.094a1 1 0 0 1-1.32.083l-.094-.083L12 13.415l-6.293 6.292a1 1 0 0 1-1.414-1.414L10.585 12 4.293 5.707a1 1 0 0 1-.083-1.32l.083-.094-.083.094Z"/></svg>
    </button>

    <div class="chat-container" id="chatContainer">
        <div class="chat-header">
            <div class="header-avatar" id="headerAvatar">
                <!-- Generic company/building icon - no bot logo here -->
                <svg viewBox="0 0 24 24" fill="white"><path d="M12 7V3H2v18h20V7H12zM6 19H4v-2h2v2zm0-4H4v-2h2v2zm0-4H4V9h2v2zm0-4H4V5h2v2zm4 12H8v-2h2v2zm0-4H8v-2h2v2zm0-4H8V9h2v2zm0-4H8V5h2v2zm10 12h-8v-2h2v-2h-2v-2h2v-2h-2V9h8v10zm-2-8h-2v2h2v-2zm0 4h-2v2h2v-2z"/></svg>
            </div>
            <div class="header-info">
                <div class="header-title" id="headerTitle">Support Chat</div>
                <div class="header-status" id="headerStatus">We're here to help</div>
            </div>
            <div class="header-actions">
                <!-- Sound toggle button -->
                <button class="header-btn" id="toggleSound" title="Sound notifications on">
                    <svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
                </button>
                <!-- Download transcript button -->
                <button class="header-btn" id="downloadChat" title="Download transcript" style="display:none;">
                    <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                </button>
                <!-- Voice/Video call buttons removed - only agents can initiate calls -->
                <button class="header-btn" id="minimizeChat" title="Minimize">
                    <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
                </button>
                <button class="header-btn" id="closeChat" title="Close">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
                </button>
            </div>
        </div>

        <div class="chat-body">
            <!-- Incoming Call Notification -->
            <div class="incoming-call-notification" id="incomingCallNotification" style="display:none;">
                <div class="incoming-call-content">
                    <div class="incoming-call-header">
                        <div class="incoming-call-icon">
                            <svg viewBox="0 0 24 24" width="22" height="22"><path fill="white" d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-1.57 1.97c-2.83-1.35-5.48-3.9-6.89-6.83l1.95-1.66c.27-.28.35-.67.24-1.02-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19C3.65 3 3 3.24 3 3.99 3 13.28 10.73 21 20.01 21c.71 0 .99-.63.99-1.18v-3.45c0-.54-.45-.99-.99-.99z"/></svg>
                        </div>
                        <div class="incoming-call-info">
                            <div class="incoming-call-title" id="incomingCallTitle">Incoming Call</div>
                            <div class="incoming-call-subtitle" id="incomingCallSubtitle">Agent is calling...</div>
                        </div>
                    </div>
                    <div class="incoming-call-actions">
                        <button class="accept-video-btn" id="acceptVideoBtn" title="Accept with video">
                            <svg viewBox="0 0 24 24" width="16" height="16"><path fill="white" d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>
                            Video
                        </button>
                        <button class="accept-call-btn" id="acceptCallBtn" title="Accept voice only">
                            <svg viewBox="0 0 24 24" width="16" height="16"><path fill="white" d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-1.57 1.97c-2.83-1.35-5.48-3.9-6.89-6.83l1.95-1.66c.27-.28.35-.67.24-1.02-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19C3.65 3 3 3.24 3 3.99 3 13.28 10.73 21 20.01 21c.71 0 .99-.63.99-1.18v-3.45c0-.54-.45-.99-.99-.99z"/></svg>
                            Voice
                        </button>
                        <button class="decline-call-btn" id="declineCallBtn" title="Decline call">
                            <svg viewBox="0 0 24 24" width="16" height="16"><path fill="white" d="M12 9c-1.6 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.27 0-.52-.11-.7-.28-.79-.74-1.69-1.36-2.67-1.85-.33-.16-.56-.5-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z"/></svg>
                            Decline
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Voice/Video Call Container -->
            <div class="call-container" id="callContainer">
                <div class="call-header">
                    <div class="call-info">
                        <div class="call-status" id="callStatus">Connecting...</div>
                        <div class="call-duration" id="callDuration">00:00</div>
                    </div>
                </div>
                <div class="call-video-area" id="callVideoArea">
                    <div class="call-connecting" id="callConnecting">
                        <div class="spinner"></div>
                        <div>Connecting to agent...</div>
                    </div>
                    <div class="call-avatar" id="callAvatar" style="display:none;">A</div>
                    <video id="remoteVideo" class="remote-video" autoplay playsinline style="display:none;"></video>
                    <video id="localVideo" class="local-video" autoplay playsinline muted style="display:none;"></video>
                </div>
                <div class="call-controls">
                    <button class="call-btn" id="muteMicBtn" title="Mute microphone">
                        <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
                    </button>
                    <button class="call-btn" id="toggleCameraBtn" title="Turn off camera" style="display:none;">
                        <svg viewBox="0 0 24 24"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>
                    </button>
                    <button class="call-btn end-call" id="endCallBtn" title="End call">
                        <svg viewBox="0 0 24 24"><path d="M12 9c-1.6 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.27 0-.52-.11-.7-.28-.79-.74-1.69-1.36-2.67-1.85-.33-.16-.56-.5-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z"/></svg>
                    </button>
                </div>
            </div>
            
            <form class="prechat-form" id="prechatForm" onsubmit="return false;">
                <div class="form-title"> Welcome!</div>
                <div class="form-subtitle">Please fill in your details to start chatting with us.</div>
                <div class="form-group">
                    <label for="userName">Name *</label>
                    <input type="text" id="userName" placeholder="Enter your name" required>
                </div>
                <div class="form-group">
                    <label for="userEmail">Email *</label>
                    <input type="email" id="userEmail" placeholder="Enter your email" required>
                </div>
                <div class="form-group">
                    <label for="userQuestion">How can we help? (optional)</label>
                    <textarea id="userQuestion" placeholder="Describe your question..."></textarea>
                </div>
                <button type="button" class="start-btn" id="startBtn">Start Chat</button>
            </form>

            <div class="connecting-view" id="connectingView">
                <div class="spinner"></div>
                <div class="connecting-text">Connecting you with an agent...</div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="typing-indicator" id="typingIndicator">
                    <div class="typing-dots"><span></span><span></span><span></span></div>
                </div>
            </div>

            <div class="chat-input-area" id="chatInputArea">
                <div class="emoji-picker" id="emojiPicker">
                    <div class="emoji-grid" id="emojiGrid"></div>
                </div>
                <div class="voice-recording" id="voiceRecording">
                    <div class="voice-dot"></div>
                    <div class="voice-waveform"><span></span><span></span><span></span><span></span><span></span></div>
                    <span>Recording...</span>
                    <button class="stop-voice-btn" id="stopVoiceBtn">Stop</button>
                </div>
                <div class="chat-input-wrapper">
                    <textarea class="message-input" id="messageInput" placeholder="Type your message..." rows="3"></textarea>
                    <div class="input-bottom-row">
                        <div class="input-actions">
                            <input type="file" id="fileInput" hidden>
                            <button type="button" class="action-btn" id="attachBtn" title="Attach file">
                                <svg viewBox="0 0 24 24"><path d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6h-1.5z"/></svg>
                            </button>
                            <button type="button" class="action-btn" id="emojiBtn" title="Emoji">
                                <svg viewBox="0 0 24 24"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"/></svg>
                            </button>
                            <button type="button" class="action-btn" id="voiceBtn" title="Voice input">
                                <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.91-3c-.49 0-.9.36-.98.85C16.52 14.2 14.47 16 12 16s-4.52-1.8-4.93-4.15c-.08-.49-.49-.85-.98-.85-.61 0-1.09.54-1 1.14.49 3 2.89 5.35 5.91 5.78V20c0 .55.45 1 1 1s1-.45 1-1v-2.08c3.02-.43 5.42-2.78 5.91-5.78.1-.6-.39-1.14-1-1.14z"/></svg>
                            </button>
                        </div>
                        <button type="button" class="send-btn" id="sendBtn" title="Send">
                            <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
                        </button>
                    </div>
                </div>
            </div>

            <div class="chat-ended" id="chatEnded">
                <div class="ended-icon"></div>
                <div class="ended-title">Chat Ended</div>
                <div class="ended-text">Thank you for chatting with us!</div>
                <button class="new-chat-btn" id="newChatBtn">Start New Chat</button>
            </div>
        </div>

        <div class="confirm-modal" id="confirmModal">
            <div class="confirm-content">
                <div class="confirm-title">End Chat?</div>
                <div class="confirm-text">Are you sure you want to end this conversation?</div>
                <div class="confirm-buttons">
                    <button class="confirm-btn cancel" id="confirmNo">Cancel</button>
                    <button class="confirm-btn end" id="confirmYes">End Chat</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        // ============ LOAD ADMIN SETTINGS ============
        function loadAdminSettings() {
            const saved = localStorage.getItem('chatWidgetSettings');
            console.log(' LOADING SETTINGS FROM localStorage...');
            console.log('Raw localStorage data:', saved ? saved.substring(0, 200) + '... (' + saved.length + ' bytes total)' : 'NULL/EMPTY');
            
            if (!saved) {
                console.warn(' No settings found in localStorage - will use defaults');
                return null;
            }
            
            try {
                const parsed = JSON.parse(saved);
                console.log(' Successfully parsed admin settings:', {
                    orgId: parsed.orgId,
                    widgetId: parsed.widgetId,
                    orgUrl: parsed.orgUrl,
                    backgroundImageUrl: parsed.backgroundImageUrl,
                    botAvatar: parsed.botAvatar ? 'SET (' + parsed.botAvatar.substring(0, 50) + '...)' : 'NULL',
                    launcherIcon: parsed.launcherIcon,
                    headerTitle: parsed.headerTitle,
                    lastSaved: parsed.lastSaved
                });
                return parsed;
            } catch (e) {
                console.error(' Error parsing admin settings:', e);
                return null;
            }
        }

        const adminSettings = loadAdminSettings();
        console.log(' Admin settings loaded, using for configuration:', adminSettings ? 'YES' : 'NO (using defaults)');

        // Load background screenshot if configured
        const demoBackground = document.getElementById('demoBackground');
        
        if (adminSettings?.backgroundImageUrl && adminSettings.backgroundImageUrl.trim()) {
            let imageUrl = adminSettings.backgroundImageUrl.trim();
            console.log('Loading background screenshot:', imageUrl);
            
            // Convert Windows path to file:/// URL format
            if (imageUrl.match(/^[A-Za-z]:\\/)) {
                imageUrl = 'file:///' + imageUrl.replace(/\\/g, '/');
            }
            
            demoBackground.style.backgroundImage = `url('${imageUrl}')`;
            demoBackground.classList.add('active');
        }

        // ============ WIDGET MODE CHECK ============
        const widgetMode = adminSettings?.widgetMode || 'custom';
        console.log('Widget mode:', widgetMode);

        if (widgetMode === 'standard') {
            // Hide custom widget elements but keep the background
            document.querySelector('.chat-launcher')?.remove();
            document.querySelector('.chat-container')?.remove();
            // Keep demoBackground for the screenshot background
            
            // Load the standard D365 Live Chat Widget
            if (adminSettings?.lcwCode) {
                // Parse the lcwCode to extract the script attributes
                const parser = new DOMParser();
                const doc = parser.parseFromString(adminSettings.lcwCode, 'text/html');
                const scriptTag = doc.querySelector('script[id="Microsoft_Omnichannel_LCWidget"]');
                
                if (scriptTag) {
                    const lcwScript = document.createElement('script');
                    lcwScript.id = 'Microsoft_Omnichannel_LCWidget';
                    lcwScript.src = scriptTag.getAttribute('src');
                    lcwScript.setAttribute('data-app-id', scriptTag.getAttribute('data-app-id'));
                    lcwScript.setAttribute('data-org-id', scriptTag.getAttribute('data-org-id'));
                    lcwScript.setAttribute('data-org-url', scriptTag.getAttribute('data-org-url'));
                    document.head.appendChild(lcwScript);
                    console.log(' Standard D365 LCW widget loaded');
                    
                    // Set up D365 context provider to pass pre-chat form data for contact authentication
                    window.addEventListener("lcw:ready", function handleLivechatReadyEvent() {
                        console.log(' LCW Ready - Setting up context provider');
                        
                        Microsoft.Omnichannel.LiveChatWidget.SDK.setContextProvider(function contextProvider() {
                            // Check if standard widget auto-authentication is enabled
                            if (adminSettings?.enableStandardAuth === true) {
                                const authName = adminSettings.standardAuthName || 'Anonymous User';
                                const authEmail = adminSettings.standardAuthEmail || 'anonymous@example.com';
                                console.log(' Using standard widget auto-authentication:', { authName, authEmail });
                                
                                return {
                                    'emailaddress1': authEmail, // Contact email in Dynamics 365
                                    'Name': { value: authName, isDisplayable: true }, // Contact name in Dynamics 365
                                    'Authenticated': { value: 'Authenticated', isDisplayable: true } // Authentication status
                                };
                            }
                            
                            // If auto-auth is disabled, return empty context (native LCW pre-chat form will be used)
                            console.log(' Standard widget auth disabled - using native D365 pre-chat form');
                            return {};
                        });
                        
                        console.log(' Context provider configured for D365 standard widget');
                    });
                    
                    // Listen for pre-chat form submission to capture user data
                    window.addEventListener("lcw:startChat", function handleStartChat() {
                        // This event fires when user starts the chat via native LCW widget
                        console.log(' LCW Start Chat event - context will be passed to D365');
                    });
                    
                } else {
                    console.error(' Could not parse LCW code');
                }
            } else {
                console.warn(' No LCW code configured - cannot load standard widget');
            }
            
            // Stop execution here for standard mode
            throw new Error('Standard mode - stopping custom widget initialization');
        }

        // ============ MICROSOFT D365 CONFIGURATION ============
        // D365 Configuration - use admin settings if available
        const omnichannelConfig = {
            orgId: adminSettings?.orgId || '6f473421-f852-f011-8ee4-00224820bd14',
            widgetId: adminSettings?.widgetId || '4fea0c57-e7c2-4fe0-b274-327396965b3c',
            orgUrl: adminSettings?.orgUrl || 'https://m-6f473421-f852-f011-8ee4-00224820bd14.us.omnichannelengagementhub.com'
        };

        let chatSDK = null, chatStarted = false, unreadCount = 0, isMinimized = false, userName = '', userEmail = '', chatMessages = [];
        let processedMessageIds = new Set(); // Track processed message IDs to avoid duplicates
        
        // Initialize Adaptive Cards
        let adaptiveCardRenderer = null;
        if (typeof AdaptiveCards !== 'undefined') {
            adaptiveCardRenderer = new AdaptiveCards.AdaptiveCard();
            adaptiveCardRenderer.hostConfig = new AdaptiveCards.HostConfig({
                fontFamily: "inherit",
                spacing: {
                    small: 8,
                    default: 12,
                    medium: 16,
                    large: 20,
                    extraLarge: 24,
                    padding: 16
                },
                separator: {
                    lineThickness: 1,
                    lineColor: "#e2e8f0"
                },
                fontSizes: {
                    small: 12,
                    default: 14,
                    medium: 16,
                    large: 18,
                    extraLarge: 20
                },
                containerStyles: {
                    default: {
                        backgroundColor: "#f8f9fa",
                        foregroundColors: {
                            default: {
                                default: "#2d3748",
                                subtle: "#64748b"
                            }
                        }
                    }
                }
            });
        }

        // DOM elements
        const launcher = document.getElementById('chatLauncher');
        const container = document.getElementById('chatContainer');
        const badge = document.getElementById('chatBadge');
        const prechatForm = document.getElementById('prechatForm');
        const connectingView = document.getElementById('connectingView');
        const messagesContainer = document.getElementById('chatMessages');
        const inputArea = document.getElementById('chatInputArea');
        const typingIndicator = document.getElementById('typingIndicator');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const startBtn = document.getElementById('startBtn');
        const closeBtn = document.getElementById('closeChat');
        const minimizeBtn = document.getElementById('minimizeChat');
        const confirmModal = document.getElementById('confirmModal');
        const confirmYes = document.getElementById('confirmYes');
        const confirmNo = document.getElementById('confirmNo');
        const headerTitle = document.getElementById('headerTitle');
        const headerStatus = document.getElementById('headerStatus');
        const headerAvatar = document.getElementById('headerAvatar');
        const chatEndedView = document.getElementById('chatEnded');
        const newChatBtn = document.getElementById('newChatBtn');
        const attachBtn = document.getElementById('attachBtn');
        const fileInput = document.getElementById('fileInput');
        const emojiBtn = document.getElementById('emojiBtn');
        const emojiPicker = document.getElementById('emojiPicker');
        const emojiGrid = document.getElementById('emojiGrid');
        const voiceBtn = document.getElementById('voiceBtn');
        const voiceRecording = document.getElementById('voiceRecording');
        const stopVoiceBtn = document.getElementById('stopVoiceBtn');
        const downloadChatBtn = document.getElementById('downloadChat');
        
        // Voice/Video Call elements (agent-initiated only - customer cannot start calls)
        const callContainer = document.getElementById('callContainer');
        const callStatus = document.getElementById('callStatus');
        const callDuration = document.getElementById('callDuration');
        const callConnecting = document.getElementById('callConnecting');
        const callAvatar = document.getElementById('callAvatar');
        const remoteVideo = document.getElementById('remoteVideo');
        const localVideo = document.getElementById('localVideo');
        const muteMicBtn = document.getElementById('muteMicBtn');
        const toggleCameraBtn = document.getElementById('toggleCameraBtn');
        const endCallBtn = document.getElementById('endCallBtn');
        
        // Incoming call elements
        const incomingCallNotification = document.getElementById('incomingCallNotification');
        const incomingCallTitle = document.getElementById('incomingCallTitle');
        const incomingCallSubtitle = document.getElementById('incomingCallSubtitle');
        const acceptCallBtn = document.getElementById('acceptCallBtn');
        const declineCallBtn = document.getElementById('declineCallBtn');
        
        // Call state
        let isInCall = false;
        let isVideoCall = false;
        let isMicMuted = false;
        let isCameraOff = false;
        let callStartTime = null;
        let callDurationInterval = null;
        let localStream = null;
        let remoteStream = null;
        let pendingCallData = null; // Store incoming call data
        let currentAgentName = 'Agent'; // Track the current agent name for calls
        
        // Sound notification state
        let soundEnabled = localStorage.getItem('chatSoundEnabled') !== 'false'; // Default to enabled
        const toggleSoundBtn = document.getElementById('toggleSound');
        
        // Initialize sound button state
        if (!soundEnabled) {
            toggleSoundBtn.classList.add('sound-off');
            toggleSoundBtn.title = 'Sound notifications off';
        }
        
        // Toggle sound notifications
        toggleSoundBtn.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            localStorage.setItem('chatSoundEnabled', soundEnabled);
            if (soundEnabled) {
                toggleSoundBtn.classList.remove('sound-off');
                toggleSoundBtn.title = 'Sound notifications on';
            } else {
                toggleSoundBtn.classList.add('sound-off');
                toggleSoundBtn.title = 'Sound notifications off';
            }
        });
        
        // Create a subtle, modern notification sound using Web Audio API
        const notificationAudio = new Audio('notification/new-notification-3-398649.mp3');
        notificationAudio.volume = 0.5; // 50% volume - adjust as needed
        
        function playNotificationSound() {
            if (!soundEnabled) return;
            
            try {
                // Reset to beginning if already playing
                notificationAudio.currentTime = 0;
                notificationAudio.play().catch(e => {
                    console.log('Could not play notification sound:', e);
                });
            } catch (e) {
                console.log('Could not play notification sound:', e);
            }
        }

        // FIXED: Actual emoji array with real emojis
        const emojis = [
            '', '', '', '', '', '', '', '',
            '', '', '', '', '', '', '', '',
            '', '', '', '', '', '', '', '',
            '', '', '', '', '', '', '', '',
            '', '', '', '', '', '', '', '',
            '', '', '', '', '', '', '', '',
            '', '', '', '', '', '', '', '',
            '', '', '', '', '', '', '', ''
        ];

        function getInitials(name) {
            if (!name || typeof name !== 'string') return '?';
            const trimmed = name.trim();
            if (!trimmed) return '?';
            const parts = trimmed.split(' ');
            if (parts.length >= 2) return (parts[0][0] + parts[parts.length-1][0]).toUpperCase();
            return trimmed.substring(0, 2).toUpperCase();
        }

        function formatTime(date) {
            return new Date(date).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        // Event listeners
        launcher.addEventListener('click', () => {
            const isOpen = container.classList.contains('open');
            container.classList.toggle('open');
            launcher.classList.toggle('open');
            if (!isOpen) { 
                unreadCount = 0; 
                badge.textContent = '0'; 
                badge.classList.remove('show'); 
                isMinimized = false;
                
                // Check if pre-chat form is disabled - if so, auto-start chat
                if (adminSettings?.enablePrechatForm === false) {
                    // Use custom auth settings if enabled, otherwise use anonymous
                    let defaultName = 'Anonymous User';
                    let defaultEmail = 'anonymous@example.com';
                    
                    if (adminSettings.enableCustomAuth) {
                        defaultName = adminSettings.customAuthName || defaultName;
                        defaultEmail = adminSettings.customAuthEmail || defaultEmail;
                        console.log(' Using custom authentication:', { defaultName, defaultEmail });
                    } else {
                        console.log(' Pre-chat form disabled - starting anonymous chat');
                    }
                    
                    initializeChat(defaultName, defaultEmail, '');
                }
            }
        });

        minimizeBtn.addEventListener('click', () => {
            container.classList.remove('open');
            launcher.classList.remove('open');
            isMinimized = true;
        });

        closeBtn.addEventListener('click', () => {
            if (chatStarted) { confirmModal.classList.add('show'); }
            else { container.classList.remove('open'); launcher.classList.remove('open'); }
        });

        confirmNo.addEventListener('click', () => confirmModal.classList.remove('show'));
        confirmYes.addEventListener('click', async () => {
            confirmModal.classList.remove('show');
            
            // End any active call first
            if (isInCall) {
                await endCall();
            }
            
            // Close VoiceVideoCallingSDK
            if (VoiceVideoCallingSDK && VoiceVideoCallingSDK.close) {
                try {
                    VoiceVideoCallingSDK.close();
                    console.log(' VoiceVideoCallingSDK closed');
                } catch (e) {
                    console.log('VoiceVideoCallingSDK close error:', e);
                }
            }
            VoiceVideoCallingSDK = null;
            
            if (chatSDK) { try { await chatSDK.endChat(); } catch (e) { console.log('End chat error:', e); } }
            localStorage.removeItem('chatWidgetSession'); // Clear saved session
            showView('ended');
        });

        sendBtn.addEventListener('click', sendMessage);
        messageInput.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });

        startBtn.addEventListener('click', async () => {
            userName = document.getElementById('userName').value.trim();
            userEmail = document.getElementById('userEmail').value.trim();
            const question = document.getElementById('userQuestion').value.trim();
            if (!userName || !userEmail) { alert('Please fill in all required fields'); return; }
            startBtn.disabled = true; startBtn.textContent = 'Starting...';
            await initializeChat(userName, userEmail, question);
        });

        attachBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelect);
        
        // In-call controls (for agent-initiated calls)
        muteMicBtn.addEventListener('click', toggleMic);
        toggleCameraBtn.addEventListener('click', toggleCamera);
        endCallBtn.addEventListener('click', endCall);
        
        // Accept call buttons - customer chooses how to answer
        const acceptVideoBtn = document.getElementById('acceptVideoBtn');
        acceptCallBtn.addEventListener('click', () => acceptIncomingCall(false)); // Voice only
        acceptVideoBtn.addEventListener('click', () => acceptIncomingCall(true));  // With video
        declineCallBtn.addEventListener('click', declineIncomingCall);

        // Download transcript
        downloadChatBtn.addEventListener('click', downloadTranscript);

        function downloadTranscript() {
            if (chatMessages.length === 0) { alert('No messages to download'); return; }
            let transcript = `Chat Transcript\n`;
            transcript += `Date: ${new Date().toLocaleDateString()}\n`;
            transcript += `User: ${userName}\n`;
            transcript += `Email: ${userEmail}\n`;
            transcript += `${'='.repeat(50)}\n\n`;
            chatMessages.forEach(msg => {
                const time = formatTime(msg.timestamp);
                const sender = msg.isUser ? userName : (msg.senderName || 'Agent');
                transcript += `[${time}] ${sender}:\n${msg.content}\n\n`;
            });
            transcript += `${'='.repeat(50)}\n`;
            transcript += `End of transcript`;
            const blob = new Blob([transcript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chat-transcript-${new Date().toISOString().slice(0,10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showView(view) {
            prechatForm.classList.add('hidden');
            connectingView.classList.remove('active');
            messagesContainer.classList.remove('active');
            inputArea.classList.remove('active');
            chatEndedView.classList.remove('active');
            downloadChatBtn.style.display = 'none';
            
            // Skip pre-chat form if disabled in settings
            if (view === 'prechat' && adminSettings?.enablePrechatForm === false) {
                console.log(' Skipping pre-chat form - disabled in settings');
                return; // Don't show anything, chat auto-starts on launcher click
            }
            
            // Header always stays as company branding - only toggle views
            if (view === 'prechat') { prechatForm.classList.remove('hidden'); }
            else if (view === 'connecting') { connectingView.classList.add('active'); }
            else if (view === 'chat') { messagesContainer.classList.add('active'); inputArea.classList.add('active'); downloadChatBtn.style.display = 'flex'; }
            else if (view === 'ended') { chatEndedView.classList.add('active'); chatStarted = false; downloadChatBtn.style.display = 'flex'; }
        }

        function updateHeaderWithAgent(agentName, agentImage) {
            // Keep header static with company branding - don't update with agent info
            // Only update the internal agent name for calls
            const name = (typeof agentName === 'string') ? agentName : 'Support Agent';
            currentAgentName = name || 'Agent';
            // Header stays as company branding (CPS Support / We're here to help)
        }

        // Default bot avatar path (fallback if not set in admin)
        const DEFAULT_BOT_AVATAR_PATH = 'img/cps_logo.png';
        
        function getBotAvatarPath() {
            return adminSettings?.botAvatar || DEFAULT_BOT_AVATAR_PATH;
        }
        
        function isBotSender(senderName) {
            if (!senderName) return false;
            const name = senderName.toLowerCase();
            return name.includes('bot') || name.includes('copilot') || name.includes('virtual') || 
                   name.includes('assistant') || name.includes('ai') || name === 'cps';
        }
        
        function createAvatarElement(isUser, senderName, senderImage, isBot = false) {
            const avatar = document.createElement('div');
            
            // Determine if this is a bot based on sender name or explicit flag
            const isBotMessage = isBot || isBotSender(senderName);
            
            // Set appropriate class
            if (isUser) {
                avatar.className = 'message-avatar user';
            } else if (isBotMessage) {
                avatar.className = 'message-avatar bot';
            } else {
                avatar.className = 'message-avatar agent';
            }
            
            // Set avatar image or initials
            if (senderImage) { 
                avatar.innerHTML = `<img src="${senderImage}" alt="${senderName || 'Avatar'}">`; 
            } else if (isBotMessage) {
                // Use admin-configured bot avatar, or fallback to default
                const botAvatarSrc = getBotAvatarPath();
                avatar.innerHTML = `<img src="${botAvatarSrc}" alt="Bot" onerror="this.parentElement.textContent=''">`;
            } else { 
                avatar.textContent = getInitials(senderName || (isUser ? userName : 'Agent')); 
            }
            return avatar;
        }
        
        // Adaptive Card Support Functions
        function isAdaptiveCardContent(content) {
            if (!content || typeof content !== 'string') return false;
            try {
                const parsed = JSON.parse(content);
                // Check if it's an Adaptive Card directly or has attachments with Adaptive Cards
                if (parsed.type === 'AdaptiveCard') return true;
                if (parsed.attachments && Array.isArray(parsed.attachments)) {
                    return parsed.attachments.some(att => 
                        att.contentType === 'application/vnd.microsoft.card.adaptive' ||
                        (att.content && att.content.type === 'AdaptiveCard')
                    );
                }
                return false;
            } catch (e) {
                return false;
            }
        }
        
        // PVA Suggested Actions Support Functions
        function isSuggestedActionsContent(content) {
            if (!content || typeof content !== 'string') return false;
            try {
                const parsed = JSON.parse(content);
                // Check for PVA-style message with suggestedActions
                if (parsed.text && parsed.suggestedActions && parsed.suggestedActions.actions) {
                    return parsed.suggestedActions.actions.length > 0;
                }
                return false;
            } catch (e) {
                return false;
            }
        }
        
        function addSuggestedActionsMessage(content, isUser, senderName, senderImage) {
            const now = new Date();
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${isUser ? 'user' : 'agent'}`;
            
            // For bot messages, don't use agent avatar - let createAvatarElement use bot avatar
            const isBotMessage = !isUser && isBotSender(senderName);
            const avatarImage = senderImage || (isUser ? adminSettings?.customerAvatar : (isBotMessage ? null : adminSettings?.agentAvatar));
            const avatar = createAvatarElement(isUser, senderName, avatarImage);
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const senderDiv = document.createElement('div');
            senderDiv.className = 'message-sender';
            senderDiv.textContent = isUser ? userName : (senderName || 'Agent');
            
            try {
                const parsed = JSON.parse(content);
                const messageText = parsed.text || '';
                const actions = parsed.suggestedActions?.actions || [];
                
                console.log(' Rendering suggested actions message:', messageText, 'with', actions.length, 'buttons');
                
                // Create message bubble with text
                const messageBubble = document.createElement('div');
                messageBubble.className = `message ${isUser ? 'user' : 'agent'}`;
                messageBubble.textContent = messageText;
                
                // Create suggested actions container
                if (actions.length > 0) {
                    const actionsContainer = document.createElement('div');
                    actionsContainer.className = 'suggested-actions-container';
                    
                    actions.forEach(action => {
                        const button = document.createElement('button');
                        button.className = 'suggested-action-btn';
                        button.textContent = action.title || action.text || 'Select';
                        
                        button.onclick = async () => {
                            const value = action.value || action.text || action.title;
                            console.log(' Suggested action clicked:', action.type, value);
                            
                            // Disable all buttons in this container after click
                            actionsContainer.querySelectorAll('.suggested-action-btn').forEach(btn => {
                                btn.disabled = true;
                            });
                            
                            if (action.type === 'openUrl' && action.value) {
                                window.open(action.value, '_blank');
                            } else if (chatSDK && chatStarted) {
                                // Send as message (imBack, postBack, messageBack)
                                try {
                                    await chatSDK.sendMessage({ content: value });
                                    addMessage(value, true);
                                } catch (err) {
                                    console.error('Error sending suggested action response:', err);
                                    // Re-enable buttons on error
                                    actionsContainer.querySelectorAll('.suggested-action-btn').forEach(btn => {
                                        btn.disabled = false;
                                    });
                                }
                            }
                        };
                        
                        actionsContainer.appendChild(button);
                    });
                    
                    messageBubble.appendChild(actionsContainer);
                }
                
                const timeDiv = document.createElement('div');
                timeDiv.className = 'message-time';
                timeDiv.textContent = formatTime(now);
                
                contentDiv.appendChild(senderDiv);
                contentDiv.appendChild(messageBubble);
                contentDiv.appendChild(timeDiv);
                
            } catch (e) {
                console.error('Error rendering suggested actions:', e);
                // Fallback to plain text
                contentDiv.innerHTML = `
                    <div class="message-sender">${isUser ? userName : (senderName || 'Agent')}</div>
                    <div class="message ${isUser ? 'user' : 'agent'}">${content}</div>
                    <div class="message-time">${formatTime(now)}</div>
                `;
            }
            
            wrapper.appendChild(avatar);
            wrapper.appendChild(contentDiv);
            typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            chatMessages.push({ isUser, content, senderName: isUser ? userName : senderName, timestamp: now });
            saveChatSession();
            
            if (!isUser && !container.classList.contains('open')) {
                unreadCount++; badge.textContent = unreadCount; badge.classList.add('show');
            }
            if (!isUser) {
                playNotificationSound();
            }
        }
        
        // Hero Card Support Functions
        function isHeroCardContent(content) {
            if (!content || typeof content !== 'string') return false;
            try {
                const parsed = JSON.parse(content);
                // Check for single hero card attachment
                if (parsed.contentType === 'application/vnd.microsoft.card.hero') return true;
                // Check for attachments array with hero cards
                if (parsed.attachments && Array.isArray(parsed.attachments)) {
                    return parsed.attachments.some(att => 
                        att.contentType === 'application/vnd.microsoft.card.hero'
                    );
                }
                return false;
            } catch (e) {
                return false;
            }
        }
        
        function addHeroCardMessage(content, isUser, senderName, senderImage) {
            const now = new Date();
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${isUser ? 'user' : 'agent'}`;
            
            // For bot messages, don't use agent avatar - let createAvatarElement use bot avatar
            const isBotMessage = !isUser && isBotSender(senderName);
            const avatarImage = senderImage || (isUser ? adminSettings?.customerAvatar : (isBotMessage ? null : adminSettings?.agentAvatar));
            const avatar = createAvatarElement(isUser, senderName, avatarImage);
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const senderDiv = document.createElement('div');
            senderDiv.className = 'message-sender';
            senderDiv.textContent = isUser ? userName : (senderName || 'Agent');
            
            const cardContainer = document.createElement('div');
            
            try {
                const parsed = JSON.parse(content);
                let heroCards = [];
                let isCarousel = false;
                
                // Extract hero card(s)
                if (parsed.contentType === 'application/vnd.microsoft.card.hero' && parsed.content) {
                    // Single hero card
                    heroCards.push(parsed.content);
                } else if (parsed.attachments && Array.isArray(parsed.attachments)) {
                    // Multiple attachments - filter hero cards
                    heroCards = parsed.attachments
                        .filter(att => att.contentType === 'application/vnd.microsoft.card.hero' && att.content)
                        .map(att => att.content);
                    isCarousel = heroCards.length > 1 || parsed.attachmentLayout === 'carousel';
                }
                
                console.log(' Rendering Hero Cards:', heroCards.length, 'isCarousel:', isCarousel);
                
                if (heroCards.length === 0) {
                    console.warn('No hero cards found in content');
                    return;
                }
                
                // Check if it's an image-only card (no title, subtitle, text, or buttons)
                const isImageOnly = heroCards.length === 1 && 
                    heroCards[0].images && heroCards[0].images.length > 0 &&
                    !heroCards[0].title && !heroCards[0].subtitle && !heroCards[0].text &&
                    (!heroCards[0].buttons || heroCards[0].buttons.length === 0);
                
                if (isImageOnly) {
                    // Render as simple image
                    cardContainer.className = 'message hero-card-image-only';
                    const img = document.createElement('img');
                    img.src = heroCards[0].images[0].url;
                    img.alt = heroCards[0].images[0].alt || 'Image';
                    img.onclick = () => window.open(heroCards[0].images[0].url, '_blank');
                    cardContainer.appendChild(img);
                } else if (isCarousel) {
                    // Render as carousel with navigation
                    cardContainer.className = 'message hero-card-carousel-wrapper';
                    
                    // Create carousel container
                    const carousel = document.createElement('div');
                    carousel.className = 'hero-card-carousel';
                    heroCards.forEach(card => {
                        carousel.appendChild(createHeroCardElement(card));
                    });
                    
                    // Create navigation buttons
                    const prevBtn = document.createElement('button');
                    prevBtn.className = 'carousel-nav-btn prev';
                    prevBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>';
                    prevBtn.onclick = () => { carousel.scrollBy({ left: -240, behavior: 'smooth' }); };
                    
                    const nextBtn = document.createElement('button');
                    nextBtn.className = 'carousel-nav-btn next';
                    nextBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>';
                    nextBtn.onclick = () => { carousel.scrollBy({ left: 240, behavior: 'smooth' }); };
                    
                    cardContainer.appendChild(prevBtn);
                    cardContainer.appendChild(carousel);
                    cardContainer.appendChild(nextBtn);
                } else {
                    // Single card with content
                    cardContainer.className = 'message hero-card-single';
                    cardContainer.appendChild(createHeroCardElement(heroCards[0]));
                }
                
            } catch (e) {
                console.error('Error rendering Hero Card:', e);
                cardContainer.className = 'message';
                cardContainer.textContent = 'Error displaying card';
            }
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'message-time';
            timeDiv.textContent = formatTime(now);
            
            contentDiv.appendChild(senderDiv);
            contentDiv.appendChild(cardContainer);
            contentDiv.appendChild(timeDiv);
            
            wrapper.appendChild(avatar);
            wrapper.appendChild(contentDiv);
            messagesContainer.appendChild(wrapper);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Store in chat history
            chatMessages.push({
                content: '[Hero Card]',
                isUser,
                senderName,
                timestamp: now
            });
        }
        
        function createHeroCardElement(cardData) {
            const card = document.createElement('div');
            card.className = 'hero-card';
            
            // Image
            if (cardData.images && cardData.images.length > 0) {
                const img = document.createElement('img');
                img.className = 'hero-card-image';
                img.src = cardData.images[0].url;
                img.alt = cardData.images[0].alt || cardData.title || 'Image';
                img.onerror = () => { img.style.display = 'none'; };
                card.appendChild(img);
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'hero-card-content';
            
            // Title
            if (cardData.title) {
                const title = document.createElement('div');
                title.className = 'hero-card-title';
                title.textContent = cardData.title;
                contentDiv.appendChild(title);
            }
            
            // Subtitle
            if (cardData.subtitle) {
                const subtitle = document.createElement('div');
                subtitle.className = 'hero-card-subtitle';
                subtitle.textContent = cardData.subtitle;
                contentDiv.appendChild(subtitle);
            }
            
            // Text
            if (cardData.text) {
                const text = document.createElement('div');
                text.className = 'hero-card-text';
                text.textContent = cardData.text;
                contentDiv.appendChild(text);
            }
            
            // Buttons
            if (cardData.buttons && cardData.buttons.length > 0) {
                const buttonsDiv = document.createElement('div');
                buttonsDiv.className = 'hero-card-buttons';
                
                cardData.buttons.forEach(btn => {
                    const button = document.createElement('button');
                    button.className = 'hero-card-button';
                    button.textContent = btn.title || btn.text || 'Click';
                    
                    button.onclick = async () => {
                        const value = btn.value || btn.title;
                        console.log(' Hero Card button clicked:', btn.type, value);
                        
                        if (btn.type === 'openUrl' && btn.value) {
                            window.open(btn.value, '_blank');
                        } else if (chatSDK && chatStarted) {
                            // Send as message (postBack, imBack, messageBack)
                            try {
                                await chatSDK.sendMessage({ content: value });
                                addMessage(value, true);
                            } catch (err) {
                                console.error('Error sending hero card response:', err);
                            }
                        }
                    };
                    
                    buttonsDiv.appendChild(button);
                });
                
                contentDiv.appendChild(buttonsDiv);
            }
            
            card.appendChild(contentDiv);
            return card;
        }
        
        function addAdaptiveCardMessage(content, isUser, senderName, senderImage) {
            const now = new Date();
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${isUser ? 'user' : 'agent'}`;
            
            // For bot messages, don't use agent avatar - let createAvatarElement use bot avatar
            const isBotMessage = !isUser && isBotSender(senderName);
            const avatarImage = senderImage || (isUser ? adminSettings?.customerAvatar : (isBotMessage ? null : adminSettings?.agentAvatar));
            const avatar = createAvatarElement(isUser, senderName, avatarImage);
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const senderDiv = document.createElement('div');
            senderDiv.className = 'message-sender';
            senderDiv.textContent = isUser ? userName : (senderName || 'Agent');
            
            const cardContainer = document.createElement('div');
            cardContainer.className = 'message adaptive-card-message';
            
            try {
                const parsed = JSON.parse(content);
                let cardPayload = null;
                
                // Extract the Adaptive Card payload
                if (parsed.type === 'AdaptiveCard') {
                    cardPayload = parsed;
                } else if (parsed.attachments && Array.isArray(parsed.attachments)) {
                    const cardAttachment = parsed.attachments.find(att => 
                        att.contentType === 'application/vnd.microsoft.card.adaptive' && att.content
                    );
                    if (cardAttachment) {
                        cardPayload = cardAttachment.content;
                    }
                }
                
                if (cardPayload && adaptiveCardRenderer) {
                    adaptiveCardRenderer.parse(cardPayload);
                    
                    // Set up action handlers
                    adaptiveCardRenderer.onExecuteAction = async (action) => {
                        console.log('Adaptive Card action executed:', action);
                        
                        if (action instanceof AdaptiveCards.SubmitAction) {
                            const data = action.data;
                            console.log('Submit action data:', data);
                            
                            if (data && chatSDK && chatStarted) {
                                try {
                                    // Disable the card visually after submission
                                    const cardElement = cardContainer.querySelector('.ac-adaptiveCard');
                                    if (cardElement) {
                                        cardElement.style.opacity = '0.6';
                                        cardElement.style.pointerEvents = 'none';
                                    }
                                    
                                    // Get the action title for display
                                    const actionId = data.actionSubmitId || action.title || 'Submit';
                                    
                                    // Format the data for display (exclude actionSubmitId)
                                    const displayData = Object.entries(data)
                                        .filter(([key, value]) => key !== 'actionSubmitId' && value)
                                        .map(([key, value]) => `${key}: ${value}`)
                                        .join('\n');
                                    
                                    // CRITICAL: Send with Adaptive Card metadata so bot knows it's a form response
                                    // Official SDK format from DEVELOPMENT_GUIDE.md
                                    console.log(' Sending Adaptive Card response (official SDK format)');
                                    
                                    // Wrap data in {value: ...} as per official docs
                                    const content = JSON.stringify({value: data});
                                    console.log(' Content:', content);
                                    
                                    await chatSDK.sendMessage({ 
                                        content: content,
                                        metadata: {
                                            'microsoft.azure.communication.chat.bot.contenttype': 'azurebotservice.adaptivecard'
                                        }
                                    });
                                    
                                    // Show in UI (friendly format)
                                    const displayMessage = displayData ? `**${actionId}**\n${displayData}` : actionId;
                                    addMessage(displayMessage, true, userName, null);
                                    console.log(' Sent successfully');
                                } catch (error) {
                                    console.error(' Error:', error);
                                    addMessage(' Failed to submit. Please try again.', false, 'System', null);
                                }
                            }
                        } else if (action instanceof AdaptiveCards.OpenUrlAction && action.url) {
                            window.open(action.url, '_blank');
                        }
                    };
                    
                    const renderedCard = adaptiveCardRenderer.render();
                    if (renderedCard) {
                        cardContainer.appendChild(renderedCard);
                    } else {
                        cardContainer.innerHTML = '<p style="color: #e74c3c;"> Could not render card</p>';
                    }
                } else {
                    cardContainer.innerHTML = '<p style="color: #e74c3c;"> Invalid Adaptive Card format</p>';
                }
            } catch (error) {
                console.error('Error rendering Adaptive Card:', error);
                cardContainer.innerHTML = '<p style="color: #e74c3c;"> Error displaying card</p>';
            }
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'message-time';
            timeDiv.textContent = formatTime(now);
            
            contentDiv.appendChild(senderDiv);
            contentDiv.appendChild(cardContainer);
            contentDiv.appendChild(timeDiv);
            
            wrapper.appendChild(avatar);
            wrapper.appendChild(contentDiv);
            
            typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Save to chat history (store original JSON)
            chatMessages.push({ 
                isUser, 
                content: content, 
                isAdaptiveCard: true,
                senderName: isUser ? userName : senderName, 
                timestamp: now 
            });
            saveChatSession();
            
            if (!isUser && !container.classList.contains('open')) {
                unreadCount++; 
                badge.textContent = unreadCount; 
                badge.classList.add('show');
            }
            // Play notification sound for incoming Adaptive Card messages
            if (!isUser) {
                playNotificationSound();
            }
        }

        function addImageMessage(fileInfo, isUser, senderName, senderImage) {
            const now = new Date();
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${isUser ? 'user' : 'agent'}`;
            // Use admin-configured avatars if no senderImage provided
            // For bot messages, don't use agent avatar - let createAvatarElement use bot avatar
            const isBotMessage = !isUser && isBotSender(senderName);
            const avatarImage = senderImage || (isUser ? adminSettings?.customerAvatar : (isBotMessage ? null : adminSettings?.agentAvatar));
            const avatar = createAvatarElement(isUser, senderName, avatarImage);
            const content = document.createElement('div');
            content.className = 'message-content';
            content.innerHTML = `
                <div class="message-sender">${isUser ? userName : (senderName || 'Agent')}</div>
                <div class="message-image-container">
                    <img src="${fileInfo.url}" class="message-image" alt="${fileInfo.name}" onclick="window.open('${fileInfo.url}', '_blank')">
                    <div class="message-file-info">${fileInfo.name}</div>
                </div>
                <div class="message-time">${formatTime(now)}</div>
            `;
            wrapper.appendChild(avatar);
            wrapper.appendChild(content);
            typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            chatMessages.push({ isUser, content: `[Image: ${fileInfo.name}]`, senderName: isUser ? userName : senderName, timestamp: now });
            // Play notification sound for incoming image messages
            if (!isUser) {
                playNotificationSound();
            }
        }

        function addMessage(text, isUser = false, senderName = null, senderImage = null) {
            const now = new Date();
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${isUser ? 'user' : 'agent'}`;
            // Use admin-configured avatars if no senderImage provided
            // For bot messages, don't use agent avatar - let createAvatarElement use bot avatar
            const isBotMessage = !isUser && isBotSender(senderName);
            const avatarImage = senderImage || (isUser ? adminSettings?.customerAvatar : (isBotMessage ? null : adminSettings?.agentAvatar));
            const avatar = createAvatarElement(isUser, senderName, avatarImage);
            const content = document.createElement('div');
            content.className = 'message-content';
            content.innerHTML = `
                <div class="message-sender">${isUser ? userName : (senderName || 'Agent')}</div>
                <div class="message ${isUser ? 'user' : 'agent'}">${text}</div>
                <div class="message-time">${formatTime(now)}</div>
            `;
            wrapper.appendChild(avatar);
            wrapper.appendChild(content);
            typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            chatMessages.push({ isUser, content: text, senderName: isUser ? userName : senderName, timestamp: now });
            saveChatSession(); // Save after adding message
            if (!isUser && !container.classList.contains('open')) {
                unreadCount++; badge.textContent = unreadCount; badge.classList.add('show');
            }
            // Play notification sound for incoming messages
            if (!isUser) {
                playNotificationSound();
            }
        }

        function processMessage(message) {
            if (!message) return;
            
            // Get message ID - try various possible ID fields
            const messageId = message.messageId || message.id || message.clientmessageid || message.messageid;
            
            // Skip if already processed
            if (messageId && processedMessageIds.has(messageId)) {
                console.log('Skipping already processed message:', messageId);
                return;
            }
            
            // Mark as processed
            if (messageId) {
                processedMessageIds.add(messageId);
            }
            
            //  CHECK FOR INCOMING VOICE/VIDEO CALL
            // Check if message contains call invitation tags or metadata
            const tags = message.tags || [];
            const metadata = message.metadata || message.properties || {};
            const messageType = message.messageType || message.type || metadata.messageType;
            
            if (tags.includes('voicecall') || tags.includes('videocall') || 
                messageType === 'VoiceVideoCall' || messageType === 'voicecall' || messageType === 'videocall' ||
                metadata.isVoiceCall || metadata.isVideoCall) {
                console.log(' INCOMING CALL DETECTED in message:', message);
                const isVideo = tags.includes('videocall') || messageType === 'videocall' || metadata.isVideoCall;
                const senderName = message.senderDisplayName || message.sender?.displayName || 'Agent';
                showIncomingCallNotification({ 
                    isVideo, 
                    agentName: senderName,
                    messageData: message,
                    callId: messageId
                });
                return; // Don't process as regular message
            }
            
            // Get message content - try various possible content fields
            const content = message.content || message.text || message.body;
            
            // Check for file attachments (images, files sent by agent)
            const fileMetadata = message.fileMetadata || message.attachments || message.attachment;
            
            // Log full message if no content (helps debug attachment structure)
            if (!content && !fileMetadata) {
                console.log('Message has no content or attachments - full object:', JSON.stringify(message, null, 2));
                return;
            }
            
            // Determine message role
            const role = message.role || message.senderRole || message.deliveryMode;
            
            // Extract sender info - senderId can be an object with displayName
            const senderId = message.senderId || message.sender;
            let senderName = 'Agent';
            if (typeof senderId === 'object' && senderId !== null) {
                senderName = senderId.displayName || senderId.name || 'Agent';
            } else if (typeof senderId === 'string') {
                senderName = senderId;
            }
            // Also check direct senderDisplayName field
            if (message.senderDisplayName) {
                senderName = message.senderDisplayName;
            }
            
            console.log('Processing message - role:', role, 'senderName:', senderName, 'content:', content, 'fileMetadata:', fileMetadata);
            
            const isFromUser = role === 'user' || role === 'User' || role === 1;
            const isFromBot = role === 'bot' || role === 'Bot' || role === 2;
            const isFromAgent = role === 'agent' || role === 'Agent' || role === 3;
            const isSystem = role === 'system' || role === 'System';
            
            // Skip user messages (those are added when sent)
            if (isFromUser) {
                console.log('Skipping user message');
                return;
            }
            
            // Handle system messages
            if (isSystem) {
                addSystemMessage(content);
                return;
            }
            
            // Handle agent/bot messages
            if (isFromBot || isFromAgent || !isFromUser) {
                // Only update header for actual agent (not system)
                if (isFromAgent && senderName && senderName !== '__agent__') {
                    updateHeaderWithAgent(senderName, null);
                }
                
                // Handle file/image attachments
                if (fileMetadata) {
                    handleAgentAttachment(fileMetadata, senderName);
                }
                
                // Handle text content - check for card types first
                if (content) {
                    if (isSuggestedActionsContent(content)) {
                        console.log(' Detected PVA Suggested Actions in message content');
                        addSuggestedActionsMessage(content, false, senderName, null);
                    } else if (isHeroCardContent(content)) {
                        console.log(' Detected Hero Card in message content');
                        addHeroCardMessage(content, false, senderName, null);
                    } else if (isAdaptiveCardContent(content)) {
                        console.log(' Detected Adaptive Card in message content');
                        addAdaptiveCardMessage(content, false, senderName, null);
                    } else {
                        addMessage(content, false, senderName, null);
                    }
                }
            }
        }
        
        function handleAgentAttachment(fileMetadata, senderName) {
            console.log('Handling agent attachment:', fileMetadata);
            
            // fileMetadata can be a single object or an array
            const attachments = Array.isArray(fileMetadata) ? fileMetadata : [fileMetadata];
            
            attachments.forEach(async (attachment) => {
                const fileName = attachment.name || attachment.fileName || attachment.filePath || 'File';
                const fileType = attachment.type || attachment.contentType || attachment.mimeType || '';
                const fileId = attachment.id;
                
                console.log('Attachment details - name:', fileName, 'id:', fileId, 'type:', fileType);
                
                // Check if there's a direct URL first
                let fileUrl = attachment.url || attachment.downloadUrl || attachment.filePath;
                
                // If no direct URL but we have an ID, use SDK to download the file
                if (!fileUrl && fileId && chatSDK) {
                    try {
                        console.log('Downloading attachment via SDK...');
                        const blob = await chatSDK.downloadFileAttachment(attachment);
                        console.log('Downloaded blob:', blob);
                        
                        if (blob) {
                            // Create a blob URL from the downloaded content
                            fileUrl = URL.createObjectURL(blob);
                            console.log('Created blob URL:', fileUrl);
                        }
                    } catch (err) {
                        console.error('Error downloading attachment:', err);
                    }
                }
                
                if (fileUrl) {
                    if (fileType.startsWith('image/') || /\.(jpg|jpeg|png|gif|webp|bmp)$/i.test(fileName)) {
                        // It's an image
                        addImageMessage({ name: fileName, url: fileUrl }, false, senderName, null);
                    } else {
                        // It's a file - show as downloadable link
                        addFileMessage({ name: fileName, url: fileUrl, type: fileType }, false, senderName, null);
                    }
                } else {
                    console.log('Could not get URL for attachment:', attachment);
                    // Show a placeholder message indicating a file was received but couldn't be loaded
                    addMessage(`?? ${fileName} (file could not be loaded)`, false, senderName, null);
                }
            });
        }
        
        function addFileMessage(fileInfo, isUser, senderName, senderImage) {
            const now = new Date();
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${isUser ? 'user' : 'agent'}`;
            // For bot messages, don't use agent avatar - let createAvatarElement use bot avatar
            const isBotMessage = !isUser && isBotSender(senderName);
            const avatarImage = senderImage || (isUser ? adminSettings?.customerAvatar : (isBotMessage ? null : adminSettings?.agentAvatar));
            const avatar = createAvatarElement(isUser, senderName, avatarImage);
            const content = document.createElement('div');
            content.className = 'message-content';
            content.innerHTML = `
                <div class="message-sender">${isUser ? userName : (senderName || 'Agent')}</div>
                <div class="message ${isUser ? 'user' : 'agent'}">
                    <a href="${fileInfo.url}" target="_blank" style="color: inherit; text-decoration: underline;">
                        ?? ${fileInfo.name}
                    </a>
                </div>
                <div class="message-time">${formatTime(now)}</div>
            `;
            wrapper.appendChild(avatar);
            wrapper.appendChild(content);
            typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            chatMessages.push({ isUser, content: `[File: ${fileInfo.name}]`, senderName: isUser ? userName : senderName, timestamp: now });
            // Play notification sound for incoming file messages
            if (!isUser) {
                playNotificationSound();
            }
        }
        
        function addSystemMessage(text) {
            const wrapper = document.createElement('div');
            wrapper.className = 'message-wrapper';
            wrapper.style.justifyContent = 'center';
            wrapper.style.maxWidth = '100%';
            
            const msg = document.createElement('div');
            msg.className = 'message system';
            msg.textContent = text;
            
            wrapper.appendChild(msg);
            typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        async function pollMessages() {
            if (!chatSDK || !chatStarted) return;
            try {
                const messages = await chatSDK.getMessages();
                console.log('Polled messages:', messages);
                if (messages && messages.length) {
                    messages.forEach(msg => {
                        processMessage(msg);
                    });
                }
            } catch (e) { console.log('Poll error:', e); }
        }

        // ============ SESSION PERSISTENCE ============
        let liveChatContext = null; // Store live chat context for reconnection
        
        async function saveChatSession() {
            if (!chatStarted || !chatSDK) {
                localStorage.removeItem('chatWidgetSession');
                return;
            }
            
            // Get live chat context from SDK for reconnection
            try {
                liveChatContext = await chatSDK.getCurrentLiveChatContext();
                console.log(' Got live chat context:', liveChatContext);
            } catch (e) {
                console.log(' Could not get live chat context:', e);
            }
            
            const session = {
                userName,
                userEmail,
                chatStarted,
                messages: chatMessages,
                processedIds: Array.from(processedMessageIds),
                liveChatContext: liveChatContext, // Save context for reconnection
                timestamp: Date.now()
            };
            
            localStorage.setItem('chatWidgetSession', JSON.stringify(session));
            console.log(' Chat session saved with context');
        }

        async function restoreChatSession() {
            const saved = localStorage.getItem('chatWidgetSession');
            if (!saved) return false;
            
            try {
                const session = JSON.parse(saved);
                
                // Check if session is recent (less than 1 hour old)
                const oneHour = 60 * 60 * 1000;
                if (Date.now() - session.timestamp > oneHour) {
                    console.log(' Session expired - clearing');
                    localStorage.removeItem('chatWidgetSession');
                    return false;
                }
                
                // Check if we have live chat context to reconnect
                if (!session.liveChatContext) {
                    console.log(' No live chat context - cannot reconnect');
                    localStorage.removeItem('chatWidgetSession');
                    return false;
                }
                
                // Restore session state
                userName = session.userName || '';
                userEmail = session.userEmail || '';
                liveChatContext = session.liveChatContext;
                chatMessages = session.messages || [];
                processedMessageIds = new Set(session.processedIds || []);
                
                // Try to reconnect to existing chat session
                console.log(' Attempting to reconnect to existing chat...');
                showView('connecting');
                
                try {
                    const OmnichannelChatSDK = window.OmnichannelChatSDK;
                    chatSDK = new OmnichannelChatSDK(omnichannelConfig);
                    await chatSDK.initialize();
                    
                    // Set up message listener
                    chatSDK.onNewMessage((msg) => {
                        console.log(' onNewMessage event received:', msg);
                        console.log(' Message details - tags:', msg?.tags, 'type:', msg?.type || msg?.messageType, 'metadata:', msg?.metadata);
                        if (msg) processMessage(msg);
                    });
                    
                    chatSDK.onTypingEvent(() => {
                        typingIndicator.classList.add('active');
                        setTimeout(() => typingIndicator.classList.remove('active'), 3000);
                    });
                    
                    chatSDK.onAgentEndSession(() => { 
                        console.log('Agent ended session');
                        localStorage.removeItem('chatWidgetSession');
                        showView('ended'); 
                    });
                    
                    // VoiceVideoCallingSDK will be initialized after chat reconnects
                    // Incoming call listener is set up in initializeVoiceVideoCallingSDK
                    
                    // Reconnect to existing chat using saved context
                    await chatSDK.startChat({ liveChatContext: session.liveChatContext });
                    console.log(' Reconnected to existing chat session!');
                    
                    // Initialize VoiceVideoCallingSDK for incoming calls (after startChat)
                    await initializeVoiceVideoCallingSDK(chatSDK);
                    
                    chatStarted = true;
                    chatMessages = session.messages || [];
                    
                    // Restore UI - rebuild message display
                    showView('chat');
                    chatMessages.forEach(msg => {
                        if (msg.content) {
                            // Check if this is an Adaptive Card message
                            if (msg.isAdaptiveCard) {
                                // Re-render the Adaptive Card
                                const now = msg.timestamp ? new Date(msg.timestamp) : new Date();
                                const wrapper = document.createElement('div');
                                wrapper.className = `message-wrapper ${msg.isUser ? 'user' : 'agent'}`;
                                
                                // For bot messages, don't use agent avatar - let createAvatarElement use bot avatar
                                const isBotMessage = !msg.isUser && isBotSender(msg.senderName);
                                const avatarImage = msg.isUser ? adminSettings?.customerAvatar : (isBotMessage ? null : adminSettings?.agentAvatar);
                                const avatar = createAvatarElement(msg.isUser, msg.senderName, avatarImage);
                                
                                const contentDiv = document.createElement('div');
                                contentDiv.className = 'message-content';
                                
                                const senderDiv = document.createElement('div');
                                senderDiv.className = 'message-sender';
                                senderDiv.textContent = msg.isUser ? userName : (msg.senderName || 'Agent');
                                
                                const cardContainer = document.createElement('div');
                                cardContainer.className = 'message adaptive-card-message';
                                
                                try {
                                    const parsed = JSON.parse(msg.content);
                                    let cardPayload = null;
                                    
                                    if (parsed.type === 'AdaptiveCard') {
                                        cardPayload = parsed;
                                    } else if (parsed.attachments && Array.isArray(parsed.attachments)) {
                                        const cardAttachment = parsed.attachments.find(att => 
                                            att.contentType === 'application/vnd.microsoft.card.adaptive' && att.content
                                        );
                                        if (cardAttachment) {
                                            cardPayload = cardAttachment.content;
                                        }
                                    }
                                    
                                    if (cardPayload && adaptiveCardRenderer) {
                                        adaptiveCardRenderer.parse(cardPayload);
                                        
                                        // Set up action handlers for restored cards
                                        adaptiveCardRenderer.onExecuteAction = async (action) => {
                                            console.log('Restored card action:', action);
                                            
                                            if (action instanceof AdaptiveCards.SubmitAction) {
                                                const data = action.data;
                                                if (data && chatSDK && chatStarted) {
                                                    try {
                                                        // Disable the card
                                                        const cardElement = cardContainer.querySelector('.ac-adaptiveCard');
                                                        if (cardElement) {
                                                            cardElement.style.opacity = '0.6';
                                                            cardElement.style.pointerEvents = 'none';
                                                        }
                                                        
                                                        const actionId = data.actionSubmitId || action.title || 'Submit';
                                                        const displayData = Object.entries(data)
                                                            .filter(([key, value]) => key !== 'actionSubmitId' && value)
                                                            .map(([key, value]) => `${key}: ${value}`)
                                                            .join('\n');
                                                        
                                                        // Send with Adaptive Card metadata (official SDK format)
                                                        const content = JSON.stringify({value: data});
                                                        await chatSDK.sendMessage({ 
                                                            content: content,
                                                            metadata: {
                                                                'microsoft.azure.communication.chat.bot.contenttype': 'azurebotservice.adaptivecard'
                                                            }
                                                        });
                                                        
                                                        const displayMessage = displayData ? `**${actionId}**\n${displayData}` : actionId;
                                                        addMessage(displayMessage, true, userName, null);
                                                    } catch (error) {
                                                        console.error('Error:', error);
                                                        addMessage(' Failed to submit.', false, 'System', null);
                                                    }
                                                }
                                            } else if (action instanceof AdaptiveCards.OpenUrlAction && action.url) {
                                                window.open(action.url, '_blank');
                                            }
                                        };
                                        
                                        const renderedCard = adaptiveCardRenderer.render();
                                        if (renderedCard) {
                                            cardContainer.appendChild(renderedCard);
                                        }
                                    }
                                } catch (error) {
                                    console.error('Error re-rendering Adaptive Card:', error);
                                    cardContainer.innerHTML = '<p style="color: #e74c3c;"> Card could not be restored</p>';
                                }
                                
                                const timeDiv = document.createElement('div');
                                timeDiv.className = 'message-time';
                                timeDiv.textContent = formatTime(now);
                                
                                contentDiv.appendChild(senderDiv);
                                contentDiv.appendChild(cardContainer);
                                contentDiv.appendChild(timeDiv);
                                
                                wrapper.appendChild(avatar);
                                wrapper.appendChild(contentDiv);
                                typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
                            } else {
                                // Regular text message
                                const now = msg.timestamp ? new Date(msg.timestamp) : new Date();
                                const wrapper = document.createElement('div');
                                wrapper.className = `message-wrapper ${msg.isUser ? 'user' : 'agent'}`;
                                
                                // For bot messages, don't use agent avatar - let createAvatarElement use bot avatar
                                const isBotMessage = !msg.isUser && isBotSender(msg.senderName);
                                const avatarImage = msg.isUser ? adminSettings?.customerAvatar : (isBotMessage ? null : adminSettings?.agentAvatar);
                                const avatar = createAvatarElement(msg.isUser, msg.senderName, avatarImage);
                                
                                const content = document.createElement('div');
                                content.className = 'message-content';
                                content.innerHTML = `
                                    <div class="message-sender">${msg.isUser ? userName : (msg.senderName || 'Agent')}</div>
                                    <div class="message ${msg.isUser ? 'user' : 'agent'}">${msg.content}</div>
                                    <div class="message-time">${formatTime(now)}</div>
                                `;
                                wrapper.appendChild(avatar);
                                wrapper.appendChild(content);
                                typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
                            }
                        }
                    });
                    
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    
                    // Start polling for new messages
                    setInterval(pollMessages, 3000);
                    
                    console.log(' Chat session fully restored with', chatMessages.length, 'messages');
                    return true;
                    
                } catch (reconnectError) {
                    console.error(' Failed to reconnect:', reconnectError);
                    localStorage.removeItem('chatWidgetSession');
                    showView('prechat');
                    return false;
                }
                
            } catch (error) {
                console.error(' Error restoring session:', error);
                localStorage.removeItem('chatWidgetSession');
            }
            
            return false;
        }

        async function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file || !chatSDK || !chatStarted) return;
            try {
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    if (file.type.startsWith('image/')) { addImageMessage({ name: file.name, url: ev.target.result }, true, userName, null); }
                };
                reader.readAsDataURL(file);
                await chatSDK.uploadFileAttachment(file);
            } catch (err) { console.error('File upload error:', err); alert('Failed to upload file'); }
            fileInput.value = '';
        }

        async function initializeChat(name, email, question) {
            try {
                // Set global userName and userEmail (important when pre-chat form is disabled)
                userName = name;
                userEmail = email;
                
                showView('connecting');
                chatMessages = [];
                processedMessageIds.clear(); // Clear any previously tracked messages
                const OmnichannelChatSDK = window.OmnichannelChatSDK;
                chatSDK = new OmnichannelChatSDK(omnichannelConfig);
                await chatSDK.initialize();
                console.log('SDK initialized');
                
                // Set up message listener BEFORE starting chat
                chatSDK.onNewMessage((msg) => {
                    console.log(' onNewMessage event received:', msg);
                    console.log(' Message details - tags:', msg?.tags, 'type:', msg?.type || msg?.messageType, 'metadata:', msg?.metadata, 'role:', msg?.role, 'id:', msg?.messageId || msg?.id);
                    if (msg) {
                        processMessage(msg);
                    }
                });
                
                chatSDK.onTypingEvent(() => {
                    console.log('Typing event received');
                    typingIndicator.classList.add('active');
                    setTimeout(() => typingIndicator.classList.remove('active'), 3000);
                });
                
                chatSDK.onAgentEndSession(() => { 
                    console.log('Agent ended session');
                    localStorage.removeItem('chatWidgetSession'); // Clear session when ended
                    showView('ended'); 
                });
                
                // Pre-load the VoiceVideoCallingSDK (but don't initialize yet - needs chat token from startChat)
                await preloadVoiceVideoCallingSDK(chatSDK);
                
                // D365 Context - uses proper field identifiers for contact authentication
                // 'Name' and 'emailaddress1' allow D365 to automatically populate contact records
                const customContext = {
                    'emailaddress1': { value: email, isDisplayable: true }, // Contact email in Dynamics 365
                    'Name': { value: name, isDisplayable: true }, // Contact name in Dynamics 365
                    'Authenticated': { value: 'Authenticated', isDisplayable: true }, // Authentication status
                    'InitialQuestion': { value: question || '', isDisplayable: true }
                };
                
                // Also store in localStorage for standard mode context provider
                localStorage.setItem('d365ChatContext', JSON.stringify({ name, email, question }));
                
                await chatSDK.startChat({ customContext });
                console.log('Chat started with D365 context:', customContext);
                chatStarted = true;
                
                // NOW initialize VoiceVideoCallingSDK (AFTER startChat - chat token is now valid)
                await initializeVoiceVideoCallingSDK(chatSDK);
                
                // Voice/video call buttons removed - only agents can initiate calls
                
                saveChatSession(); // Save initial session state
                showView('chat');
                if (question) { await sendMessageText(question); }
                setInterval(pollMessages, 3000);
            } catch (error) {
                console.error('Chat init error:', error);
                alert('Failed to start chat. Please try again.');
                showView('prechat');
                startBtn.disabled = false; startBtn.textContent = 'Start Chat';
            }
        }

        async function sendMessageText(text) {
            if (!text || !chatSDK || !chatStarted) return;
            addMessage(text, true, userName, null);
            try { await chatSDK.sendMessage({ content: text }); } catch (e) { console.error('Send error:', e); }
        }
        
        // ============ INCOMING CALL HANDLING (Agent-Initiated) ============
        
        // Global VoiceVideoCallingSDK instance
        let VoiceVideoCallingSDK = null;
        
        // Step 1: Pre-load the SDK before startChat (but don't initialize)
        async function preloadVoiceVideoCallingSDK(sdk) {
            console.log(' Pre-loading VoiceVideoCallingSDK...');
            
            try {
                if (!sdk.getVoiceVideoCalling) {
                    console.log(' getVoiceVideoCalling not available on SDK');
                    return;
                }
                
                VoiceVideoCallingSDK = await sdk.getVoiceVideoCalling();
                console.log(' VoiceVideoCallingSDK pre-loaded:', VoiceVideoCallingSDK ? 'Yes' : 'No');
                
            } catch (err) {
                console.log(' VoiceVideoCalling pre-load error:', err);
                
                if (err.message === 'UnsupportedPlatform') {
                    console.log(' Voice/Video calling not supported on this platform');
                } else if (err.message === 'FeatureDisabled') {
                    console.log(' Voice/Video calling is disabled in admin settings');
                }
            }
        }
        
        // Step 2: Initialize the SDK AFTER startChat (chat token is now valid)
        async function initializeVoiceVideoCallingSDK(sdk) {
            console.log(' Initializing VoiceVideoCallingSDK...');
            
            if (!VoiceVideoCallingSDK) {
                console.log(' VoiceVideoCallingSDK was not pre-loaded');
                return;
            }
            
            try {
                // Get chat token - THIS IS ONLY VALID AFTER startChat()
                const chatToken = await sdk.getChatToken();
                console.log(' Chat token obtained:', chatToken ? 'Yes' : 'No');
                
                if (!chatToken) {
                    console.error(' Failed to get chat token for VoiceVideoCalling');
                    return;
                }
                
                // Initialize VoiceVideoCallingSDK with required parameters
                // This registers the customer endpoint with ACS (Azure Communication Services)
                await VoiceVideoCallingSDK.initialize({
                    chatToken: chatToken,
                    selfVideoHTMLElementId: 'localVideo',      // HTML element for local video
                    remoteVideoHTMLElementId: 'remoteVideo',   // HTML element for remote video
                    OCClient: sdk.OCClient
                });
                console.log(' VoiceVideoCallingSDK initialized successfully');
                
                // IMPORTANT: Also set element IDs on proxyInstance directly
                if (VoiceVideoCallingSDK.proxyInstance) {
                    VoiceVideoCallingSDK.proxyInstance._selfVideoHTMLElementId = 'localVideo';
                    VoiceVideoCallingSDK.proxyInstance._remoteVideoHTMLElementId = 'remoteVideo';
                    console.log(' Video element IDs configured on proxyInstance');
                }
                
                // Try to find and expose LocalVideoStream class from ACS SDK
                console.log(' Searching for LocalVideoStream class...');
                
                // Method 1: Check if CallingBundle exposed it
                if (window.LocalVideoStream) {
                    console.log(' Found window.LocalVideoStream');
                }
                
                // Method 2: Search global object for ACS exports
                for (const key in window) {
                    try {
                        if (key.includes('LocalVideoStream') && typeof window[key] === 'function') {
                            console.log(' Found LocalVideoStream at window.' + key);
                            window.LocalVideoStream = window[key];
                            break;
                        }
                        // Also check for ACS namespace
                        if (key === 'ACS' || key.includes('AzureCommunication')) {
                            const obj = window[key];
                            if (obj && obj.LocalVideoStream) {
                                console.log(' Found LocalVideoStream in', key);
                                window.LocalVideoStream = obj.LocalVideoStream;
                                break;
                            }
                        }
                    } catch (e) {}
                }
                
                // Log available SDK methods to help debug video detection
                console.log(' Available SDK methods:', Object.keys(VoiceVideoCallingSDK).filter(k => typeof VoiceVideoCallingSDK[k] === 'function'));
                
                // Set up incoming call listener - THIS IS THE KEY PART
                // This registers the callback that fires when agent initiates a call
                VoiceVideoCallingSDK.onCallAdded((callInfo) => {
                    console.log(' ========================================');
                    console.log(' INCOMING CALL DETECTED via onCallAdded!');
                    console.log(' ========================================');
                    
                    try {
                        // DEEP INSPECTION: Log everything about callInfo
                        console.log(' callInfo raw:', callInfo);
                        console.log(' callInfo type:', typeof callInfo);
                        
                        if (callInfo) {
                            // All own properties
                            console.log(' callInfo keys:', Object.keys(callInfo));
                            
                            // Full JSON dump
                            try {
                                console.log(' callInfo JSON:', JSON.stringify(callInfo, null, 2));
                            } catch (e) {
                                console.log(' callInfo not JSON-serializable');
                            }
                            
                            // Check all properties including nested
                            for (const key of Object.keys(callInfo)) {
                                const val = callInfo[key];
                                console.log(` callInfo.${key}:`, val, '(type:', typeof val + ')');
                                // If it's an object, dive deeper
                                if (val && typeof val === 'object') {
                                    try {
                                        console.log(`   ${key} nested keys:`, Object.keys(val));
                                        for (const subKey of Object.keys(val)) {
                                            console.log(`   ${key}.${subKey}:`, val[subKey]);
                                        }
                                    } catch (e) {}
                                }
                            }
                            
                            // Check prototype methods
                            const proto = Object.getPrototypeOf(callInfo);
                            if (proto && proto !== Object.prototype) {
                                console.log(' callInfo prototype methods:', Object.getOwnPropertyNames(proto));
                            }
                        }
                        
                        // DEEP INSPECTION: Check VoiceVideoCallingSDK for any call-related state
                        console.log(' VoiceVideoCallingSDK methods:', Object.keys(VoiceVideoCallingSDK));
                        
                        // Try to access any call state
                        const sdkMethods = ['getCurrentCall', 'getCall', 'getCallInfo', 'getIncomingCall',
                                           'getCallState', 'getCallType', 'getMediaType', 'getVideoState',
                                           'isVideoEnabled', 'hasVideoCapability', 'getCallFeatures'];
                        for (const method of sdkMethods) {
                            if (typeof VoiceVideoCallingSDK[method] === 'function') {
                                try {
                                    const result = VoiceVideoCallingSDK[method]();
                                    console.log(` SDK.${method}():`, result);
                                    if (result && typeof result === 'object') {
                                        console.log(`   ${method} keys:`, Object.keys(result));
                                    }
                                } catch (e) {
                                    console.log(` SDK.${method}() error:`, e.message);
                                }
                            }
                        }
                        
                        // Determine if video call - check multiple indicators
                        let hasVideo = false;
                        
                        // Check the callInfo parameter passed to onCallAdded
                        if (callInfo) {
                            hasVideo = callInfo.isVideoCall || callInfo.hasVideo || 
                                       callInfo.videoEnabled || callInfo.isVideo ||
                                       callInfo.callType === 'video' || callInfo.type === 'video' ||
                                       callInfo.mediaType === 'video' || callInfo.withVideo ||
                                       (callInfo.callClientName && callInfo.callClientName.toLowerCase().includes('video')) ||
                                       false;
                                       
                            // Check nested objects for video indicators
                            if (!hasVideo && callInfo.options) {
                                hasVideo = callInfo.options.videoEnabled || callInfo.options.isVideo || 
                                           callInfo.options.withVideo || false;
                            }
                            if (!hasVideo && callInfo.callOptions) {
                                hasVideo = callInfo.callOptions.videoEnabled || callInfo.callOptions.isVideo ||
                                           callInfo.callOptions.withVideo || false;
                            }
                            if (!hasVideo && callInfo.mediaOptions) {
                                hasVideo = callInfo.mediaOptions.video || callInfo.mediaOptions.videoEnabled || false;
                            }
                        }
                        
                        // Try to get call info from SDK methods
                        if (!hasVideo && VoiceVideoCallingSDK.isRemoteVideoEnabled) {
                            try {
                                hasVideo = VoiceVideoCallingSDK.isRemoteVideoEnabled();
                                console.log(' isRemoteVideoEnabled():', hasVideo);
                            } catch (e) { console.log(' isRemoteVideoEnabled error:', e); }
                        }
                        
                        // Check SDK state for video capability
                        if (!hasVideo && VoiceVideoCallingSDK.isVideoCall) {
                            try {
                                hasVideo = VoiceVideoCallingSDK.isVideoCall();
                                console.log(' isVideoCall():', hasVideo);
                            } catch (e) { console.log(' isVideoCall error:', e); }
                        }
                        
                        // Check if local video is being requested
                        if (!hasVideo && VoiceVideoCallingSDK.isLocalVideoEnabled) {
                            try {
                                hasVideo = VoiceVideoCallingSDK.isLocalVideoEnabled();
                                console.log(' isLocalVideoEnabled():', hasVideo);
                            } catch (e) { console.log(' isLocalVideoEnabled error:', e); }
                        }
                        
                        console.log(' ========================================');
                        console.log(' Final video call detection:', hasVideo);
                        console.log(' ========================================');
                        
                        showIncomingCallNotification({ 
                            isVideo: hasVideo, 
                            agentName: currentAgentName || 'Agent',
                            sdk: VoiceVideoCallingSDK
                        });
                    } catch (err) {
                        console.error(' Error in onCallAdded handler:', err);
                    }
                });
                
                // Set up call disconnected listener - handles both connected calls ending 
                // AND when agent cancels before customer answers
                VoiceVideoCallingSDK.onCallDisconnected(() => {
                    console.log(' Call disconnected by remote party');
                    
                    // Hide incoming call notification if it's still showing
                    const notification = document.getElementById('incomingCallNotification');
                    if (notification && notification.style.display !== 'none') {
                        console.log(' Hiding incoming call notification (agent cancelled)');
                        notification.style.display = 'none';
                        pendingCallData = null;
                    }
                    
                    // End the call if we're in a call
                    if (isInCall) {
                        endCall();
                    }
                });
                
                // Set up call removed listener (if available) - fires when call is cancelled
                if (VoiceVideoCallingSDK.onCallRemoved) {
                    VoiceVideoCallingSDK.onCallRemoved(() => {
                        console.log(' Call removed (agent cancelled the call)');
                        
                        // Hide incoming call notification
                        const notification = document.getElementById('incomingCallNotification');
                        if (notification) {
                            notification.style.display = 'none';
                        }
                        pendingCallData = null;
                        
                        if (isInCall) {
                            endCall();
                        }
                    });
                }
                
                // Set up call ended listener (if available)
                if (VoiceVideoCallingSDK.onCallEnded) {
                    VoiceVideoCallingSDK.onCallEnded(() => {
                        console.log(' Call ended event received');
                        
                        // Hide incoming call notification if showing
                        const notification = document.getElementById('incomingCallNotification');
                        if (notification) {
                            notification.style.display = 'none';
                        }
                        pendingCallData = null;
                        
                        if (isInCall) {
                            endCall();
                        }
                    });
                }
                
                // Set up call connected listener to start video after connection
                if (VoiceVideoCallingSDK.onCallConnected) {
                    VoiceVideoCallingSDK.onCallConnected(async () => {
                        console.log(' Call connected event received');
                        callStatus.textContent = 'Connected';
                        
                        // If this is a video call, ensure video is started
                        if (isVideoCall && VoiceVideoCallingSDK.startVideo) {
                            console.log(' Auto-starting video after call connected...');
                            try {
                                await VoiceVideoCallingSDK.startVideo();
                                console.log(' Video started after connection');
                            } catch (err) {
                                console.warn(' Could not auto-start video:', err);
                            }
                        }
                    });
                }
                
                // Set up remote video stream listeners
                if (VoiceVideoCallingSDK.onRemoteVideoStreamAdded) {
                    VoiceVideoCallingSDK.onRemoteVideoStreamAdded(async (streamInfo) => {
                        console.log(' Remote video stream added - showing remote video');
                        console.log(' Stream info:', streamInfo);
                        console.log(' Stream info type:', typeof streamInfo);
                        if (streamInfo) {
                            console.log(' Stream info keys:', Object.keys(streamInfo));
                        }
                        
                        remoteVideo.style.display = 'block';
                        callAvatar.style.display = 'none';
                        
                        // IMPORTANT: Ensure element IDs are set on proxyInstance
                        if (VoiceVideoCallingSDK.proxyInstance) {
                            VoiceVideoCallingSDK.proxyInstance._selfVideoHTMLElementId = 'localVideo';
                            VoiceVideoCallingSDK.proxyInstance._remoteVideoHTMLElementId = 'remoteVideo';
                            console.log(' Element IDs confirmed on proxyInstance');
                        }
                        
                        // Try to get the actual call object and render remote video
                        if (VoiceVideoCallingSDK.proxyInstance?._callClients) {
                            for (const [clientName, client] of VoiceVideoCallingSDK.proxyInstance._callClients) {
                                if (client._calls) {
                                    for (const [callId, call] of client._calls) {
                                        console.log(' Found call in onRemoteVideoStreamAdded:', callId);
                                        
                                        // Try to access remote participants
                                        if (call.remoteParticipants) {
                                            console.log(' Remote participants:', call.remoteParticipants.length);
                                            
                                            for (const participant of call.remoteParticipants) {
                                                console.log(' Checking participant:', participant);
                                                
                                                if (participant.videoStreams) {
                                                    for (const stream of participant.videoStreams) {
                                                        console.log(' Found video stream:', stream);
                                                        console.log(' Stream.isAvailable:', stream.isAvailable);
                                                        
                                                        if (stream.isAvailable) {
                                                            // Try getMediaStream
                                                            if (typeof stream.getMediaStream === 'function') {
                                                                try {
                                                                    const ms = await stream.getMediaStream();
                                                                    if (ms instanceof MediaStream) {
                                                                        console.log(' Got MediaStream in onRemoteVideoStreamAdded!');
                                                                        remoteVideo.srcObject = ms;
                                                                        remoteVideo.play().catch(e => {});
                                                                    }
                                                                } catch (e) {
                                                                    console.log(' getMediaStream error:', e);
                                                                }
                                                            }
                                                        }
                                                        
                                                        // Set up listener for when stream becomes available
                                                        if (stream.on) {
                                                            stream.on('isAvailableChanged', async () => {
                                                                console.log(' Stream availability changed:', stream.isAvailable);
                                                                if (stream.isAvailable && typeof stream.getMediaStream === 'function') {
                                                                    try {
                                                                        const ms = await stream.getMediaStream();
                                                                        if (ms instanceof MediaStream) {
                                                                            console.log(' Got MediaStream after availability change!');
                                                                            remoteVideo.srcObject = ms;
                                                                            remoteVideo.play().catch(e => {});
                                                                        }
                                                                    } catch (e) {
                                                                        console.log(' getMediaStream error:', e);
                                                                    }
                                                                }
                                                            });
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Call renderVideoStreams as backup
                        if (VoiceVideoCallingSDK.renderVideoStreams) {
                            try {
                                console.log(' Calling renderVideoStreams...');
                                await VoiceVideoCallingSDK.renderVideoStreams();
                                console.log(' renderVideoStreams completed');
                            } catch (err) {
                                console.warn(' renderVideoStreams error:', err);
                            }
                        }
                        
                        // Also update the call status to indicate video is active
                        if (isInCall) {
                            callStatus.textContent = 'Video Call - Connected';
                            isVideoCall = true;
                        }
                    });
                }
                
                if (VoiceVideoCallingSDK.onRemoteVideoStreamRemoved) {
                    VoiceVideoCallingSDK.onRemoteVideoStreamRemoved(() => {
                        console.log(' Remote video stream removed');
                        remoteVideo.style.display = 'none';
                        if (isInCall) {
                            callAvatar.style.display = 'flex';
                        }
                    });
                }
                
                // Set up local video stream listeners
                if (VoiceVideoCallingSDK.onLocalVideoStreamAdded) {
                    VoiceVideoCallingSDK.onLocalVideoStreamAdded(async (streamInfo) => {
                        console.log(' Local video stream added');
                        console.log(' Local stream info:', streamInfo);
                        if (streamInfo) {
                            console.log(' Local stream info keys:', Object.keys(streamInfo));
                        }
                        
                        localVideo.style.display = 'block';
                        
                        // Try createView for local video
                        if (VoiceVideoCallingSDK.createView) {
                            try {
                                console.log(' Attempting SDK createView for local video...');
                                const view = await VoiceVideoCallingSDK.createView(streamInfo, { 
                                    scalingMode: 'Fit',
                                    isMirrored: true 
                                });
                                if (view && view.target) {
                                    localVideo.parentElement.appendChild(view.target);
                                    console.log(' Local video rendered via createView');
                                }
                            } catch (err) {
                                console.warn(' Local createView failed:', err);
                            }
                        }
                        
                        // Try renderLocalVideo if available
                        if (VoiceVideoCallingSDK.renderLocalVideo) {
                            try {
                                console.log(' Attempting SDK renderLocalVideo...');
                                await VoiceVideoCallingSDK.renderLocalVideo(localVideo);
                                console.log(' Local video rendered via renderLocalVideo');
                            } catch (err) {
                                console.warn(' renderLocalVideo failed:', err);
                            }
                        }
                        
                        // Try various methods to get MediaStream
                        const localMethods = ['getLocalVideoStream', 'getLocalStream', 'getLocalMediaStream'];
                        for (const method of localMethods) {
                            if (typeof VoiceVideoCallingSDK[method] === 'function') {
                                try {
                                    const ms = await VoiceVideoCallingSDK[method]();
                                    if (ms instanceof MediaStream) {
                                        localVideo.srcObject = ms;
                                        console.log(` Local stream via ${method}`);
                                        break;
                                    }
                                } catch (err) {
                                    console.log(` ${method} error:`, err.message);
                                }
                            }
                        }
                        
                        // Check streamInfo for MediaStream
                        if (streamInfo) {
                            if (streamInfo instanceof MediaStream) {
                                localVideo.srcObject = streamInfo;
                                console.log(' Local streamInfo was MediaStream');
                            } else if (typeof streamInfo.getMediaStream === 'function') {
                                try {
                                    localVideo.srcObject = await streamInfo.getMediaStream();
                                    console.log(' Local stream via streamInfo.getMediaStream()');
                                } catch (e) {}
                            } else if (streamInfo.stream instanceof MediaStream) {
                                localVideo.srcObject = streamInfo.stream;
                                console.log(' Local stream via streamInfo.stream');
                            }
                        }
                    });
                }
                
                if (VoiceVideoCallingSDK.onLocalVideoStreamRemoved) {
                    VoiceVideoCallingSDK.onLocalVideoStreamRemoved(() => {
                        console.log(' Local video stream removed');
                        localVideo.style.display = 'none';
                        localVideo.srcObject = null;
                    });
                }
                
                console.log(' All VoiceVideoCallingSDK event listeners configured');
                
            } catch (err) {
                console.error(' VoiceVideoCallingSDK initialization error:', err);
            }
        }
        
        function showIncomingCallNotification(callData) {
            console.log(' showIncomingCallNotification called with:', callData);
            
            try {
                // Get DOM elements (in case they weren't captured at init time)
                const notificationEl = document.getElementById('incomingCallNotification');
                const titleEl = document.getElementById('incomingCallTitle');
                const subtitleEl = document.getElementById('incomingCallSubtitle');
                const containerEl = document.getElementById('chatContainer');
                
                console.log(' DOM elements found - notification:', !!notificationEl, 'title:', !!titleEl, 'subtitle:', !!subtitleEl, 'container:', !!containerEl);
                
                if (!notificationEl) {
                    console.error(' incomingCallNotification element not found!');
                    return;
                }
                
                // Make sure the chat container is open
                if (containerEl && !containerEl.classList.contains('open')) {
                    console.log(' Opening chat container for incoming call...');
                    containerEl.classList.add('open');
                }
                
                pendingCallData = callData;
                
                // Note: D365 SDK doesn't reliably tell us if it's video or voice
                // So we show a generic "Incoming Call" and let user choose how to answer
                const agentName = callData?.agentName || callData?.from || 'Agent';
                
                console.log(' Setting notification for incoming call from:', agentName);
                
                if (titleEl) titleEl.textContent = 'Incoming Call';
                if (subtitleEl) subtitleEl.textContent = `${agentName} is calling you...`;
                
                // Use a combined phone/video icon
                const iconEl = notificationEl.querySelector('.incoming-call-icon');
                if (iconEl) {
                    // Phone icon - user will choose video or voice when accepting
                    iconEl.innerHTML = '<svg viewBox="0 0 24 24" width="22" height="22"><path fill="white" d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-1.57 1.97c-2.83-1.35-5.48-3.9-6.89-6.83l1.95-1.66c.27-.28.35-.67.24-1.02-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19C3.65 3 3 3.24 3 3.99 3 13.28 10.73 21 20.01 21c.71 0 .99-.63.99-1.18v-3.45c0-.54-.45-.99-.99-.99z"/></svg>';
                }
                
                // Make sure the notification is visible with high z-index
                notificationEl.style.display = 'block';
                notificationEl.style.visibility = 'visible';
                notificationEl.style.opacity = '1';
                notificationEl.style.zIndex = '10000';
                notificationEl.style.position = 'absolute';
                notificationEl.style.top = '60px';
                notificationEl.style.left = '0';
                notificationEl.style.right = '0';
                
                console.log(' Notification display set to:', notificationEl.style.display);
                console.log(' Notification offsetHeight:', notificationEl.offsetHeight);
                console.log(' Notification banner should now be visible');
                
                // Play notification sound if available
                playNotificationSound();
                
            } catch (err) {
                console.error(' Error showing incoming call notification:', err);
            }
        }
        
        async function acceptIncomingCall(withVideo = false) {
            console.log(' Accepting incoming call...');
            console.log(' VoiceVideoCallingSDK available:', !!VoiceVideoCallingSDK);
            console.log(' pendingCallData:', pendingCallData);
            console.log(' User chose to accept with video:', withVideo);
            
            // Set isVideoCall based on user's choice
            isVideoCall = withVideo;
            
            incomingCallNotification.style.display = 'none';
            
            try {
                // DON'T request camera/mic permissions here - let the SDK handle it
                // Pre-grabbing the camera causes "Device in use" conflicts with the SDK
                console.log(' Letting SDK handle media permissions...');
                
                // Show call UI with connecting state
                callContainer.classList.add('active');
                callConnecting.style.display = 'flex';
                callAvatar.style.display = 'none';
                remoteVideo.style.display = 'none';
                localVideo.style.display = 'none';
                toggleCameraBtn.style.display = isVideoCall ? 'flex' : 'none';
                callStatus.textContent = 'Connecting...';
                
                // Use the global VoiceVideoCallingSDK that was initialized in initializeVoiceVideoCallingSDK
                if (!VoiceVideoCallingSDK) {
                    throw new Error('VoiceVideoCallingSDK not initialized');
                }
                
                // Accept the call using the SDK's acceptCall method
                // The SDK handles media permissions internally
                const acceptCallConfig = {
                    withVideo: isVideoCall // Accept with video if it's a video call
                };
                
                console.log(' Calling VoiceVideoCallingSDK.acceptCall with config:', acceptCallConfig);
                await VoiceVideoCallingSDK.acceptCall(acceptCallConfig);
                console.log(' VoiceVideoCallingSDK.acceptCall completed successfully');
                
                // DEEP INSPECTION: Log all available SDK methods after call is accepted
                console.log(' ========== POST-ACCEPT SDK INSPECTION ==========');
                console.log(' SDK keys:', Object.keys(VoiceVideoCallingSDK));
                
                // Check for video rendering methods
                const videoMethods = [
                    'createView', 'disposeView', 'renderView',
                    'renderRemoteVideo', 'renderLocalVideo', 'renderVideoStreams',
                    'getRemoteVideoStream', 'getLocalVideoStream',
                    'getRemoteParticipants', 'getRemoteParticipant',
                    'getCall', 'getCurrentCall', 'getCallInfo',
                    'startLocalVideoStream', 'stopLocalVideoStream',
                    'startRemoteVideoStream', 'stopRemoteVideoStream',
                    'createLocalVideoStream', 'createRemoteVideoStream',
                    'getVideoDevices', 'getCameras', 'getSelectedCamera',
                    'attachVideo', 'detachVideo', 'bindVideo'
                ];
                
                for (const method of videoMethods) {
                    if (typeof VoiceVideoCallingSDK[method] === 'function') {
                        console.log(` SDK.${method} = function `);
                    }
                }
                
                // Check if proxy has additional methods
                if (VoiceVideoCallingSDK.proxy) {
                    console.log(' SDK.proxy exists, checking its methods...');
                    console.log(' SDK.proxy keys:', Object.keys(VoiceVideoCallingSDK.proxy));
                }
                
                if (VoiceVideoCallingSDK.proxyInstance) {
                    console.log(' SDK.proxyInstance exists, checking...');
                    console.log(' SDK.proxyInstance type:', typeof VoiceVideoCallingSDK.proxyInstance);
                    if (typeof VoiceVideoCallingSDK.proxyInstance === 'object') {
                        console.log(' SDK.proxyInstance keys:', Object.keys(VoiceVideoCallingSDK.proxyInstance));
                        
                        // KEY DISCOVERY: Check the video element IDs the SDK expects
                        const pi = VoiceVideoCallingSDK.proxyInstance;
                        console.log(' _selfVideoHTMLElementId:', pi._selfVideoHTMLElementId);
                        console.log(' _remoteVideoHTMLElementId:', pi._remoteVideoHTMLElementId);
                        
                        // Set our element IDs so the SDK knows where to render!
                        console.log(' Setting our video element IDs on proxyInstance...');
                        pi._selfVideoHTMLElementId = 'localVideo';
                        pi._remoteVideoHTMLElementId = 'remoteVideo';
                        console.log(' Element IDs set: localVideo, remoteVideo');
                        
                        // Check _voiceVideoCallingStream for actual stream
                        if (pi._voiceVideoCallingStream) {
                            console.log(' _voiceVideoCallingStream exists!');
                            console.log(' _voiceVideoCallingStream:', pi._voiceVideoCallingStream);
                            console.log(' _voiceVideoCallingStream type:', typeof pi._voiceVideoCallingStream);
                            if (typeof pi._voiceVideoCallingStream === 'object') {
                                console.log(' _voiceVideoCallingStream keys:', Object.keys(pi._voiceVideoCallingStream));
                            }
                        }
                        
                        // Check _callClients for active call
                        if (pi._callClients) {
                            console.log(' _callClients:', pi._callClients);
                            if (pi._callClients instanceof Map) {
                                console.log(' _callClients is a Map with', pi._callClients.size, 'entries');
                                pi._callClients.forEach((value, key) => {
                                    console.log(` _callClients[${key}]:`, value);
                                    if (value && typeof value === 'object') {
                                        console.log(` _callClients[${key}] keys:`, Object.keys(value));
                                    }
                                });
                            }
                        }
                    }
                }
                
                // Try to get call agent or call object
                if (VoiceVideoCallingSDK.callAgent) {
                    console.log(' SDK.callAgent exists');
                    console.log(' SDK.callAgent keys:', Object.keys(VoiceVideoCallingSDK.callAgent));
                }
                
                if (VoiceVideoCallingSDK.call) {
                    console.log(' SDK.call exists');
                    console.log(' SDK.call keys:', Object.keys(VoiceVideoCallingSDK.call));
                }
                
                console.log(' ========== END POST-ACCEPT INSPECTION ==========');
                
                // Store reference for later use
                window.activeVoiceVideoCall = VoiceVideoCallingSDK;
                
                // Update state
                isInCall = true;
                callConnecting.style.display = 'none';
                callStatus.textContent = isVideoCall ? 'Video Call' : 'Voice Call';
                
                // Show appropriate UI based on call type
                if (!isVideoCall) {
                    callAvatar.style.display = 'flex';
                    callAvatar.textContent = getInitials(pendingCallData?.agentName || currentAgentName || 'Agent');
                }
                
                // For video calls, we need to explicitly start local video after accepting
                if (isVideoCall) {
                    console.log(' Starting local video for video call...');
                    
                    // Log all available methods on VoiceVideoCallingSDK for debugging
                    const allMethods = [];
                    for (const key in VoiceVideoCallingSDK) {
                        if (typeof VoiceVideoCallingSDK[key] === 'function') {
                            allMethods.push(key);
                        }
                    }
                    console.log(' All VoiceVideoCallingSDK methods:', allMethods);
                    
                    // Try to start local video via SDK
                    if (VoiceVideoCallingSDK.startVideo) {
                        try {
                            await VoiceVideoCallingSDK.startVideo();
                            console.log(' Local video started via SDK.startVideo');
                            localVideo.style.display = 'block';
                        } catch (videoErr) {
                            console.warn(' SDK.startVideo error:', videoErr);
                        }
                    }
                    
                    // Try startLocalVideo
                    if (!localVideo.srcObject && VoiceVideoCallingSDK.startLocalVideo) {
                        try {
                            await VoiceVideoCallingSDK.startLocalVideo();
                            console.log(' Local video started via SDK.startLocalVideo');
                            localVideo.style.display = 'block';
                        } catch (videoErr) {
                            console.warn(' SDK.startLocalVideo error:', videoErr);
                        }
                    }
                    
                    // Try toggleLocalVideo
                    if (!localVideo.srcObject && VoiceVideoCallingSDK.toggleLocalVideo) {
                        try {
                            const isVideoOn = VoiceVideoCallingSDK.isLocalVideoEnabled ? 
                                              VoiceVideoCallingSDK.isLocalVideoEnabled() : false;
                            if (!isVideoOn) {
                                await VoiceVideoCallingSDK.toggleLocalVideo();
                                console.log(' Local video toggled on via SDK.toggleLocalVideo');
                            }
                            localVideo.style.display = 'block';
                        } catch (videoErr) {
                            console.warn(' SDK.toggleLocalVideo error:', videoErr);
                        }
                    }
                    
                    // Check _voiceVideoCallingStream for methods
                    if (VoiceVideoCallingSDK.proxyInstance?._voiceVideoCallingStream) {
                        const stream = VoiceVideoCallingSDK.proxyInstance._voiceVideoCallingStream;
                        console.log(' _voiceVideoCallingStream:', stream);
                        console.log(' _voiceVideoCallingStream methods:', Object.keys(stream));
                        
                        // Check if it has startVideo or related methods
                        if (stream._voiceVideoCalling) {
                            const vvc = stream._voiceVideoCalling;
                            console.log(' _voiceVideoCalling:', vvc);
                            console.log(' _voiceVideoCalling keys:', Object.keys(vvc));
                        }
                    }
                    
                    // The remote video should be handled by onRemoteVideoStreamAdded event
                    // But let's check if remote video is already available
                    if (VoiceVideoCallingSDK.isRemoteVideoEnabled) {
                        const remoteVideoEnabled = VoiceVideoCallingSDK.isRemoteVideoEnabled();
                        console.log(' Remote video enabled:', remoteVideoEnabled);
                        if (remoteVideoEnabled) {
                            remoteVideo.style.display = 'block';
                            callAvatar.style.display = 'none';
                        }
                    }
                    
                    // Try to render video streams if the SDK has this method
                    // This is sometimes needed to attach streams to HTML elements
                    if (VoiceVideoCallingSDK.renderVideoStreams) {
                        try {
                            await VoiceVideoCallingSDK.renderVideoStreams();
                            console.log(' Video streams rendered');
                        } catch (renderErr) {
                            console.warn(' Could not render video streams:', renderErr);
                        }
                    }
                    
                    // Also try createView for local and remote video if available
                    if (VoiceVideoCallingSDK.createLocalVideoStream) {
                        try {
                            const localStream = await VoiceVideoCallingSDK.createLocalVideoStream();
                            if (localStream && localStream.getMediaStream) {
                                localVideo.srcObject = localStream.getMediaStream();
                                console.log(' Local video stream attached directly');
                            }
                        } catch (streamErr) {
                            console.warn(' Could not create local video stream:', streamErr);
                        }
                    }
                }
                
                startCallDuration();
                
                console.log(' Call accepted and connected');
                
                // DEEP INSPECTION: Find the actual video streams after call connects
                console.log(' ========== DEEP STREAM INSPECTION ==========');
                
                // Helper function to render remote video streams from ACS call object
                async function renderRemoteVideoFromCall(call) {
                    console.log(' Attempting to render remote video from call object...');
                    console.log(' Call:', call);
                    console.log(' Call keys:', Object.keys(call));
                    
                    // Check for remoteParticipants
                    let participants = null;
                    if (call.remoteParticipants) {
                        participants = call.remoteParticipants;
                    } else if (call._remoteParticipants) {
                        participants = call._remoteParticipants;
                    } else if (typeof call.getRemoteParticipants === 'function') {
                        participants = call.getRemoteParticipants();
                    }
                    
                    if (participants) {
                        console.log(' Remote participants found:', participants);
                        console.log(' Participants type:', typeof participants);
                        
                        // Handle both array and Map
                        const participantList = participants instanceof Map 
                            ? Array.from(participants.values()) 
                            : (Array.isArray(participants) ? participants : [participants]);
                        
                        console.log(' Participant count:', participantList.length);
                        
                        for (const participant of participantList) {
                            console.log(' Processing participant:', participant);
                            if (participant && typeof participant === 'object') {
                                console.log(' Participant keys:', Object.keys(participant));
                            }
                            
                            // Get video streams
                            let videoStreams = null;
                            if (participant.videoStreams) {
                                videoStreams = participant.videoStreams;
                            } else if (participant._videoStreams) {
                                videoStreams = participant._videoStreams;
                            } else if (typeof participant.getVideoStreams === 'function') {
                                videoStreams = participant.getVideoStreams();
                            }
                            
                            if (videoStreams) {
                                console.log(' Video streams found:', videoStreams);
                                const streamList = Array.isArray(videoStreams) ? videoStreams : [videoStreams];
                                
                                for (const stream of streamList) {
                                    console.log(' Processing video stream:', stream);
                                    if (stream && typeof stream === 'object') {
                                        console.log(' Stream keys:', Object.keys(stream));
                                        console.log(' Stream isAvailable:', stream.isAvailable);
                                        console.log(' Stream mediaStreamType:', stream.mediaStreamType);
                                    }
                                    
                                    // Try to get MediaStream directly
                                    if (stream instanceof MediaStream) {
                                        console.log(' Stream IS a MediaStream!');
                                        remoteVideo.srcObject = stream;
                                        remoteVideo.play().catch(e => console.log('Play error:', e));
                                        return true;
                                    }
                                    
                                    // Try getMediaStream() method
                                    if (typeof stream.getMediaStream === 'function') {
                                        try {
                                            const ms = await stream.getMediaStream();
                                            if (ms instanceof MediaStream) {
                                                console.log(' Got MediaStream via getMediaStream()!');
                                                remoteVideo.srcObject = ms;
                                                remoteVideo.play().catch(e => console.log('Play error:', e));
                                                return true;
                                            }
                                        } catch (e) {
                                            console.log(' getMediaStream error:', e);
                                        }
                                    }
                                    
                                    // Try createView() - ACS pattern for rendering
                                    if (call.createView || (stream && typeof stream.createView === 'function')) {
                                        try {
                                            console.log(' Trying createView for remote stream...');
                                            const createViewFn = stream.createView || call.createView;
                                            const view = await createViewFn(stream, { scalingMode: 'Fit' });
                                            if (view && view.target) {
                                                console.log(' createView succeeded, appending to DOM');
                                                // Clear existing content and append
                                                const container = remoteVideo.parentElement;
                                                view.target.style.width = '100%';
                                                view.target.style.height = '100%';
                                                view.target.style.objectFit = 'cover';
                                                container.appendChild(view.target);
                                                remoteVideo.style.display = 'none';
                                                return true;
                                            }
                                        } catch (e) {
                                            console.log(' createView error:', e);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return false;
                }
                
                if (VoiceVideoCallingSDK.proxyInstance) {
                    const pi = VoiceVideoCallingSDK.proxyInstance;
                    
                    // CRITICAL: Access the _calls Map inside _callClients
                    if (pi._callClients && pi._callClients instanceof Map) {
                        console.log(' _callClients Map found, size:', pi._callClients.size);
                        
                        for (const [clientName, client] of pi._callClients) {
                            console.log(` Processing callClient: ${clientName}`);
                            console.log(` Client keys:`, Object.keys(client));
                            
                            // Access the _calls Map inside the client
                            if (client._calls && client._calls instanceof Map) {
                                console.log(` Found _calls Map, size:`, client._calls.size);
                                
                                for (const [callId, call] of client._calls) {
                                    console.log(` Found call: ${callId}`);
                                    console.log(` Call object:`, call);
                                    
                                    if (call && typeof call === 'object') {
                                        console.log(` Call keys:`, Object.keys(call));
                                        
                                        // Store reference for later use
                                        window.activeACSCall = call;
                                        
                                        // Try to render remote video
                                        const rendered = await renderRemoteVideoFromCall(call);
                                        if (rendered) {
                                            console.log(' Remote video rendered from call object!');
                                        }
                                    }
                                }
                            }
                            
                            // Also check _callAgent - this has the REAL ACS call object
                            if (client._callAgent) {
                                console.log(' Found _callAgent:', client._callAgent);
                                console.log(' _callAgent keys:', Object.keys(client._callAgent));
                                
                                // Check for _calls on callAgent
                                if (client._callAgent._calls) {
                                    console.log(' _callAgent._calls:', client._callAgent._calls);
                                }
                                
                                // Check for calls property - THIS is the real ACS call!
                                if (client._callAgent.calls && client._callAgent.calls.length > 0) {
                                    console.log(' _callAgent.calls:', client._callAgent.calls);
                                    for (const call of client._callAgent.calls) {
                                        console.log(' REAL ACS call found!');
                                        console.log(' ACS call keys:', Object.keys(call));
                                        
                                        // Store the REAL ACS call (with 59+ keys) for camera control
                                        window.activeACSCall = call;
                                        console.log(' Stored real ACS call in window.activeACSCall');
                                        
                                        await renderRemoteVideoFromCall(call);
                                        
                                        // AUTO-START LOCAL CAMERA for video calls using ACS SDK
                                        if (isVideoCall) {
                                            console.log(' Auto-starting local camera via ACS SDK...');
                                            try {
                                                // Check if localVideoStream already exists on the call
                                                const existingStream = call.localVideoStream || (call._localVideoStreams && call._localVideoStreams[0]);
                                                console.log(' Existing localVideoStream:', existingStream);
                                                
                                                if (existingStream && typeof existingStream.getMediaStream === 'function') {
                                                    // Get MediaStream directly from ACS LocalVideoStream
                                                    console.log(' Getting MediaStream from existing localVideoStream...');
                                                    try {
                                                        const mediaStream = await existingStream.getMediaStream();
                                                        if (mediaStream) {
                                                            localVideo.srcObject = mediaStream;
                                                            localVideo.style.display = 'block';
                                                            localStream = mediaStream;
                                                            isCameraOff = false;
                                                            console.log(' Local camera preview from ACS stream');
                                                            toggleCameraBtn.classList.remove('muted');
                                                            toggleCameraBtn.title = 'Turn off camera';
                                                            toggleCameraBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>';
                                                        }
                                                    } catch (streamErr) {
                                                        console.log(' getMediaStream error:', streamErr);
                                                    }
                                                } else if (client._deviceManager) {
                                                    // No existing stream - start video through ACS call
                                                    console.log(' No existing stream, starting via call.startVideo...');
                                                    try {
                                                        let cameras = [];
                                                        if (typeof client._deviceManager.getCameras === 'function') {
                                                            cameras = await client._deviceManager.getCameras();
                                                        } else if (client._deviceManager._videoDevices) {
                                                            cameras = client._deviceManager._videoDevices;
                                                        }
                                                        
                                                        if (cameras && cameras.length > 0) {
                                                            console.log(' Available cameras:', cameras.length, cameras[0]);
                                                            
                                                            // Try to find LocalVideoStream class
                                                            let LocalVideoStreamClass = window.ACS?.LocalVideoStream || 
                                                                                        window.LocalVideoStream ||
                                                                                        window.currentLocalVideoStream?.constructor;
                                                            
                                                            // Try to find from existing streams on call
                                                            if (!LocalVideoStreamClass && call._localVideoStreams && call._localVideoStreams.length > 0) {
                                                                LocalVideoStreamClass = call._localVideoStreams[0].constructor;
                                                            }
                                                            
                                                            // Search window object for LocalVideoStream
                                                            if (!LocalVideoStreamClass) {
                                                                for (const key in window) {
                                                                    try {
                                                                        if (key.includes('LocalVideoStream') && typeof window[key] === 'function') {
                                                                            LocalVideoStreamClass = window[key];
                                                                            console.log(' Found LocalVideoStream at window.' + key);
                                                                            break;
                                                                        }
                                                                    } catch (e) {}
                                                                }
                                                            }
                                                            
                                                            if (LocalVideoStreamClass) {
                                                                console.log(' Creating LocalVideoStream with class:', LocalVideoStreamClass.name || 'anonymous');
                                                                const newLvs = new LocalVideoStreamClass(cameras[0]);
                                                                window.currentLocalVideoStream = newLvs;
                                                                await call.startVideo(newLvs);
                                                                
                                                                // Get preview from the new stream
                                                                if (typeof newLvs.getMediaStream === 'function') {
                                                                    const mediaStream = await newLvs.getMediaStream();
                                                                    if (mediaStream) {
                                                                        localVideo.srcObject = mediaStream;
                                                                        localVideo.style.display = 'block';
                                                                        localStream = mediaStream;
                                                                        isCameraOff = false;
                                                                        console.log(' Local camera started via LocalVideoStream');
                                                                        toggleCameraBtn.classList.remove('muted');
                                                                        toggleCameraBtn.title = 'Turn off camera';
                                                                        toggleCameraBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>';
                                                                    }
                                                                }
                                                            } else {
                                                                // Try to find LocalVideoStream through VoiceVideoCallingSDK
                                                                console.log(' LocalVideoStream not found, trying VoiceVideoCallingSDK methods...');
                                                                let foundStream = false;
                                                                
                                                                const pi = VoiceVideoCallingSDK?.proxyInstance;
                                                                if (pi && pi._voiceVideoCallingStream) {
                                                                    const vvs = pi._voiceVideoCallingStream;
                                                                    console.log(' Checking _voiceVideoCallingStream:', Object.keys(vvs));
                                                                    
                                                                    // Check if vvs has LocalVideoStream
                                                                    if (vvs.LocalVideoStream) {
                                                                        LocalVideoStreamClass = vvs.LocalVideoStream;
                                                                        console.log(' Found LocalVideoStream on vvs!');
                                                                        const newLvs = new LocalVideoStreamClass(cameras[0]);
                                                                        window.currentLocalVideoStream = newLvs;
                                                                        await call.startVideo(newLvs);
                                                                        foundStream = true;
                                                                    }
                                                                    
                                                                    // Try startLocalVideo method
                                                                    if (!foundStream && typeof vvs.startLocalVideo === 'function') {
                                                                        try {
                                                                            console.log(' Calling vvs.startLocalVideo()...');
                                                                            await vvs.startLocalVideo();
                                                                            foundStream = true;
                                                                            console.log(' Started via vvs.startLocalVideo()');
                                                                        } catch (e) {
                                                                            console.log(' vvs.startLocalVideo error:', e);
                                                                        }
                                                                    }
                                                                }
                                                                
                                                                // Look for SDK-created local video element
                                                                if (foundStream || call._isLocalVideoStarted) {
                                                                    await new Promise(r => setTimeout(r, 500));
                                                                    const allVideos = document.querySelectorAll('video');
                                                                    for (const v of allVideos) {
                                                                        if (v !== remoteVideo && v !== localVideo && v.srcObject) {
                                                                            console.log(' Found SDK video with stream, copying...');
                                                                            localVideo.srcObject = v.srcObject;
                                                                            localVideo.style.display = 'block';
                                                                            localStream = v.srcObject;
                                                                            isCameraOff = false;
                                                                            foundStream = true;
                                                                            console.log(' Local preview from SDK element');
                                                                            toggleCameraBtn.classList.remove('muted');
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                                
                                                                // Fallback: use getUserMedia for preview
                                                                if (!foundStream) {
                                                                    console.log(' No SDK stream, trying getUserMedia for preview...');
                                                                    try {
                                                                        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                                                                        localVideo.srcObject = stream;
                                                                        localVideo.style.display = 'block';
                                                                        localStream = stream;
                                                                        isCameraOff = false;
                                                                        console.log(' Local camera preview via getUserMedia');
                                                                        toggleCameraBtn.classList.remove('muted');
                                                                        toggleCameraBtn.title = 'Turn off camera';
                                                                        toggleCameraBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>';
                                                                    } catch (gmErr) {
                                                                        console.log(' getUserMedia failed:', gmErr.message);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    } catch (startErr) {
                                                        console.log(' startVideo error:', startErr);
                                                    }
                                                }
                                            } catch (camErr) {
                                                console.log(' Camera auto-start error:', camErr);
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // Check _deviceManager for streams
                            if (client._deviceManager) {
                                console.log(' Found _deviceManager:', client._deviceManager);
                                console.log(' _deviceManager keys:', Object.keys(client._deviceManager));
                            }
                        }
                    }
                    
                    // Inspect _voiceVideoCallingStream
                    if (pi._voiceVideoCallingStream) {
                        console.log(' _voiceVideoCallingStream found:', pi._voiceVideoCallingStream);
                    }
                }
                
                console.log(' ========== END DEEP INSPECTION ==========');
                
                // Set up a delayed inspection to catch streams that appear later
                setTimeout(async () => {
                    console.log(' ========== DELAYED INSPECTION (3s) ==========');
                    
                    // Re-check the call object for remote participants
                    if (window.activeACSCall) {
                        console.log(' [3s] Re-checking activeACSCall...');
                        const call = window.activeACSCall;
                        console.log(' [3s] Call state:', call.state);
                        console.log(' [3s] Call keys:', Object.keys(call));
                        
                        // Check for remoteParticipants (ACS standard property)
                        if (call.remoteParticipants && call.remoteParticipants.length > 0) {
                            console.log(' [3s] Remote participants:', call.remoteParticipants.length);
                            for (const participant of call.remoteParticipants) {
                                console.log(' [3s] Participant:', participant);
                                console.log(' [3s] Participant keys:', Object.keys(participant));
                                
                                // Check videoStreams
                                if (participant.videoStreams && participant.videoStreams.length > 0) {
                                    console.log(' [3s] Participant videoStreams:', participant.videoStreams);
                                    
                                    for (const stream of participant.videoStreams) {
                                        console.log(' [3s] Stream:', stream);
                                        console.log(' [3s] Stream.isAvailable:', stream.isAvailable);
                                        console.log(' [3s] Stream keys:', Object.keys(stream));
                                        
                                        // If stream is available, try to render it
                                        if (stream.isAvailable) {
                                            // Check for createView method on the call
                                            if (typeof call.createRemoteVideoView === 'function') {
                                                try {
                                                    console.log(' [3s] Calling createRemoteVideoView...');
                                                    const view = await call.createRemoteVideoView(stream);
                                                    if (view && view.target) {
                                                        const container = remoteVideo.parentElement;
                                                        view.target.style.width = '100%';
                                                        view.target.style.height = '100%';
                                                        container.appendChild(view.target);
                                                        remoteVideo.style.display = 'none';
                                                        console.log(' [3s] Remote video rendered via createRemoteVideoView');
                                                    }
                                                } catch (e) {
                                                    console.log(' [3s] createRemoteVideoView error:', e);
                                                }
                                            }
                                            
                                            // Try getMediaStream
                                            if (typeof stream.getMediaStream === 'function') {
                                                try {
                                                    const ms = await stream.getMediaStream();
                                                    if (ms instanceof MediaStream) {
                                                        console.log(' [3s] Got MediaStream!', ms);
                                                        remoteVideo.srcObject = ms;
                                                        remoteVideo.play().catch(e => console.log('Play error:', e));
                                                    }
                                                } catch (e) {
                                                    console.log(' [3s] getMediaStream error:', e);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Set up event listener for when video streams are added
                        if (call.on && typeof call.on === 'function') {
                            console.log(' [3s] Setting up call.on event listeners...');
                            
                            call.on('remoteParticipantsUpdated', (e) => {
                                console.log(' remoteParticipantsUpdated event:', e);
                                if (e.added) {
                                    for (const participant of e.added) {
                                        console.log(' New participant added:', participant);
                                        setupParticipantVideoListener(participant);
                                    }
                                }
                            });
                        }
                        
                        // Check existing participants and set up listeners
                        if (call.remoteParticipants) {
                            for (const participant of call.remoteParticipants) {
                                setupParticipantVideoListener(participant);
                            }
                        }
                    }
                    
                    // Check if remoteVideo has srcObject now
                    console.log(' [3s] remoteVideo.srcObject:', remoteVideo.srcObject);
                    console.log(' [3s] localVideo.srcObject:', localVideo.srcObject);
                    
                    // Use window.activeACSCall which we stored earlier
                    const acsCall = window.activeACSCall;
                    
                    // If local video is still missing, try to get it from ACS
                    if (!localVideo.srcObject && isVideoCall && acsCall) {
                        console.log(' [3s] Local video missing, trying to get from ACS...');
                        const lvs = acsCall.localVideoStream || (acsCall._localVideoStreams && acsCall._localVideoStreams[0]);
                        console.log(' [3s] acsCall.localVideoStream:', lvs);
                        console.log(' [3s] acsCall._isLocalVideoStarted:', acsCall._isLocalVideoStarted);
                        
                        if (lvs && typeof lvs.getMediaStream === 'function') {
                            try {
                                const mediaStream = await lvs.getMediaStream();
                                if (mediaStream) {
                                    console.log(' [3s] Got local MediaStream from ACS!');
                                    localVideo.srcObject = mediaStream;
                                    localVideo.style.display = 'block';
                                    window.localStream = mediaStream;
                                    isCameraOff = false;
                                    toggleCameraBtn.classList.remove('muted');
                                }
                            } catch (e) {
                                console.log(' [3s] getMediaStream error for local:', e);
                            }
                        } else if (!acsCall._isLocalVideoStarted) {
                            // Try to start local video if not started - need LocalVideoStream class
                            console.log(' [3s] Local video not started, trying to find LocalVideoStream class...');
                            
                            // Try to extract LocalVideoStream from ACS SDK
                            let LocalVideoStreamClass = window.LocalVideoStream;
                            
                            // Method 1: Check if it's on the call object's constructor
                            if (!LocalVideoStreamClass && acsCall._localVideoStreams && acsCall._localVideoStreams.length > 0) {
                                LocalVideoStreamClass = acsCall._localVideoStreams[0].constructor;
                                console.log(' [3s] Found LocalVideoStream from existing stream constructor');
                            }
                            
                            // Method 2: Check CallingBundle exports
                            if (!LocalVideoStreamClass && window.ACS) {
                                LocalVideoStreamClass = window.ACS.LocalVideoStream;
                            }
                            
                            // Method 3: Search window for LocalVideoStream
                            if (!LocalVideoStreamClass) {
                                for (const key in window) {
                                    if (key.includes('LocalVideoStream') && typeof window[key] === 'function') {
                                        LocalVideoStreamClass = window[key];
                                        console.log(' [3s] Found LocalVideoStream at window.' + key);
                                        break;
                                    }
                                }
                            }
                            
                            // Get device manager and try to start video
                            try {
                                const pi = VoiceVideoCallingSDK.proxyInstance;
                                if (pi && pi._callClients) {
                                    for (const [name, client] of pi._callClients.entries()) {
                                        if (client._deviceManager) {
                                            let cameras = [];
                                            if (typeof client._deviceManager.getCameras === 'function') {
                                                cameras = await client._deviceManager.getCameras();
                                            } else if (client._deviceManager._videoDevices) {
                                                cameras = client._deviceManager._videoDevices;
                                            }
                                            
                                            if (cameras && cameras.length > 0) {
                                                console.log(' [3s] Starting video with camera:', cameras[0]);
                                                
                                                if (LocalVideoStreamClass) {
                                                    console.log(' [3s] Creating LocalVideoStream with class:', LocalVideoStreamClass.name);
                                                    const newLvs = new LocalVideoStreamClass(cameras[0]);
                                                    window.currentLocalVideoStream = newLvs;
                                                    await acsCall.startVideo(newLvs);
                                                    
                                                    // Get preview
                                                    const mediaStream = await newLvs.getMediaStream();
                                                    if (mediaStream) {
                                                        console.log(' [3s] Got local stream via LocalVideoStream!');
                                                        localVideo.srcObject = mediaStream;
                                                        localVideo.style.display = 'block';
                                                        window.localStream = mediaStream;
                                                        isCameraOff = false;
                                                        toggleCameraBtn.classList.remove('muted');
                                                    }
                                                } else {
                                                    // Last resort: getUserMedia for preview only
                                                    console.log(' [3s] No LocalVideoStream class, trying to find SDK-created local video...');
                                                    
                                                    // First, look for SDK-created video elements for local preview
                                                    const allVideos = document.querySelectorAll('video');
                                                    let foundLocalVideo = false;
                                                    for (const v of allVideos) {
                                                        if (v !== remoteVideo && v !== localVideo && v.srcObject) {
                                                            // Check if this might be a local video (not the remote one we're showing)
                                                            const tracks = v.srcObject.getVideoTracks();
                                                            if (tracks.length > 0) {
                                                                console.log(' [3s] Found SDK video element with stream:', v.id, tracks[0].label);
                                                                // If the track label suggests it's a camera, use it for local
                                                                if (tracks[0].label.toLowerCase().includes('camera') || 
                                                                    !tracks[0].label.toLowerCase().includes('screen')) {
                                                                    localVideo.srcObject = v.srcObject;
                                                                    localVideo.style.display = 'block';
                                                                    window.localStream = v.srcObject;
                                                                    isCameraOff = false;
                                                                    toggleCameraBtn.classList.remove('muted');
                                                                    foundLocalVideo = true;
                                                                    console.log(' [3s] Got local preview from SDK element!');
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    
                                                    // If still no local preview, try getUserMedia
                                                    if (!foundLocalVideo) {
                                                        try {
                                                            console.log(' [3s] Trying getUserMedia for preview...');
                                                            const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                                                            localVideo.srcObject = stream;
                                                            localVideo.style.display = 'block';
                                                            window.localStream = stream;
                                                            isCameraOff = false;
                                                            toggleCameraBtn.classList.remove('muted');
                                                            console.log(' [3s] Got local preview via getUserMedia');
                                                        } catch (gmErr) {
                                                            console.log(' [3s] getUserMedia failed:', gmErr.message);
                                                        }
                                                    }
                                                }
                                            }
                                            break;
                                        }
                                    }
                                }
                            } catch (e) {
                                console.log(' [3s] startVideo error:', e);
                            }
                        }
                    }
                    
                    // Look for any video elements that might have been created by SDK
                    const allVideos = document.querySelectorAll('video');
                    console.log(' [3s] All video elements:', allVideos.length);
                    allVideos.forEach((v, i) => {
                        console.log(` [3s] Video ${i}: id=${v.id}, srcObject=`, v.srcObject);
                        if (v.srcObject && v !== remoteVideo && v !== localVideo) {
                            // Log video track info to understand what kind of stream this is
                            const tracks = v.srcObject.getVideoTracks ? v.srcObject.getVideoTracks() : [];
                            console.log(` [3s] Video ${i} tracks:`, tracks.length, tracks.map(t => t.label));
                            
                            // Check if this is a remote video (already has different source)
                            if (!remoteVideo.srcObject) {
                                console.log(' [3s] Copying to remoteVideo...');
                                remoteVideo.srcObject = v.srcObject;
                            } else if (!localVideo.srcObject) {
                                // If local video is still empty, this might be the local preview
                                console.log(' [3s] Copying to localVideo...');
                                localVideo.srcObject = v.srcObject;
                                localVideo.style.display = 'block';
                                window.localStream = v.srcObject;
                                isCameraOff = false;
                                toggleCameraBtn.classList.remove('muted');
                            }
                        }
                    });
                    
                    // Also check for hidden video elements inside divs created by SDK
                    const sdkContainers = document.querySelectorAll('[id*="video"], [class*="video"], [id*="stream"], [class*="stream"]');
                    console.log(' [3s] SDK-like containers found:', sdkContainers.length);
                    sdkContainers.forEach((container, i) => {
                        const videos = container.querySelectorAll('video');
                        videos.forEach((v, j) => {
                            if (v.srcObject && v !== remoteVideo && v !== localVideo && !localVideo.srcObject) {
                                console.log(` [3s] Found video in container ${i}:`, v.srcObject);
                                localVideo.srcObject = v.srcObject;
                                localVideo.style.display = 'block';
                                window.localStream = v.srcObject;
                                isCameraOff = false;
                                toggleCameraBtn.classList.remove('muted');
                            }
                        });
                    });
                    
                    console.log(' ========== END DELAYED INSPECTION ==========');
                }, 3000);
                
                // Helper function to listen for video streams on a participant
                function setupParticipantVideoListener(participant) {
                    console.log(' Setting up video listener for participant:', participant.identifier);
                    
                    if (participant.on && typeof participant.on === 'function') {
                        participant.on('videoStreamsUpdated', async (e) => {
                            console.log(' videoStreamsUpdated event:', e);
                            if (e.added) {
                                for (const stream of e.added) {
                                    console.log(' New video stream added:', stream);
                                    await handleRemoteVideoStream(stream);
                                }
                            }
                        });
                    }
                    
                    // Check existing streams
                    if (participant.videoStreams) {
                        for (const stream of participant.videoStreams) {
                            if (stream.isAvailable) {
                                handleRemoteVideoStream(stream);
                            }
                            
                            // Listen for availability changes
                            if (stream.on) {
                                stream.on('isAvailableChanged', async () => {
                                    console.log(' Stream isAvailableChanged:', stream.isAvailable);
                                    if (stream.isAvailable) {
                                        await handleRemoteVideoStream(stream);
                                    }
                                });
                            }
                        }
                    }
                }
                
                // Helper function to handle a remote video stream
                async function handleRemoteVideoStream(stream) {
                    console.log(' Handling remote video stream:', stream);
                    console.log(' Stream keys:', Object.keys(stream));
                    console.log(' Stream.isAvailable:', stream.isAvailable);
                    
                    // Try getMediaStream
                    if (typeof stream.getMediaStream === 'function') {
                        try {
                            const ms = await stream.getMediaStream();
                            if (ms instanceof MediaStream) {
                                console.log(' Got MediaStream from remote stream!');
                                remoteVideo.srcObject = ms;
                                remoteVideo.style.display = 'block';
                                callAvatar.style.display = 'none';
                                remoteVideo.play().catch(e => console.log('Play error:', e));
                                return;
                            }
                        } catch (e) {
                            console.log(' getMediaStream error:', e);
                        }
                    }
                    
                    // Check if stream itself is MediaStream
                    if (stream instanceof MediaStream) {
                        console.log(' Stream IS MediaStream!');
                        remoteVideo.srcObject = stream;
                        remoteVideo.style.display = 'block';
                        callAvatar.style.display = 'none';
                        remoteVideo.play().catch(e => console.log('Play error:', e));
                    }
                }
                
            } catch (error) {
                console.error(' Failed to accept call:', error);
                alert('Could not connect to call: ' + error.message);
                callContainer.classList.remove('active');
                endCall();
            }
        }
        
        async function declineIncomingCall() {
            console.log(' Declining incoming call');
            incomingCallNotification.style.display = 'none';
            
            // Use the global VoiceVideoCallingSDK to reject the call
            if (VoiceVideoCallingSDK && VoiceVideoCallingSDK.rejectCall) {
                try {
                    await VoiceVideoCallingSDK.rejectCall();
                    console.log(' Call rejected successfully');
                } catch (err) {
                    console.log(' Could not reject call:', err);
                }
            }
            
            pendingCallData = null;
        }
        
        // ============ OUTGOING CALL FUNCTIONS (Customer-Initiated) ============
        // Note: These may not work if SDK doesn't support client-initiated calling
        
        // Voice/Video Call Functions
        async function startVoiceCall() {
            if (!chatSDK || !chatStarted || isInCall) return;
            
            try {
                console.log(' Starting voice call...');
                console.log('Available SDK methods:', Object.keys(chatSDK));
                
                // Check if calling is available through SDK
                // Note: D365 voice/video calling may require specific Omnichannel configuration
                // and might not be available through the headless chat SDK
                const hasCallingSupport = typeof chatSDK.getVoiceVideoCalling === 'function' ||
                                         typeof chatSDK.requestVoiceCall === 'function' ||
                                         typeof chatSDK.initiateCall === 'function';
                
                if (!hasCallingSupport) {
                    throw new Error('Voice/Video calling is not available through the chat SDK.\n\n' +
                        'This feature requires:\n' +
                        '1. Voice/Video channel enabled in D365 Omnichannel Admin Center\n' +
                        '2. Proper licensing (Digital Messaging + Voice add-on)\n' +
                        '3. Native D365 widget or supported calling SDK\n\n' +
                        'The headless chat SDK may not support direct client-initiated calling.\n' +
                        'Consider using the native D365 widget or contact Microsoft support.');
                }
                
                isVideoCall = false;
                callContainer.classList.add('active');
                callConnecting.style.display = 'flex';
                callAvatar.style.display = 'none';
                remoteVideo.style.display = 'none';
                localVideo.style.display = 'none';
                toggleCameraBtn.style.display = 'none';
                callStatus.textContent = 'Connecting...';
                
                // Try to get the voice/video calling object from SDK
                let voiceVideoCall = null;
                if (chatSDK.getVoiceVideoCalling) {
                    voiceVideoCall = await chatSDK.getVoiceVideoCalling();
                }
                console.log('Voice/Video calling object:', voiceVideoCall);
                
                // Request microphone access
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true, 
                    video: false 
                });
                
                // Start voice calling using SDK
                if (voiceVideoCall && voiceVideoCall.startCall) {
                    await voiceVideoCall.startCall({ 
                        video: false, 
                        audio: true 
                    });
                } else {
                    throw new Error('Calling API not available. Please check Omnichannel configuration.');
                }
                
                console.log(' Voice call started');
                isInCall = true;
                callConnecting.style.display = 'none';
                callAvatar.style.display = 'flex';
                callAvatar.textContent = getInitials(headerTitle.textContent);
                callStatus.textContent = 'Voice Call';
                
                // Voice call is now active
                startCallDuration();
                
                // Setup call event listeners
                if (voiceVideoCall.onCallConnected) {
                    voiceVideoCall.onCallConnected(() => {
                        console.log(' Call connected');
                        callStatus.textContent = 'Connected';
                    });
                }
                
                if (voiceVideoCall.onCallDisconnected) {
                    voiceVideoCall.onCallDisconnected(() => {
                        console.log(' Call disconnected');
                        endCall();
                    });
                }
                
                if (voiceVideoCall.onRemoteVideoStreamAdded) {
                    voiceVideoCall.onRemoteVideoStreamAdded((stream) => {
                        console.log(' Remote stream added');
                        remoteStream = stream;
                        remoteVideo.srcObject = stream;
                    });
                }
                
                // Store the calling object for later use
                window.activeVoiceVideoCall = voiceVideoCall;
                
            } catch (error) {
                console.error(' Voice call failed:', error);
                alert('Could not start voice call: ' + error.message);
                callContainer.classList.remove('active');
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
            }
        }
        
        async function startVideoCall() {
            if (!chatSDK || !chatStarted || isInCall) return;
            
            try {
                console.log(' Starting video call...');
                console.log('Available SDK methods:', Object.keys(chatSDK));
                
                // Check if calling is available through SDK
                const hasCallingSupport = typeof chatSDK.getVoiceVideoCalling === 'function' ||
                                         typeof chatSDK.requestVideoCall === 'function' ||
                                         typeof chatSDK.initiateCall === 'function';
                
                if (!hasCallingSupport) {
                    throw new Error('Voice/Video calling is not available through the chat SDK.\n\n' +
                        'This feature requires:\n' +
                        '1. Voice/Video channel enabled in D365 Omnichannel Admin Center\n' +
                        '2. Proper licensing (Digital Messaging + Voice add-on)\n' +
                        '3. Native D365 widget or supported calling SDK\n\n' +
                        'The headless chat SDK may not support direct client-initiated calling.\n' +
                        'Consider using the native D365 widget or contact Microsoft support.');
                }
                
                isVideoCall = true;
                callContainer.classList.add('active');
                callConnecting.style.display = 'flex';
                callAvatar.style.display = 'none';
                remoteVideo.style.display = 'none';
                localVideo.style.display = 'none';
                toggleCameraBtn.style.display = 'flex';
                callStatus.textContent = 'Connecting...';
                
                // Try to get the voice/video calling object from SDK
                let voiceVideoCall = null;
                if (chatSDK.getVoiceVideoCalling) {
                    voiceVideoCall = await chatSDK.getVoiceVideoCalling();
                }
                console.log('Voice/Video calling object:', voiceVideoCall);
                
                // Request camera and microphone access
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true, 
                    video: { 
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 } 
                    } 
                });
                
                localVideo.srcObject = localStream;
                localVideo.style.display = 'block';
                
                // Start video calling using SDK
                if (voiceVideoCall && voiceVideoCall.startCall) {
                    await voiceVideoCall.startCall({ 
                        video: true, 
                        audio: true 
                    });
                } else {
                    throw new Error('Calling API not available. Please check Omnichannel configuration.');
                }
                
                console.log(' Video call started');
                isInCall = true;
                callConnecting.style.display = 'none';
                remoteVideo.style.display = 'block';
                callStatus.textContent = 'Video Call';
                
                // Video call is now active
                startCallDuration();
                
                // Setup call event listeners
                if (voiceVideoCall.onCallConnected) {
                    voiceVideoCall.onCallConnected(() => {
                        console.log(' Call connected');
                        callStatus.textContent = 'Connected';
                    });
                }
                
                if (voiceVideoCall.onCallDisconnected) {
                    voiceVideoCall.onCallDisconnected(() => {
                        console.log(' Call disconnected');
                        endCall();
                    });
                }
                
                if (voiceVideoCall.onRemoteVideoStreamAdded) {
                    voiceVideoCall.onRemoteVideoStreamAdded((stream) => {
                        console.log(' Remote stream added');
                        remoteStream = stream;
                        remoteVideo.srcObject = stream;
                    });
                }
                
                // Store the calling object for later use
                window.activeVoiceVideoCall = voiceVideoCall;
                
            } catch (error) {
                console.error(' Video call failed:', error);
                alert('Could not start video call: ' + error.message);
                callContainer.classList.remove('active');
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
            }
        }
        
        function startCallDuration() {
            callStartTime = Date.now();
            callDurationInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                callDuration.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }
        
        async function toggleMic() {
            if (!isInCall) return;
            
            try {
                // Use the VoiceVideoCallingSDK to toggle mute
                if (VoiceVideoCallingSDK && VoiceVideoCallingSDK.toggleMute) {
                    await VoiceVideoCallingSDK.toggleMute();
                    
                    // Check the mute state from SDK
                    isMicMuted = VoiceVideoCallingSDK.isMicrophoneMuted ? 
                                 VoiceVideoCallingSDK.isMicrophoneMuted() : !isMicMuted;
                    
                    muteMicBtn.classList.toggle('muted', isMicMuted);
                    muteMicBtn.title = isMicMuted ? 'Unmute microphone' : 'Mute microphone';
                    
                    // Update mic icon
                    if (isMicMuted) {
                        muteMicBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M19 11h-1.7c0 .74-.16 1.43-.43 2.05l1.23 1.23c.56-.98.9-2.09.9-3.28zm-4.02.17c0-.06.02-.11.02-.17V5c0-1.66-1.34-3-3-3S9 3.34 9 5v.18l5.98 5.99zM4.27 3L3 4.27l6.01 6.01V11c0 1.66 1.33 3 2.99 3 .22 0 .44-.03.65-.08l1.66 1.66c-.71.33-1.5.52-2.31.52-2.76 0-5.3-2.1-5.3-5.1H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c.91-.13 1.77-.45 2.54-.9L19.73 21 21 19.73 4.27 3z"/></svg>';
                    } else {
                        muteMicBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>';
                    }
                    
                    console.log(isMicMuted ? ' Microphone muted' : ' Microphone unmuted');
                }
            } catch (error) {
                console.error('Failed to toggle mute:', error);
            }
        }
        
        async function toggleCamera() {
            if (!isInCall || !isVideoCall) return;
            
            try {
                console.log(' toggleCamera called, isCameraOff:', isCameraOff);
                
                // Try using the ACS call object directly
                if (window.activeACSCall) {
                    const call = window.activeACSCall;
                    console.log(' Using activeACSCall for camera toggle');
                    
                    // Get device manager from the SDK
                    let deviceManager = null;
                    if (VoiceVideoCallingSDK?.proxyInstance?._callClients) {
                        for (const [name, client] of VoiceVideoCallingSDK.proxyInstance._callClients) {
                            if (client._deviceManager) {
                                deviceManager = client._deviceManager;
                                break;
                            }
                        }
                    }
                    
                    if (isCameraOff) {
                        // Turn camera ON
                        console.log(' Turning camera ON...');
                        console.log(' call.localVideoStream:', call.localVideoStream);
                        console.log(' call.localVideoStreams:', call.localVideoStreams);
                        console.log(' call._localVideoStreams:', call._localVideoStreams);
                        console.log(' call._isLocalVideoStarted:', call._isLocalVideoStarted);
                        
                        if (deviceManager) {
                            console.log(' Got deviceManager');
                            
                            // Get available cameras
                            let cameras = [];
                            if (typeof deviceManager.getCameras === 'function') {
                                cameras = await deviceManager.getCameras();
                            } else if (deviceManager.cameras) {
                                cameras = deviceManager.cameras;
                            } else if (deviceManager._videoDevices) {
                                cameras = deviceManager._videoDevices;
                            }
                            console.log(' Available cameras:', cameras);
                            
                            if (cameras && cameras.length > 0) {
                                const camera = cameras[0];
                                console.log(' Using camera:', camera.name || camera.id);
                                
                                // Create LocalVideoStream
                                // Check if there's a LocalVideoStream class available
                                let localVideoStream = null;
                                
                                // Check if there's already a localVideoStream on the call (singular)
                                if (call.localVideoStream) {
                                    console.log(' Found call.localVideoStream (singular):', call.localVideoStream);
                                    localVideoStream = call.localVideoStream;
                                    if (typeof localVideoStream.getMediaStream === 'function') {
                                        try {
                                            const ms = await localVideoStream.getMediaStream();
                                            if (ms instanceof MediaStream) {
                                                console.log(' Got MediaStream from localVideoStream!');
                                                localVideo.srcObject = ms;
                                                localVideo.style.display = 'block';
                                                localStream = ms;
                                                isCameraOff = false;
                                            }
                                        } catch (e) {
                                            console.log(' localVideoStream.getMediaStream error:', e);
                                        }
                                    }
                                }
                                
                                // Try different ways to create local video stream
                                if (isCameraOff && call.startVideo) {
                                    // ACS way: create stream and start video
                                    try {
                                        // First check if call has localVideoStreams we can use
                                        if (call.localVideoStreams && call.localVideoStreams.length > 0) {
                                            console.log(' Restarting existing local video stream');
                                            localVideoStream = call.localVideoStreams[0];
                                            await call.startVideo(localVideoStream);
                                        } else if (call._localVideoStreams && call._localVideoStreams.length > 0) {
                                            console.log(' Using _localVideoStreams');
                                            localVideoStream = call._localVideoStreams[0];
                                            await call.startVideo(localVideoStream);
                                        } else {
                                            // Create new stream - need LocalVideoStream class
                                            // Try multiple ways to find LocalVideoStream
                                            let LocalVideoStreamClass = window.ACS?.LocalVideoStream || 
                                                                        window.LocalVideoStream ||
                                                                        window.currentLocalVideoStream?.constructor;
                                            
                                            // Try to find from existing call streams
                                            if (!LocalVideoStreamClass && call._localVideoStreams && call._localVideoStreams.length > 0) {
                                                LocalVideoStreamClass = call._localVideoStreams[0].constructor;
                                                console.log(' Got LocalVideoStream class from existing stream');
                                            }
                                            
                                            // Try searching window object
                                            if (!LocalVideoStreamClass) {
                                                for (const key in window) {
                                                    try {
                                                        if (key.includes('LocalVideoStream') && typeof window[key] === 'function') {
                                                            LocalVideoStreamClass = window[key];
                                                            console.log(' Found LocalVideoStream at window.' + key);
                                                            break;
                                                        }
                                                    } catch (e) {}
                                                }
                                            }
                                            
                                            if (LocalVideoStreamClass) {
                                                localVideoStream = new LocalVideoStreamClass(camera);
                                                window.currentLocalVideoStream = localVideoStream;
                                                console.log(' Created LocalVideoStream:', localVideoStream);
                                                await call.startVideo(localVideoStream);
                                                
                                                // Try to get preview from the new stream
                                                if (typeof localVideoStream.getMediaStream === 'function') {
                                                    try {
                                                        const ms = await localVideoStream.getMediaStream();
                                                        if (ms instanceof MediaStream) {
                                                            console.log(' Got MediaStream from new LocalVideoStream!');
                                                            localVideo.srcObject = ms;
                                                            localVideo.style.display = 'block';
                                                            localStream = ms;
                                                            isCameraOff = false;
                                                        }
                                                    } catch (e) {
                                                        console.log(' getMediaStream from new LVS error:', e);
                                                    }
                                                }
                                            } else {
                                                console.log(' LocalVideoStream class not found via standard methods');
                                                
                                                // Try using D365 VoiceVideoCallingSDK methods directly
                                                console.log(' Trying VoiceVideoCallingSDK.startLocalVideo...');
                                                let startedViaSDK = false;
                                                
                                                if (VoiceVideoCallingSDK) {
                                                    // Try various SDK methods
                                                    const sdkMethods = Object.getOwnPropertyNames(Object.getPrototypeOf(VoiceVideoCallingSDK) || {});
                                                    console.log(' VoiceVideoCallingSDK prototype methods:', sdkMethods);
                                                    
                                                    // Check proxyInstance for video methods
                                                    const pi = VoiceVideoCallingSDK.proxyInstance;
                                                    if (pi) {
                                                        console.log(' proxyInstance keys:', Object.keys(pi));
                                                        
                                                        // Check _voiceVideoCallingStream for LocalVideoStream
                                                        if (pi._voiceVideoCallingStream) {
                                                            const vvs = pi._voiceVideoCallingStream;
                                                            console.log(' _voiceVideoCallingStream:', vvs);
                                                            console.log(' _voiceVideoCallingStream keys:', Object.keys(vvs));
                                                            
                                                            // Check if it has LocalVideoStream
                                                            if (vvs.LocalVideoStream) {
                                                                LocalVideoStreamClass = vvs.LocalVideoStream;
                                                                console.log(' Found LocalVideoStream on _voiceVideoCallingStream!');
                                                            }
                                                            
                                                            // Try startLocalVideo method
                                                            if (typeof vvs.startLocalVideo === 'function') {
                                                                try {
                                                                    console.log(' Calling vvs.startLocalVideo()...');
                                                                    await vvs.startLocalVideo();
                                                                    startedViaSDK = true;
                                                                    console.log(' Started via _voiceVideoCallingStream.startLocalVideo()');
                                                                } catch (e) {
                                                                    console.log(' vvs.startLocalVideo error:', e);
                                                                }
                                                            }
                                                        }
                                                        
                                                        // Check _callClients for ACS exports
                                                        if (pi._callClients) {
                                                            for (const [name, client] of pi._callClients) {
                                                                // Check if client has ACS modules
                                                                console.log(' Client keys:', Object.keys(client));
                                                                
                                                                // Try to find LocalVideoStream in client's module context
                                                                if (client.LocalVideoStream) {
                                                                    LocalVideoStreamClass = client.LocalVideoStream;
                                                                    console.log(' Found LocalVideoStream on client!');
                                                                }
                                                            }
                                                        }
                                                    }
                                                    
                                                    // Try direct SDK methods
                                                    if (typeof VoiceVideoCallingSDK.startLocalVideo === 'function') {
                                                        try {
                                                            console.log(' Calling VoiceVideoCallingSDK.startLocalVideo()...');
                                                            await VoiceVideoCallingSDK.startLocalVideo();
                                                            startedViaSDK = true;
                                                            console.log(' Started via VoiceVideoCallingSDK.startLocalVideo()');
                                                        } catch (e) {
                                                            console.log(' VoiceVideoCallingSDK.startLocalVideo error:', e);
                                                        }
                                                    }
                                                }
                                                
                                                // If we found LocalVideoStreamClass, try to use it
                                                if (LocalVideoStreamClass && !startedViaSDK) {
                                                    try {
                                                        localVideoStream = new LocalVideoStreamClass(camera);
                                                        window.currentLocalVideoStream = localVideoStream;
                                                        await call.startVideo(localVideoStream);
                                                        startedViaSDK = true;
                                                        console.log(' Started via discovered LocalVideoStream class');
                                                    } catch (e) {
                                                        console.log(' LocalVideoStream creation failed:', e);
                                                    }
                                                }
                                                
                                                // Check if video actually started
                                                if (startedViaSDK || call._isLocalVideoStarted || 
                                                    (call._localVideoStreams && call._localVideoStreams.length > 0)) {
                                                    console.log(' Local video started, looking for preview stream...');
                                                    
                                                    // Wait briefly for stream to be ready
                                                    await new Promise(r => setTimeout(r, 500));
                                                    
                                                    // Check for local video stream
                                                    const lvs = call.localVideoStream || 
                                                                (call._localVideoStreams && call._localVideoStreams[0]) ||
                                                                (call.localVideoStreams && call.localVideoStreams[0]);
                                                    
                                                    if (lvs && typeof lvs.getMediaStream === 'function') {
                                                        try {
                                                            const ms = await lvs.getMediaStream();
                                                            if (ms instanceof MediaStream) {
                                                                localVideo.srcObject = ms;
                                                                localVideo.style.display = 'block';
                                                                localStream = ms;
                                                                isCameraOff = false;
                                                                console.log(' Got local preview from SDK stream!');
                                                            }
                                                        } catch (e) {
                                                            console.log(' getMediaStream after start error:', e);
                                                        }
                                                    }
                                                    
                                                    // Look for SDK-created video elements
                                                    if (!localVideo.srcObject) {
                                                        console.log(' Searching for SDK-created local video elements...');
                                                        const allVideos = document.querySelectorAll('video');
                                                        for (const v of allVideos) {
                                                            if (v !== remoteVideo && v !== localVideo && v.srcObject) {
                                                                console.log(' Found SDK video element with srcObject');
                                                                // Clone the stream for local preview
                                                                localVideo.srcObject = v.srcObject;
                                                                localVideo.style.display = 'block';
                                                                isCameraOff = false;
                                                                console.log(' Copied local stream from SDK element!');
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                                
                                                // Ultimate fallback: getUserMedia for preview only
                                                if (!localVideo.srcObject) {
                                                    console.log(' No SDK stream found, trying getUserMedia for preview...');
                                                    try {
                                                        const stream = await navigator.mediaDevices.getUserMedia({ 
                                                            video: { deviceId: camera.id ? { exact: camera.id } : undefined },
                                                            audio: false 
                                                        });
                                                        localVideo.srcObject = stream;
                                                        localVideo.style.display = 'block';
                                                        localStream = stream;
                                                        isCameraOff = false;
                                                        console.log(' Got local preview via getUserMedia');
                                                    } catch (gmErr) {
                                                        console.log(' getUserMedia with device failed:', gmErr.message);
                                                        // Try without device constraint
                                                        try {
                                                            const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                                                            localVideo.srcObject = stream;
                                                            localVideo.style.display = 'block';
                                                            localStream = stream;
                                                            isCameraOff = false;
                                                            console.log(' Got local preview via getUserMedia (any camera)');
                                                        } catch (e) {
                                                            console.log(' getUserMedia completely failed:', e.message);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        console.log(' Camera started via call.startVideo');
                                        isCameraOff = false;
                                        
                                        // NOW get the local preview from the localVideoStream
                                        // After startVideo, localVideoStreams should be populated
                                        if (call.localVideoStreams && call.localVideoStreams.length > 0) {
                                            localVideoStream = call.localVideoStreams[0];
                                            console.log(' LocalVideoStream from call:', localVideoStream);
                                            console.log(' LocalVideoStream keys:', Object.keys(localVideoStream));
                                            
                                            // Try to get MediaStream for preview
                                            if (typeof localVideoStream.getMediaStream === 'function') {
                                                try {
                                                    const ms = await localVideoStream.getMediaStream();
                                                    if (ms instanceof MediaStream) {
                                                        console.log(' Got local MediaStream for preview!');
                                                        localVideo.srcObject = ms;
                                                        localVideo.style.display = 'block';
                                                        localStream = ms;
                                                    }
                                                } catch (msErr) {
                                                    console.log(' getMediaStream error:', msErr);
                                                }
                                            }
                                            
                                            // Alternative: check source property
                                            if (!localVideo.srcObject && localVideoStream.source) {
                                                console.log(' LocalVideoStream.source:', localVideoStream.source);
                                                if (localVideoStream.source instanceof MediaStream) {
                                                    localVideo.srcObject = localVideoStream.source;
                                                    localVideo.style.display = 'block';
                                                }
                                            }
                                        }
                                    } catch (e) {
                                        console.log(' call.startVideo error:', e);
                                    }
                                }
                                
                                // Fallback: try to get media stream directly for preview
                                if (!localVideo.srcObject) {
                                    console.log(' Still no local preview, trying additional methods...');
                                    
                                    // Method 1: Check call.localVideoStream again (singular)
                                    const lvs = call.localVideoStream || (call._localVideoStreams && call._localVideoStreams[0]) || 
                                               (call.localVideoStreams && call.localVideoStreams[0]);
                                    if (lvs) {
                                        console.log(' Found LocalVideoStream:', lvs);
                                        console.log(' LocalVideoStream keys:', Object.keys(lvs));
                                        
                                        // Try getMediaStream
                                        if (typeof lvs.getMediaStream === 'function') {
                                            try {
                                                const ms = await lvs.getMediaStream();
                                                console.log(' getMediaStream result:', ms);
                                                if (ms instanceof MediaStream) {
                                                    localVideo.srcObject = ms;
                                                    localVideo.style.display = 'block';
                                                    localStream = ms;
                                                    isCameraOff = false;
                                                    console.log(' Got preview via getMediaStream!');
                                                }
                                            } catch (e) {
                                                console.log(' getMediaStream failed:', e.message);
                                            }
                                        }
                                        
                                        // Try getMediaStreamForRenderer
                                        if (!localVideo.srcObject && typeof lvs.getMediaStreamForRenderer === 'function') {
                                            try {
                                                const ms = await lvs.getMediaStreamForRenderer();
                                                console.log(' getMediaStreamForRenderer result:', ms);
                                                if (ms instanceof MediaStream) {
                                                    localVideo.srcObject = ms;
                                                    localVideo.style.display = 'block';
                                                    localStream = ms;
                                                    isCameraOff = false;
                                                    console.log(' Got preview via getMediaStreamForRenderer!');
                                                }
                                            } catch (e) {
                                                console.log(' getMediaStreamForRenderer failed:', e.message);
                                            }
                                        }
                                        
                                        // Check for source or mediaStream property
                                        if (!localVideo.srcObject) {
                                            const directStream = lvs.source || lvs.mediaStream || lvs._mediaStream;
                                            console.log(' Direct stream property:', directStream);
                                            if (directStream instanceof MediaStream) {
                                                localVideo.srcObject = directStream;
                                                localVideo.style.display = 'block';
                                                localStream = directStream;
                                                isCameraOff = false;
                                                console.log(' Got preview via direct property!');
                                            }
                                        }
                                    }
                                    
                                    // Method 2: Create a VideoStreamRenderer (ACS pattern)
                                    if (!localVideo.srcObject && lvs) {
                                        console.log(' Trying VideoStreamRenderer approach...');
                                        try {
                                            const VideoStreamRenderer = window.VideoStreamRenderer || window.ACS?.VideoStreamRenderer;
                                            if (VideoStreamRenderer) {
                                                const renderer = new VideoStreamRenderer(lvs);
                                                const view = await renderer.createView({ scalingMode: 'Crop' });
                                                if (view.target && view.target.srcObject) {
                                                    localVideo.srcObject = view.target.srcObject;
                                                    localVideo.style.display = 'block';
                                                    console.log(' Got preview via VideoStreamRenderer!');
                                                }
                                            }
                                        } catch (e) {
                                            console.log(' VideoStreamRenderer failed:', e.message);
                                        }
                                    }
                                    
                                    // Method 3: Search for SDK-created video elements
                                    if (!localVideo.srcObject) {
                                        console.log(' Searching for SDK-created local video elements...');
                                        const allVideos = document.querySelectorAll('video');
                                        for (const v of allVideos) {
                                            if (v.srcObject && v.srcObject instanceof MediaStream && v !== remoteVideo && v !== localVideo) {
                                                const videoTracks = v.srcObject.getVideoTracks();
                                                // Skip if it's the same as remote video
                                                if (v.srcObject !== remoteVideo.srcObject && videoTracks.length > 0) {
                                                    console.log(' Found SDK video element with stream');
                                                    localVideo.srcObject = v.srcObject;
                                                    localVideo.style.display = 'block';
                                                    isCameraOff = false;
                                                    console.log(' Using SDK video element stream!');
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Fallback: try SDK method
                        if (isCameraOff && VoiceVideoCallingSDK?.toggleLocalVideo) {
                            try {
                                const result = await VoiceVideoCallingSDK.toggleLocalVideo();
                                console.log(' SDK toggleLocalVideo result:', result);
                                if (result !== undefined) {
                                    isCameraOff = false;
                                }
                            } catch (e) {
                                console.log(' SDK toggleLocalVideo error:', e);
                            }
                        }
                        
                        // Another fallback: try startLocalVideo
                        if (isCameraOff && VoiceVideoCallingSDK?.startLocalVideo) {
                            try {
                                await VoiceVideoCallingSDK.startLocalVideo();
                                console.log(' Local video started via SDK.startLocalVideo');
                                isCameraOff = false;
                            } catch (e) {
                                console.log(' SDK startLocalVideo error:', e);
                            }
                        }
                    } else {
                        // Turn camera OFF
                        console.log(' Turning camera OFF...');
                        
                        // Stop via call object
                        if (call.stopVideo && call.localVideoStreams && call.localVideoStreams.length > 0) {
                            try {
                                await call.stopVideo(call.localVideoStreams[0]);
                                console.log(' Camera stopped via call.stopVideo');
                            } catch (e) {
                                console.log(' call.stopVideo error:', e);
                            }
                        }
                        
                        // Stop local stream
                        if (localStream) {
                            localStream.getVideoTracks().forEach(track => track.stop());
                        }
                        if (localVideo.srcObject) {
                            localVideo.srcObject.getVideoTracks().forEach(track => track.stop());
                            localVideo.srcObject = null;
                        }
                        
                        // Try SDK method
                        if (VoiceVideoCallingSDK?.toggleLocalVideo) {
                            try {
                                await VoiceVideoCallingSDK.toggleLocalVideo();
                            } catch (e) {
                                console.log(' SDK toggleLocalVideo error:', e);
                            }
                        }
                        
                        isCameraOff = true;
                        localVideo.style.display = 'none';
                    }
                } else {
                    // Fallback to original SDK method
                    if (VoiceVideoCallingSDK && VoiceVideoCallingSDK.toggleLocalVideo) {
                        await VoiceVideoCallingSDK.toggleLocalVideo();
                        isCameraOff = !isCameraOff;
                    }
                }
                
                // Update UI
                toggleCameraBtn.classList.toggle('muted', isCameraOff);
                toggleCameraBtn.title = isCameraOff ? 'Turn on camera' : 'Turn off camera';
                
                // Update camera icon
                if (isCameraOff) {
                    toggleCameraBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M21 6.5l-4 4V7c0-.55-.45-1-1-1H9.82L21 17.18V6.5zM3.27 2L2 3.27 4.73 6H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.21 0 .39-.08.54-.18L19.73 21 21 19.73 3.27 2z"/></svg>';
                } else {
                    toggleCameraBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>';
                }
                
                localVideo.style.display = isCameraOff ? 'none' : 'block';
                console.log(isCameraOff ? ' Camera off' : ' Camera on');
                
            } catch (error) {
                console.error('Failed to toggle camera:', error);
            }
        }
        
        async function endCall() {
            console.log(' Ending call...');
            
            // Stop call via VoiceVideoCallingSDK
            if (VoiceVideoCallingSDK && isInCall) {
                try {
                    if (typeof VoiceVideoCallingSDK.stopCall === 'function') {
                        await VoiceVideoCallingSDK.stopCall();
                        console.log(' Call stopped via VoiceVideoCallingSDK');
                    }
                } catch (error) {
                    console.error('Error stopping call via SDK:', error);
                }
            }
            
            // Stop local media streams (fallback cleanup)
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('Stopped track:', track.kind);
                });
                localStream = null;
            }
            
            // Clear remote stream
            if (remoteVideo.srcObject) {
                remoteVideo.srcObject = null;
            }
            if (localVideo.srcObject) {
                localVideo.srcObject = null;
            }
            
            // Clear stored calling object reference
            window.activeVoiceVideoCall = null;
            
            // Reset UI
            callContainer.classList.remove('active');
            muteMicBtn.classList.remove('muted');
            toggleCameraBtn.classList.remove('muted');
            
            // Clear call duration timer
            if (callDurationInterval) {
                clearInterval(callDurationInterval);
                callDurationInterval = null;
            }
            
            // Reset state
            isInCall = false;
            isVideoCall = false;
            isMicMuted = false;
            isCameraOff = false;
            callStartTime = null;
            callDuration.textContent = '00:00';
            
            console.log(' Call ended');
        }

        async function sendMessage() {
            const text = messageInput.value.trim();
            if (!text) return;
            messageInput.value = '';
            await sendMessageText(text);
        }

        // Emoji picker - Use native OS emoji picker
        emojiBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Focus the message input first
            messageInput.focus();
            
            // Try to trigger native emoji picker using keyboard simulation
            // Windows: Win + . (period) | Mac: Cmd + Ctrl + Space
            try {
                // Create and dispatch the keyboard event for emoji picker
                const isWindows = navigator.platform.indexOf('Win') > -1;
                const isMac = navigator.platform.indexOf('Mac') > -1;
                
                if (isWindows) {
                    // For Windows, we show a helpful tooltip since we can't programmatically trigger Win+.
                    const tooltip = document.createElement('div');
                    tooltip.style.cssText = `
                        position: fixed; bottom: 120px; right: 30px; background: #1e293b; color: white;
                        padding: 12px 16px; border-radius: 8px; font-size: 13px; z-index: 10000;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3); animation: fadeIn 0.2s ease;
                    `;
                    tooltip.innerHTML = `<strong> Tip:</strong> Press <kbd style="background:#374151;padding:2px 6px;border-radius:4px;margin:0 2px;">Win</kbd> + <kbd style="background:#374151;padding:2px 6px;border-radius:4px;margin:0 2px;">.</kbd> for emojis`;
                    document.body.appendChild(tooltip);
                    setTimeout(() => tooltip.remove(), 3000);
                } else if (isMac) {
                    const tooltip = document.createElement('div');
                    tooltip.style.cssText = `
                        position: fixed; bottom: 120px; right: 30px; background: #1e293b; color: white;
                        padding: 12px 16px; border-radius: 8px; font-size: 13px; z-index: 10000;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3); animation: fadeIn 0.2s ease;
                    `;
                    tooltip.innerHTML = `<strong> Tip:</strong> Press <kbd style="background:#374151;padding:2px 6px;border-radius:4px;margin:0 2px;">Cmd</kbd> + <kbd style="background:#374151;padding:2px 6px;border-radius:4px;margin:0 2px;">Ctrl</kbd> + <kbd style="background:#374151;padding:2px 6px;border-radius:4px;margin:0 2px;">Space</kbd> for emojis`;
                    document.body.appendChild(tooltip);
                    setTimeout(() => tooltip.remove(), 3000);
                }
            } catch (err) {
                console.log('Emoji picker error:', err);
            }
        });

        // Voice input with visual indicator
        let recognition = null;
        let isRecording = false;

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isRecording = true;
                voiceBtn.classList.add('recording');
                voiceRecording.classList.add('show');
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                messageInput.value += transcript;
            };

            recognition.onend = () => {
                isRecording = false;
                voiceBtn.classList.remove('recording');
                voiceRecording.classList.remove('show');
            };

            recognition.onerror = (event) => {
                console.log('Speech recognition error:', event.error);
                isRecording = false;
                voiceBtn.classList.remove('recording');
                voiceRecording.classList.remove('show');
            };

            voiceBtn.addEventListener('click', () => {
                if (isRecording) {
                    recognition.stop();
                } else {
                    recognition.start();
                }
            });

            stopVoiceBtn.addEventListener('click', () => {
                recognition.stop();
            });
        } else {
            voiceBtn.style.display = 'none';
        }

        // New chat button
        newChatBtn.addEventListener('click', () => {
            chatSDK = null; chatStarted = false;
            processedMessageIds.clear(); // Clear processed message IDs
            chatMessages = []; // Clear messages array
            localStorage.removeItem('chatWidgetSession'); // Clear saved session
            messagesContainer.querySelectorAll('.message-wrapper').forEach(el => el.remove());
            document.getElementById('userName').value = '';
            document.getElementById('userEmail').value = '';
            document.getElementById('userQuestion').value = '';
            startBtn.disabled = false; startBtn.textContent = adminSettings?.startBtnText || 'Start Chat';
            headerAvatar.innerHTML = '<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/></svg>';
            showView('prechat');
        });

        // ============ APPLY ADMIN THEME SETTINGS ============
        function applyAdminTheme() {
            if (!adminSettings) {
                console.log('?? No admin settings found - using default theme');
                return;
            }

            console.log('? Applying admin theme with settings:', adminSettings);
            const s = adminSettings;
            
            // Font family mapping
            const fontMap = {
                // System
                'system': '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                // Sans-Serif
                'inter': '"Inter", sans-serif',
                'roboto': '"Roboto", sans-serif',
                'opensans': '"Open Sans", sans-serif',
                'lato': '"Lato", sans-serif',
                'poppins': '"Poppins", sans-serif',
                'montserrat': '"Montserrat", sans-serif',
                'nunito': '"Nunito", sans-serif',
                'sourcesans': '"Source Sans Pro", sans-serif',
                'raleway': '"Raleway", sans-serif',
                'ubuntu': '"Ubuntu", sans-serif',
                'rubik': '"Rubik", sans-serif',
                'worksans': '"Work Sans", sans-serif',
                'firasans': '"Fira Sans", sans-serif',
                'dmsans': '"DM Sans", sans-serif',
                'manrope': '"Manrope", sans-serif',
                'plusjakarta': '"Plus Jakarta Sans", sans-serif',
                'outfit': '"Outfit", sans-serif',
                'lexend': '"Lexend", sans-serif',
                // Serif
                'playfair': '"Playfair Display", serif',
                'merriweather': '"Merriweather", serif',
                'lora': '"Lora", serif',
                'crimson': '"Crimson Text", serif',
                'libre': '"Libre Baskerville", serif',
                // Monospace
                'jetbrains': '"JetBrains Mono", monospace',
                'firacode': '"Fira Code", monospace',
                'sourcecodepro': '"Source Code Pro", monospace',
                // Display
                'quicksand': '"Quicksand", sans-serif',
                'comfortaa': '"Comfortaa", cursive',
                'righteous': '"Righteous", cursive'
            };
            const fontFamily = fontMap[s.fontFamily] || fontMap['system'];
            
            // Determine gradient or solid color
            const gradient = s.useGradient 
                ? `linear-gradient(135deg, ${s.gradientStart || '#667eea'} 0%, ${s.gradientEnd || '#764ba2'} 100%)`
                : s.primaryColor || '#667eea';
            
            const launcherBg = s.launcherColor || gradient;

            // Create dynamic style element
            const styleEl = document.createElement('style');
            styleEl.id = 'admin-theme';
            styleEl.textContent = `
                /* Font */
                .chat-container, .chat-launcher { font-family: ${fontFamily} !important; }
                
                /* Header & Launcher */
                .chat-header { background: ${gradient} !important; }
                .chat-launcher { background: ${launcherBg} !important; }
                .chat-launcher:hover { box-shadow: 0 6px 30px ${s.gradientStart || '#667eea'}66 !important; }

                /* Messages */
                .chat-messages { background: ${s.chatBgColor || '#f8fafc'} !important; }
                .message.user { background: ${s.useGradient ? gradient : (s.userBubbleColor || '#667eea')} !important; color: ${s.userTextColor || '#ffffff'} !important; }
                .message.agent { background: ${s.agentBubbleColor || '#ffffff'} !important; color: ${s.agentTextColor || '#2d3748'} !important; }
                .message.system { background: ${s.systemMsgColor || '#e2e8f0'} !important; color: ${s.systemTextColor || '#64748b'} !important; }
                .message-avatar.agent { background: ${gradient} !important; }

                /* Input Area */
                .chat-input-area { background: ${s.inputBgColor || '#ffffff'} !important; }
                .message-input { border-color: ${s.inputBorderColor || '#e2e8f0'} !important; }
                .message-input:focus { border-color: ${s.gradientStart || '#667eea'} !important; box-shadow: 0 0 0 3px ${s.gradientStart || '#667eea'}1a !important; }
                .send-btn { color: ${s.sendBtnColor || '#667eea'} !important; }
                .send-btn:hover { background: ${s.sendBtnColor || '#667eea'}1a !important; }

                /* Buttons */
                .start-btn { background: ${gradient} !important; }
                .start-btn:hover { box-shadow: 0 4px 15px ${s.gradientStart || '#667eea'}66 !important; }
                .new-chat-btn { background: ${gradient} !important; }
                
                /* Badge */
                .chat-badge { background: ${s.badgeColor || '#ff4757'} !important; }
            `;
            document.head.appendChild(styleEl);

            // Apply launcher icon
            const launcherIcon = document.querySelector('.chat-launcher .chat-icon');
            if (launcherIcon && s.launcherIcon) {
                const iconPaths = {
                    chat_multiple: 'M9.56158 3C5.41944 3 2.06158 6.35786 2.06158 10.5C2.06158 11.6329 2.31325 12.7088 2.76423 13.6734C2.5102 14.6714 2.22638 15.7842 2.03999 16.5147C1.80697 17.428 2.6294 18.2588 3.54374 18.039C4.29396 17.8587 5.44699 17.5819 6.47447 17.337C7.41678 17.7631 8.46241 18 9.56158 18C13.7037 18 17.0616 14.6421 17.0616 10.5C17.0616 6.35786 13.7037 3 9.56158 3ZM3.56158 10.5C3.56158 7.18629 6.24787 4.5 9.56158 4.5C12.8753 4.5 15.5616 7.18629 15.5616 10.5C15.5616 13.8137 12.8753 16.5 9.56158 16.5C8.60084 16.5 7.69487 16.2748 6.89161 15.8749L6.6482 15.7537L6.38368 15.8167C5.46095 16.0363 4.39489 16.2919 3.59592 16.4838C3.79467 15.7047 4.05784 14.6724 4.28601 13.7757L4.35619 13.4998L4.22568 13.2468C3.80145 12.4246 3.56158 11.4914 3.56158 10.5ZM14.5616 21.0001C12.5922 21.0001 10.8001 20.241 9.46191 18.9995C9.49511 18.9999 9.52835 19.0001 9.56163 19.0001C10.2796 19.0001 10.9768 18.911 11.6427 18.7434C12.5067 19.2254 13.5021 19.5001 14.5616 19.5001C15.5223 19.5001 16.4283 19.2748 17.2316 18.8749L17.475 18.7537L17.7395 18.8167C18.6611 19.0361 19.7046 19.2625 20.4787 19.4262C20.3037 18.6757 20.065 17.6711 19.8372 16.7757L19.767 16.4999L19.8975 16.2469C20.3217 15.4247 20.5616 14.4915 20.5616 13.5001C20.5616 11.3853 19.4676 9.52617 17.8146 8.45761C17.6363 7.73435 17.3653 7.04756 17.015 6.41052C19.9523 7.42684 22.0616 10.2171 22.0616 13.5001C22.0616 14.6332 21.8098 15.7094 21.3586 16.6741C21.6117 17.6821 21.8679 18.774 22.0304 19.4773C22.2348 20.3623 21.4554 21.1633 20.563 20.9768C19.8358 20.8248 18.6933 20.581 17.6495 20.3367C16.707 20.763 15.6611 21.0001 14.5616 21.0001Z',
                    chat_multiple_checkmark: 'M13.0606 8.99827C13.3357 8.68869 13.3079 8.21463 12.9983 7.93944C12.6887 7.66425 12.2146 7.69214 11.9394 8.00173L8.44187 11.9365L7.0029 10.6359C6.69561 10.3582 6.22134 10.3821 5.94359 10.6894C5.66585 10.9967 5.6898 11.471 5.9971 11.7487L7.9971 13.5564C8.14546 13.6905 8.34124 13.7598 8.54094 13.7489C8.74063 13.738 8.92769 13.6477 9.06056 13.4983L13.0606 8.99827ZM2.06158 10.5C2.06158 6.35786 5.41944 3 9.56158 3C13.7037 3 17.0616 6.35786 17.0616 10.5C17.0616 14.6421 13.7037 18 9.56158 18C8.46241 18 7.41678 17.7631 6.47447 17.337C5.44699 17.5819 4.29396 17.8587 3.54374 18.039C2.6294 18.2588 1.80697 17.428 2.03999 16.5147C2.22638 15.7842 2.5102 14.6714 2.76423 13.6734C2.31325 12.7088 2.06158 11.6329 2.06158 10.5ZM9.56158 4.5C6.24787 4.5 3.56158 7.18629 3.56158 10.5C3.56158 11.4914 3.80145 12.4246 4.22568 13.2468L4.35619 13.4998L4.28601 13.7757C4.05784 14.6724 3.79467 15.7047 3.59592 16.4838C4.39489 16.2919 5.46095 16.0363 6.38368 15.8167L6.6482 15.7537L6.89161 15.8749C7.69487 16.2748 8.60084 16.5 9.56158 16.5C12.8753 16.5 15.5616 13.8137 15.5616 10.5C15.5616 7.18629 12.8753 4.5 9.56158 4.5ZM9.46191 18.9995C10.8001 20.241 12.5922 21.0001 14.5616 21.0001C15.6611 21.0001 16.707 20.763 17.6495 20.3367C18.6933 20.581 19.8358 20.8248 20.563 20.9768C21.4554 21.1633 22.2348 20.3623 22.0304 19.4773C21.8679 18.774 21.6117 17.6821 21.3586 16.6741C21.8098 15.7094 22.0616 14.6332 22.0616 13.5001C22.0616 10.2171 19.9523 7.42684 17.015 6.41052C17.3653 7.04756 17.6363 7.73435 17.8146 8.45761C19.4676 9.52617 20.5616 11.3853 20.5616 13.5001C20.5616 14.4915 20.3217 15.4247 19.8975 16.2469L19.767 16.4999L19.8372 16.7757C20.065 17.6711 20.3037 18.6757 20.4787 19.4262C19.7046 19.2625 18.6611 19.0361 17.7395 18.8167L17.475 18.7537L17.2316 18.8749C16.4283 19.2748 15.5223 19.5001 14.5616 19.5001C13.5021 19.5001 12.5067 19.2254 11.6427 18.7434C10.9768 18.911 10.2796 19.0001 9.56163 19.0001C9.52835 19.0001 9.49511 18.9999 9.46191 18.9995Z',
                    chat_sparkle: 'M16.0883 6.41228C16.016 6.31886 15.9377 6.2298 15.8539 6.14569C15.5417 5.83255 15.1606 5.59666 14.741 5.45683L13.3632 5.00939C13.257 4.97196 13.165 4.90253 13.1 4.81068C13.0349 4.71883 13 4.60908 13 4.49656C13 4.38404 13.0349 4.27429 13.1 4.18244C13.165 4.09058 13.257 4.02116 13.3632 3.98372L14.741 3.53628C15.1547 3.39352 15.5299 3.15705 15.837 2.84537C16.1357 2.54224 16.3623 2.17595 16.5 1.77372L16.5114 1.73963L16.9592 0.362894C16.9967 0.256782 17.0662 0.164895 17.1581 0.0998993C17.25 0.0349035 17.3598 0 17.4724 0C17.5851 0 17.6949 0.0349035 17.7868 0.0998993C17.8787 0.164895 17.9482 0.256782 17.9857 0.362894L18.4335 1.73963C18.5727 2.15819 18.8077 2.53853 19.1198 2.85041C19.432 3.1623 19.8126 3.39715 20.2315 3.53628L21.6093 3.98372L21.6368 3.99061C21.743 4.02804 21.835 4.09747 21.9 4.18932C21.9651 4.28117 22 4.39092 22 4.50344C22 4.61596 21.9651 4.72571 21.9 4.81756C21.835 4.90942 21.743 4.97884 21.6368 5.01628L20.259 5.46372C19.8402 5.60285 19.4595 5.8377 19.1474 6.14959C18.8353 6.46147 18.6003 6.84181 18.461 7.26037L18.0132 8.63711C18.0092 8.64855 18.0048 8.65983 18 8.67093C17.9605 8.76273 17.8964 8.84212 17.8144 8.9001C17.7224 8.9651 17.6126 9 17.5 9C17.3874 9 17.2776 8.9651 17.1856 8.9001C17.0937 8.8351 17.0242 8.74322 16.9868 8.63711L16.539 7.26037C16.4378 6.95331 16.2851 6.66664 16.0883 6.41228ZM23.7829 10.2132L23.0175 9.9646C22.7848 9.8873 22.5733 9.75683 22.3999 9.58356C22.2265 9.41029 22.0959 9.199 22.0186 8.96646L21.7698 8.20161C21.749 8.14266 21.7104 8.09161 21.6593 8.0555C21.6083 8.01939 21.5473 8 21.4847 8C21.4221 8 21.3611 8.01939 21.31 8.0555C21.259 8.09161 21.2204 8.14266 21.1996 8.20161L20.9508 8.96646C20.875 9.19736 20.7467 9.40761 20.5761 9.58076C20.4055 9.75392 20.1971 9.88529 19.9672 9.9646L19.2018 10.2132C19.1428 10.234 19.0917 10.2725 19.0555 10.3236C19.0194 10.3746 19 10.4356 19 10.4981C19 10.5606 19.0194 10.6216 19.0555 10.6726C19.0917 10.7236 19.1428 10.7622 19.2018 10.783L19.9672 11.0316C20.2003 11.1093 20.412 11.2403 20.5855 11.4143C20.7589 11.5882 20.8893 11.8003 20.9661 12.0335L21.2149 12.7984C21.2357 12.8573 21.2743 12.9084 21.3254 12.9445C21.3764 12.9806 21.4374 13 21.5 13C21.5626 13 21.6236 12.9806 21.6746 12.9445C21.7257 12.9084 21.7643 12.8573 21.7851 12.7984L22.0339 12.0335C22.1113 11.801 22.2418 11.5897 22.4152 11.4164C22.5886 11.2432 22.8001 11.1127 23.0328 11.0354L23.7982 10.7868C23.8572 10.766 23.9083 10.7275 23.9445 10.6764C23.9806 10.6254 24 10.5644 24 10.5019C24 10.4394 23.9806 10.3784 23.9445 10.3274C23.9083 10.2764 23.8572 10.2378 23.7982 10.217L23.7829 10.2132ZM12 2C12.957 2 13.8826 2.13443 14.7589 2.38542C14.6435 2.45713 14.5197 2.51549 14.39 2.55903L13.05 2.99903C12.7677 3.09976 12.5186 3.27531 12.329 3.50625C12.2199 3.5021 12.1102 3.5 12 3.5C7.30558 3.5 3.5 7.30558 3.5 12C3.5 13.4696 3.87277 14.8834 4.57303 16.1375L4.72368 16.4072L3.61096 20.3914L7.59755 19.2792L7.86709 19.4295C9.12006 20.1281 10.5322 20.5 12 20.5C16.1949 20.5 19.68 17.4613 20.3742 13.465C20.4642 13.5981 20.5776 13.7148 20.71 13.809C20.9288 13.9654 21.191 14.0495 21.46 14.0495C21.5752 14.0495 21.6892 14.034 21.7991 14.0041C20.871 18.5665 16.8365 22 12 22C10.3817 22 8.81782 21.6146 7.41286 20.888L3.58704 21.9553C2.92212 22.141 2.23258 21.7525 2.04691 21.0876C1.98546 20.8676 1.98549 20.6349 2.04695 20.4151L3.11461 16.5922C2.38637 15.186 2 13.6203 2 12C2 6.47715 6.47715 2 12 2Z',
                    chat_multiple_heart: 'M6.3412 8.3412C7.1326 7.5498 8.41849 7.55366 9.21333 8.3485L9.49671 8.63188L9.77626 8.35179C10.5691 7.55898 11.8556 7.56284 12.6518 8.3591C13.4468 9.15408 13.4493 10.4364 12.6597 11.2303L9.73275 14.1556C9.6107 14.2777 9.41283 14.2777 9.29079 14.1556L6.3485 11.2133C5.55366 10.4185 5.5498 9.1326 6.3412 8.3412ZM2.06158 10.5C2.06158 6.35786 5.41944 3 9.56158 3C13.7037 3 17.0616 6.35786 17.0616 10.5C17.0616 14.6421 13.7037 18 9.56158 18C8.46241 18 7.41678 17.7631 6.47447 17.337C5.44699 17.5819 4.29396 17.8587 3.54374 18.039C2.6294 18.2588 1.80697 17.428 2.03999 16.5147C2.22638 15.7842 2.5102 14.6714 2.76423 13.6734C2.31325 12.7088 2.06158 11.6329 2.06158 10.5ZM9.56158 4.5C6.24787 4.5 3.56158 7.18629 3.56158 10.5C3.56158 11.4914 3.80145 12.4246 4.22568 13.2468L4.35619 13.4998L4.28601 13.7757C4.05784 14.6724 3.79467 15.7047 3.59592 16.4838C4.39489 16.2919 5.46095 16.0363 6.38368 15.8167L6.6482 15.7537L6.89161 15.8749C7.69487 16.2748 8.60084 16.5 9.56158 16.5C12.8753 16.5 15.5616 13.8137 15.5616 10.5C15.5616 7.18629 12.8753 4.5 9.56158 4.5ZM9.46191 18.9995C10.8001 20.241 12.5922 21.0001 14.5616 21.0001C15.6611 21.0001 16.707 20.763 17.6495 20.3367C18.6933 20.581 19.8358 20.8248 20.563 20.9768C21.4554 21.1633 22.2348 20.3623 22.0304 19.4773C21.8679 18.774 21.6117 17.6821 21.3586 16.6741C21.8098 15.7094 22.0616 14.6332 22.0616 13.5001C22.0616 10.2171 19.9523 7.42684 17.015 6.41052C17.3653 7.04756 17.6363 7.73435 17.8146 8.45761C19.4676 9.52617 20.5616 11.3853 20.5616 13.5001C20.5616 14.4915 20.3217 15.4247 19.8975 16.2469L19.767 16.4999L19.8372 16.7757C20.065 17.6711 20.3037 18.6757 20.4787 19.4262C19.7046 19.2625 18.6611 19.0361 17.7395 18.8167L17.475 18.7537L17.2316 18.8749C16.4283 19.2748 15.5223 19.5001 14.5616 19.5001C13.5021 19.5001 12.5067 19.2254 11.6427 18.7434C10.9768 18.911 10.2796 19.0001 9.56163 19.0001C9.52835 19.0001 9.49511 18.9999 9.46191 18.9995Z',
                    chat_help: 'M12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C10.3817 22 8.81782 21.6146 7.41286 20.888L3.58704 21.9553C2.92212 22.141 2.23258 21.7525 2.04691 21.0876C1.98546 20.8676 1.98549 20.6349 2.04695 20.4151L3.11461 16.5922C2.38637 15.186 2 13.6203 2 12C2 6.47715 6.47715 2 12 2ZM12 3.5C7.30558 3.5 3.5 7.30558 3.5 12C3.5 13.4696 3.87277 14.8834 4.57303 16.1375L4.72368 16.4072L3.61096 20.3914L7.59755 19.2792L7.86709 19.4295C9.12006 20.1281 10.5322 20.5 12 20.5C16.6944 20.5 20.5 16.6944 20.5 12C20.5 7.30558 16.6944 3.5 12 3.5ZM12 15.5C12.5523 15.5 13 15.9477 13 16.5C13 17.0523 12.5523 17.5 12 17.5C11.4477 17.5 11 17.0523 11 16.5C11 15.9477 11.4477 15.5 12 15.5ZM12 6.75C13.5188 6.75 14.75 7.98122 14.75 9.5C14.75 10.5108 14.4525 11.074 13.6989 11.8586L13.5303 12.0303C12.9084 12.6522 12.75 12.9163 12.75 13.5C12.75 13.9142 12.4142 14.25 12 14.25C11.5858 14.25 11.25 13.9142 11.25 13.5C11.25 12.4892 11.5475 11.926 12.3011 11.1414L12.4697 10.9697C13.0916 10.3478 13.25 10.0837 13.25 9.5C13.25 8.80964 12.6904 8.25 12 8.25C11.3528 8.25 10.8205 8.74187 10.7565 9.37219L10.75 9.5C10.75 9.91421 10.4142 10.25 10 10.25C9.58579 10.25 9.25 9.91421 9.25 9.5C9.25 7.98122 10.4812 6.75 12 6.75Z',
                    chat_empty: 'M5.25 18C3.45507 18 2 16.5449 2 14.75V6.25C2 4.45507 3.45507 3 5.25 3H18.75C20.5449 3 22 4.45507 22 6.25V14.75C22 16.5449 20.5449 18 18.75 18H13.0125L7.99868 21.7507C7.44585 22.1642 6.6625 22.0512 6.24901 21.4984C6.08736 21.2822 6 21.0196 6 20.7499L5.99921 18H5.25ZM12.5135 16.5H18.75C19.7165 16.5 20.5 15.7165 20.5 14.75V6.25C20.5 5.2835 19.7165 4.5 18.75 4.5H5.25C4.2835 4.5 3.5 5.2835 3.5 6.25V14.75C3.5 15.7165 4.2835 16.5 5.25 16.5H7.49879L7.499 17.2498L7.49986 20.2506L12.5135 16.5Z',
                    chat_bubbles_question: 'M8.14303 6.30723C8.57707 6.07535 9.04414 6.00076 9.49888 6.00073C10.0253 6.0007 10.6367 6.17363 11.1305 6.57829C11.6475 7.00192 11.9989 7.65186 11.9989 8.5C11.9989 9.47459 11.3102 10.0037 10.9219 10.302C10.8918 10.3252 10.8634 10.347 10.8373 10.3675C10.4127 10.7012 10.2489 10.8795 10.2489 11.25C10.2489 11.6642 9.91314 12 9.49892 12C9.08471 12 8.74892 11.6642 8.74892 11.25C8.74892 10.116 9.46017 9.54195 9.91052 9.18806C10.4238 8.78469 10.4989 8.69484 10.4989 8.5C10.4989 8.10296 10.3503 7.87825 10.1798 7.73853C9.98616 7.57985 9.72254 7.50072 9.49896 7.50073C9.20371 7.50075 9.00078 7.54962 8.84982 7.63027C8.70637 7.7069 8.55459 7.84146 8.40826 8.11137C8.21083 8.47551 7.7556 8.61066 7.39146 8.41324C7.02732 8.21582 6.89217 7.76058 7.08959 7.39644C7.35326 6.91012 7.70147 6.54311 8.14303 6.30723ZM9.49909 15.0001C10.0514 15.0001 10.4992 14.5524 10.4992 14.0001C10.4992 13.4477 10.0514 13 9.49909 13C8.94677 13 8.49902 13.4477 8.49902 14.0001C8.49902 14.5524 8.94677 15.0001 9.49909 15.0001ZM9.49908 3C5.35694 3 1.99908 6.35786 1.99908 10.5C1.99908 11.6329 2.25075 12.7088 2.70173 13.6734C2.4477 14.6714 2.16388 15.7842 1.97749 16.5147C1.74447 17.428 2.5669 18.2588 3.48124 18.039C4.23146 17.8587 5.38449 17.5819 6.41197 17.337C7.35428 17.7631 8.39991 18 9.49908 18C13.6412 18 16.9991 14.6421 16.9991 10.5C16.9991 6.35786 13.6412 3 9.49908 3ZM3.49908 10.5C3.49908 7.18629 6.18537 4.5 9.49908 4.5C12.8128 4.5 15.4991 7.18629 15.4991 10.5C15.4991 13.8137 12.8128 16.5 9.49908 16.5C8.53834 16.5 7.63237 16.2748 6.82911 15.8749L6.5857 15.7537L6.32118 15.8167C5.39845 16.0363 4.33239 16.2919 3.53342 16.4838C3.73217 15.7047 3.99534 14.6724 4.22351 13.7757L4.29369 13.4998L4.16318 13.2468C3.73895 12.4246 3.49908 11.4914 3.49908 10.5ZM14.4991 21.0001C12.5297 21.0001 10.7376 20.241 9.39941 18.9995C9.43261 18.9999 9.46585 19.0001 9.49913 19.0001C10.2171 19.0001 10.9143 18.911 11.5802 18.7434C12.4442 19.2254 13.4396 19.5001 14.4991 19.5001C15.4598 19.5001 16.3658 19.2748 17.1691 18.8749L17.4125 18.7537L17.677 18.8167C18.5986 19.0361 19.6421 19.2625 20.4162 19.4262C20.2412 18.6757 20.0025 17.6711 19.7747 16.7757L19.7045 16.4999L19.835 16.2469C20.2592 15.4247 20.4991 14.4915 20.4991 13.5001C20.4991 11.3853 19.4051 9.52617 17.7521 8.45761C17.5738 7.73435 17.3028 7.04756 16.9525 6.41052C19.8898 7.42684 21.9991 10.2171 21.9991 13.5001C21.9991 14.6332 21.7473 15.7094 21.2961 16.6741C21.5492 17.6821 21.8054 18.774 21.9679 19.4773C22.1723 20.3623 21.3929 21.1633 20.5005 20.9768C19.7733 20.8248 18.6308 20.581 17.587 20.3367C16.6445 20.763 15.5986 21.0001 14.4991 21.0001Z',
                    chat: 'M12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C10.3817 22 8.81782 21.6146 7.41286 20.888L3.58704 21.9553C2.92212 22.141 2.23258 21.7525 2.04691 21.0876C1.98546 20.8676 1.98549 20.6349 2.04695 20.4151L3.11461 16.5922C2.38637 15.186 2 13.6203 2 12C2 6.47715 6.47715 2 12 2ZM12 3.5C7.30558 3.5 3.5 7.30558 3.5 12C3.5 13.4696 3.87277 14.8834 4.57303 16.1375L4.72368 16.4072L3.61096 20.3914L7.59755 19.2792L7.86709 19.4295C9.12006 20.1281 10.5322 20.5 12 20.5C16.6944 20.5 20.5 16.6944 20.5 12C20.5 7.30558 16.6944 3.5 12 3.5Z',
                    bot: 'M17.7534 13.9994C18.9961 13.9994 20.0034 15.0068 20.0034 16.2494V17.1545C20.0034 18.2482 19.526 19.2874 18.6961 19.9998C17.1307 21.3437 14.8904 22.0006 12.0004 22.0006C9.11087 22.0006 6.87205 21.344 5.30918 20.0003C4.48056 19.2879 4.00391 18.2495 4.00391 17.1567V16.2494C4.00391 15.0068 5.01127 13.9994 6.25391 13.9994H17.7534ZM17.7534 15.4994H6.25391C5.83969 15.4994 5.50391 15.8352 5.50391 16.2494V17.1567C5.50391 17.8124 5.7899 18.4354 6.28707 18.8629C7.54516 19.9445 9.44117 20.5006 12.0004 20.5006C14.5603 20.5006 16.4582 19.9442 17.7191 18.8617C18.2169 18.4342 18.5034 17.8107 18.5034 17.1545V16.2494C18.5034 15.8352 18.1676 15.4994 17.7534 15.4994ZM11.8989 2.00685L12.0007 2C12.3804 2 12.6942 2.28215 12.7438 2.64823L12.7507 2.75L12.7499 3.499L16.2504 3.49951C17.493 3.49951 18.5004 4.50687 18.5004 5.74951V10.2541C18.5004 11.4967 17.493 12.5041 16.2504 12.5041H7.75036C6.50772 12.5041 5.50036 11.4967 5.50036 10.2541V5.74951C5.50036 4.50687 6.50772 3.49951 7.75036 3.49951L11.2499 3.499L11.2507 2.75C11.2507 2.3703 11.5328 2.05651 11.8989 2.00685L12.0007 2L11.8989 2.00685ZM16.2504 4.99951H7.75036C7.33615 4.99951 7.00036 5.33529 7.00036 5.74951V10.2541C7.00036 10.6683 7.33615 11.0041 7.75036 11.0041H16.2504C16.6646 11.0041 17.0004 10.6683 17.0004 10.2541V5.74951C17.0004 5.33529 16.6646 4.99951 16.2504 4.99951ZM9.74965 6.49951C10.4396 6.49951 10.9989 7.05883 10.9989 7.74879C10.9989 8.43876 10.4396 8.99808 9.74965 8.99808C9.05969 8.99808 8.50036 8.43876 8.50036 7.74879C8.50036 7.05883 9.05969 6.49951 9.74965 6.49951ZM14.2424 6.49951C14.9324 6.49951 15.4917 7.05883 15.4917 7.74879C15.4917 8.43876 14.9324 8.99808 14.2424 8.99808C13.5524 8.99808 12.9931 8.43876 12.9931 7.74879C12.9931 7.05883 13.5524 6.49951 14.2424 6.49951Z',
                    bot_sparkle: 'M18.5004 10.2546C18.5004 10.2994 18.4991 10.3438 18.4965 10.3879C18.4546 10.3508 18.4105 10.3159 18.3645 10.2834C18.1037 10.099 17.7921 10 17.4728 10C17.3115 10 17.1522 10.0253 17.0004 10.074V5.74999C17.0004 5.33578 16.6646 4.99999 16.2504 4.99999H7.75036C7.33615 4.99999 7.00036 5.33578 7.00036 5.74999V10.2546C7.00036 10.6688 7.33615 11.0046 7.75036 11.0046H16.0258L16.0166 11.03L16.0125 11.0417L15.5622 12.426L15.5534 12.4524C15.5474 12.4699 15.5411 12.4873 15.5345 12.5046H7.75036C6.50772 12.5046 5.50036 11.4972 5.50036 10.2546V5.74999C5.50036 4.50735 6.50772 3.49999 7.75036 3.49999L11.2499 3.49949L11.2507 2.75049C11.2507 2.37079 11.5328 2.057 11.8989 2.00733L12.0007 2.00049C12.3804 2.00049 12.6942 2.28264 12.7438 2.64872L12.7507 2.75049L12.7499 3.49949L16.2504 3.49999C17.493 3.49999 18.5004 4.50735 18.5004 5.74999V10.2546ZM13.0428 14.0365L13.1554 13.9999H6.25391C5.01127 13.9999 4.00391 15.0073 4.00391 16.2499V17.1572C4.00391 18.25 4.48056 19.2884 5.30918 20.0008C6.87205 21.3445 9.11087 22.0011 12.0004 22.0011C14.0763 22.0011 15.8171 21.6621 17.2132 20.9731C16.9968 20.9321 16.7904 20.8451 16.6087 20.7166C16.3478 20.5322 16.1506 20.2714 16.0442 19.97L16.04 19.9583L16.0096 19.8646C14.9245 20.2865 13.5901 20.5011 12.0004 20.5011C9.44117 20.5011 7.54516 19.945 6.28707 18.8634C5.7899 18.4359 5.50391 17.8129 5.50391 17.1572V16.2499C5.50391 15.8357 5.83969 15.4999 6.25391 15.4999H12.0004L12.0004 15.4966C12.0004 15.1769 12.0996 14.8653 12.2843 14.6045C12.4689 14.3438 12.7299 14.1468 13.0311 14.0406L13.0428 14.0365ZM10.9989 7.74928C10.9989 7.05932 10.4396 6.49999 9.74965 6.49999C9.05969 6.49999 8.50036 7.05932 8.50036 7.74928C8.50036 8.43925 9.05969 8.99857 9.74965 8.99857C10.4396 8.99857 10.9989 8.43925 10.9989 7.74928ZM14.2424 6.49999C14.9324 6.49999 15.4917 7.05932 15.4917 7.74928C15.4917 8.43925 14.9324 8.99857 14.2424 8.99857C13.5524 8.99857 12.9931 8.43925 12.9931 7.74928C12.9931 7.05932 13.5524 6.49999 14.2424 6.49999ZM16.0886 17.4123C16.0163 17.3189 15.9381 17.2298 15.8542 17.1457C15.5421 16.8326 15.161 16.5967 14.7413 16.4568L13.3635 16.0094C13.2573 15.972 13.1654 15.9025 13.1003 15.8107C13.0353 15.7188 13.0004 15.6091 13.0004 15.4966C13.0004 15.384 13.0353 15.2743 13.1003 15.1824C13.1654 15.0906 13.2573 15.0212 13.3635 14.9837L14.7413 14.5363C15.1551 14.3935 15.5302 14.1571 15.8374 13.8454C16.1361 13.5422 16.3626 13.1759 16.5004 12.7737L16.5118 12.7396L16.9596 11.3629C16.997 11.2568 17.0665 11.1649 17.1584 11.0999C17.2504 11.0349 17.3602 11 17.4728 11C17.5854 11 17.6953 11.0349 17.7872 11.0999C17.8791 11.1649 17.9486 11.2568 17.986 11.3629L18.4338 12.7396C18.5731 13.1582 18.8081 13.5385 19.1202 13.8504C19.4323 14.1623 19.813 14.3971 20.2318 14.5363L21.6096 14.9837L21.6372 14.9906C21.7434 15.028 21.8353 15.0975 21.9004 15.1893C21.9654 15.2812 22.0004 15.3909 22.0004 15.5034C22.0004 15.616 21.9654 15.7257 21.9004 15.8176C21.8353 15.9094 21.7434 15.9788 21.6372 16.0163L20.2594 16.4637C19.8405 16.6029 19.4599 16.8377 19.1478 17.1496C18.8356 17.4615 18.6006 17.8418 18.4614 18.2604L18.0136 19.6371C18.0096 19.6486 18.0051 19.6598 18.0004 19.6709C17.9609 19.7627 17.8967 19.8421 17.8147 19.9001C17.7228 19.9651 17.613 20 17.5004 20C17.3878 20 17.2779 19.9651 17.186 19.9001C17.0941 19.8351 17.0246 19.7432 16.9871 19.6371L16.5394 18.2604C16.4382 17.9533 16.2855 17.6666 16.0886 17.4123ZM23.7833 21.2132L23.0179 20.9646C22.7851 20.8873 22.5737 20.7568 22.4003 20.5836C22.2269 20.4103 22.0963 20.199 22.019 19.9665L21.7702 19.2016C21.7494 19.1427 21.7108 19.0916 21.6597 19.0555C21.6086 19.0194 21.5476 19 21.4851 19C21.4225 19 21.3615 19.0194 21.3104 19.0555C21.2593 19.0916 21.2207 19.1427 21.1999 19.2016L20.9512 19.9665C20.8753 20.1974 20.7471 20.4076 20.5765 20.5808C20.4058 20.7539 20.1974 20.8853 19.9676 20.9646L19.2021 21.2132C19.1431 21.234 19.092 21.2725 19.0559 21.3236C19.0198 21.3746 19.0004 21.4356 19.0004 21.4981C19.0004 21.5606 19.0198 21.6216 19.0559 21.6726C19.092 21.7236 19.1431 21.7622 19.2021 21.783L19.9676 22.0316C20.2007 22.1093 20.4124 22.2403 20.5858 22.4143C20.7593 22.5882 20.8896 22.8003 20.9665 23.0335L21.2152 23.7984C21.2361 23.8573 21.2747 23.9084 21.3257 23.9445C21.3768 23.9806 21.4378 24 21.5004 24C21.5629 24 21.6239 23.9806 21.675 23.9445C21.7261 23.9084 21.7647 23.8573 21.7855 23.7984L22.0343 23.0335C22.1116 22.801 22.2422 22.5897 22.4156 22.4164C22.589 22.2432 22.8005 22.1127 23.0332 22.0354L23.7986 21.7868C23.8576 21.766 23.9087 21.7275 23.9448 21.6764C23.981 21.6254 24.0004 21.5644 24.0004 21.5019C24.0004 21.4394 23.981 21.3784 23.9448 21.3274C23.9087 21.2764 23.8576 21.2378 23.7986 21.217L23.7833 21.2132Z'
                };
                const selectedIconPath = iconPaths[s.launcherIcon] || iconPaths.chat_multiple;
                launcherIcon.innerHTML = `<path d="${selectedIconPath}"/>`;
            }

            // Apply header text
            if (s.headerTitle) {
                headerTitle.textContent = s.headerTitle;
            }
            if (s.headerSubtitle) {
                headerStatus.textContent = s.headerSubtitle;
            }

            // Apply header logo if set
            if (s.headerLogo) {
                headerAvatar.innerHTML = `<img src="${s.headerLogo}" alt="Logo" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
            }

            // Apply pre-chat form labels
            if (s.welcomeTitle) {
                const formTitle = document.querySelector('.form-title');
                if (formTitle) formTitle.textContent = s.welcomeTitle;
            }
            if (s.welcomeMessage) {
                const formSubtitle = document.querySelector('.form-subtitle');
                if (formSubtitle) formSubtitle.textContent = s.welcomeMessage;
            }
            if (s.nameFieldLabel) {
                const nameLabel = document.querySelector('label[for="userName"]');
                if (nameLabel) nameLabel.textContent = s.nameFieldLabel + ' *';
            }
            if (s.emailFieldLabel) {
                const emailLabel = document.querySelector('label[for="userEmail"]');
                if (emailLabel) emailLabel.textContent = s.emailFieldLabel + ' *';
            }
            if (s.questionFieldLabel) {
                const questionLabel = document.querySelector('label[for="userQuestion"]');
                if (questionLabel) questionLabel.textContent = s.questionFieldLabel + ' (optional)';
            }
            if (s.startBtnText) {
                startBtn.textContent = s.startBtnText;
            }

            console.log(' Admin theme applied successfully');
        }

        // Apply theme on load
        applyAdminTheme();
        
        // Restore previous chat session if available (async)
        (async function initPage() {
            const sessionRestored = await restoreChatSession();
            if (!sessionRestored) {
                showView('prechat');
            }
        })();
    </script>
</body>
</html>
