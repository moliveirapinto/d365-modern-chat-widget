<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Chat Widget</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;500;600&family=Crimson+Text:wght@400;600&family=DM+Sans:wght@400;500;600&family=Fira+Code:wght@400;500&family=Fira+Sans:wght@400;500;600&family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&family=Lato:wght@400;700&family=Lexend:wght@400;500;600&family=Libre+Baskerville:wght@400;700&family=Lora:wght@400;500;600&family=Manrope:wght@400;500;600&family=Merriweather:wght@400;700&family=Montserrat:wght@400;500;600&family=Nunito:wght@400;600;700&family=Open+Sans:wght@400;600&family=Outfit:wght@400;500;600&family=Playfair+Display:wght@400;500;600&family=Plus+Jakarta+Sans:wght@400;500;600&family=Poppins:wght@400;500;600&family=Quicksand:wght@400;500;600&family=Raleway:wght@400;500;600&family=Righteous&family=Roboto:wght@400;500&family=Rubik:wght@400;500;600&family=Source+Code+Pro:wght@400;500&family=Source+Sans+Pro:wght@400;600&family=Ubuntu:wght@400;500;700&family=Work+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Adaptive Cards Library -->
    <script src="https://unpkg.com/adaptivecards@3.0.2/dist/adaptivecards.min.js"></script>
    
    <script src="dist/chat-sdk-bundle.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            min-height: 100vh; 
            overflow: hidden;
            position: relative;
        }
        
        /* Background screenshot image */
        #demoBackground {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: none;
        }
        #demoBackground.active {
            display: block;
        }
        
        /* Elegant pulse animation */
        @keyframes elegantPulse {
            0% {
                box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4), 
                            0 0 0 0 rgba(102, 126, 234, 0.4);
            }
            50% {
                box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4), 
                            0 0 0 12px rgba(102, 126, 234, 0);
            }
            100% {
                box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4), 
                            0 0 0 0 rgba(102, 126, 234, 0);
            }
        }
        
        /* Chat launcher with elegant pulse */
        .chat-launcher {
            position: fixed; bottom: 24px; right: 24px; width: 60px; height: 60px;
            border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none; cursor: pointer; box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
            transition: transform 0.3s ease, box-shadow 0.3s ease; z-index: 1000; 
            display: flex; align-items: center; justify-content: center;
            animation: elegantPulse 2.5s ease-in-out infinite;
        }
        .chat-launcher:hover { 
            transform: scale(1.1); 
            box-shadow: 0 6px 30px rgba(102, 126, 234, 0.6);
            animation: none; /* Stop pulse on hover */
        }
        .chat-launcher.open {
            animation: none; /* Stop pulse when chat is open */
        }
        .chat-launcher svg { width: 28px; height: 28px; fill: white; }
        /* Show/hide icons based on state */
        .chat-launcher .chat-icon { display: block; }
        .chat-launcher .close-icon { display: none; }
        .chat-launcher.open .chat-icon { display: none; }
        .chat-launcher.open .close-icon { display: block; }
        
        .chat-badge {
            position: absolute; top: -4px; right: -4px; background: #ff4757; color: white;
            font-size: 11px; font-weight: 700; min-width: 20px; height: 20px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center; opacity: 0; transform: scale(0);
            transition: all 0.2s ease;
        }
        .chat-badge.show { opacity: 1; transform: scale(1); }

        /* TALLER chat container */
        .chat-container {
            position: fixed; bottom: 100px; right: 24px; width: 400px; height: 700px;
            max-height: calc(100vh - 120px);
            background: white; border-radius: 16px; box-shadow: 0 10px 50px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; overflow: hidden; opacity: 0;
            transform: translateY(20px) scale(0.95); transition: all 0.3s ease; pointer-events: none; z-index: 999;
        }
        .chat-container.open { opacity: 1; transform: translateY(0) scale(1); pointer-events: all; }

        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 16px 20px; display: flex; align-items: center; gap: 12px; position: relative;
        }
        .header-avatar {
            width: 44px; height: 44px; border-radius: 50%; background: rgba(255,255,255,0.2);
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }
        .header-avatar svg { width: 26px; height: 26px; fill: white; }
        .header-avatar img { width: 100%; height: 100%; object-fit: cover; }
        .header-info { flex: 1; }
        .header-title { color: white; font-weight: 600; font-size: 16px; }
        .header-status { color: rgba(255,255,255,0.8); font-size: 12px; margin-top: 2px; }
        .header-actions { display: flex; gap: 8px; }
        .header-btn {
            background: rgba(255,255,255,0.2); border: none; width: 32px; height: 32px;
            border-radius: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: background 0.2s;
        }
        .header-btn:hover { background: rgba(255,255,255,0.3); }
        .header-btn svg { width: 18px; height: 18px; fill: white; }
        .header-btn.active { background: #48bb78; }
        .header-btn.active:hover { background: #38a169; }
        .header-btn.disabled { opacity: 0.4; pointer-events: none; }

        /* Incoming Call Notification */
        .incoming-call-notification {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 12px 16px;
            z-index: 1000;
            animation: slideDown 0.3s ease-out;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        @keyframes slideDown {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .incoming-call-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .incoming-call-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .incoming-call-icon {
            width: 44px;
            height: 44px;
            min-width: 44px;
            min-height: 44px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 15px rgba(72, 187, 120, 0.4);
        }
        
        .incoming-call-icon svg {
            width: 22px;
            height: 22px;
            fill: white;
            flex-shrink: 0;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .incoming-call-info {
            flex: 1;
        }
        
        .incoming-call-title {
            font-size: 15px;
            font-weight: 600;
            color: white;
            margin-bottom: 2px;
        }
        
        .incoming-call-subtitle {
            font-size: 13px;
            color: rgba(255,255,255,0.9);
        }
        
        .incoming-call-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }
        
        .accept-call-btn,
        .accept-video-btn,
        .decline-call-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            justify-content: center;
        }
        
        .accept-video-btn {
            background: #4299e1;
            color: white;
        }
        
        .accept-video-btn:hover {
            background: #3182ce;
            transform: scale(1.05);
        }
        
        .accept-video-btn svg {
            fill: white;
        }
        
        .accept-call-btn {
            background: #48bb78;
            color: white;
        }
        
        .accept-call-btn:hover {
            background: #38a169;
            transform: scale(1.05);
        }
        
        .accept-call-btn svg {
            fill: white;
        }
        
        .decline-call-btn {
            background: #f56565;
            color: white;
        }
        
        .decline-call-btn:hover {
            background: #e53e3e;
            transform: scale(1.05);
        }
        
        .decline-call-btn svg {
            width: 18px;
            height: 18px;
            fill: white;
        }
        
        /* Voice/Video Call Container */
        .call-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a202c;
            z-index: 100;
            display: none;
            flex-direction: column;
        }
        .call-container.active { display: flex; }
        
        .call-header {
            padding: 16px 20px;
            background: rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .call-info {
            color: white;
        }
        .call-status {
            font-size: 14px;
            font-weight: 600;
        }
        .call-duration {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 4px;
        }
        
        .call-video-area {
            flex: 1;
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .remote-video,
        .local-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .local-video {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 120px;
            height: 160px;
            border-radius: 12px;
            border: 2px solid white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        
        .call-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 48px;
            font-weight: 600;
        }
        
        .call-controls {
            padding: 24px 20px;
            background: rgba(0,0,0,0.5);
            display: flex;
            gap: 16px;
            justify-content: center;
        }
        
        .call-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            background: rgba(255,255,255,0.2);
        }
        .call-btn svg {
            width: 24px;
            height: 24px;
            fill: white;
        }
        .call-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }
        .call-btn.muted {
            background: rgba(239, 68, 68, 0.8);
        }
        .call-btn.end-call {
            background: #ef4444;
            width: 64px;
            height: 64px;
        }
        .call-btn.end-call:hover {
            background: #dc2626;
        }
        
        .call-connecting {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            color: white;
        }
        .call-connecting .spinner {
            border-color: rgba(255,255,255,0.2);
            border-top-color: white;
        }

        .chat-body { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }
        .prechat-form {
            padding: 24px; display: flex; flex-direction: column; gap: 16px; flex: 1; justify-content: center;
        }
        .prechat-form.hidden { display: none; }
        .form-title { font-size: 20px; font-weight: 600; color: #2d3748; text-align: center; margin-bottom: 8px; }
        .form-subtitle { font-size: 14px; color: #718096; text-align: center; margin-bottom: 16px; }
        .form-group { display: flex; flex-direction: column; gap: 6px; }
        .form-group label { font-size: 13px; font-weight: 500; color: #4a5568; }
        .form-group input, .form-group textarea {
            padding: 12px; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 14px;
            transition: border-color 0.2s, box-shadow 0.2s; font-family: inherit;
        }
        .form-group input:focus, .form-group textarea:focus {
            outline: none; border-color: #667eea; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .form-group textarea { resize: none; min-height: 80px; }
        .start-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; border: none; padding: 14px; border-radius: 8px; font-size: 15px;
            font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; margin-top: 8px;
        }
        .start-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); }
        .start-btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }

        .connecting-view, .chat-ended {
            display: none; flex-direction: column; align-items: center; justify-content: center;
            flex: 1; gap: 16px; padding: 24px; text-align: center;
        }
        .connecting-view.active, .chat-ended.active { display: flex; }
        .spinner {
            width: 48px; height: 48px; border: 3px solid #e2e8f0; border-top-color: #667eea;
            border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .connecting-text { color: #4a5568; font-size: 14px; }
        .ended-icon { font-size: 48px; }
        .ended-title { font-size: 18px; font-weight: 600; color: #2d3748; }
        .ended-text { font-size: 14px; color: #718096; }
        .new-chat-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 14px;
            font-weight: 600; cursor: pointer; margin-top: 8px;
        }

        .chat-messages {
            display: none; flex-direction: column; flex: 1; overflow-y: auto; padding: 16px;
            gap: 12px; background: #f8fafc; scroll-behavior: smooth;
        }
        .chat-messages.active { display: flex; }

        /* FIXED: Message wrapper with VERTICALLY CENTERED avatar */
        .message-wrapper { 
            display: flex; 
            gap: 10px; 
            max-width: 85%; 
            animation: fadeIn 0.3s ease;
            align-items: flex-start; /* Avatar at top, aligned with sender name */
        }
        .message-wrapper.user { flex-direction: row-reverse; align-self: flex-end; }
        .message-wrapper.agent { align-self: flex-start; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .message-avatar {
            width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center;
            justify-content: center; font-weight: 600; font-size: 13px; flex-shrink: 0; overflow: hidden;
            margin-top: 18px; /* Align with message bubble center */
        }
        .message-avatar.agent { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .message-avatar.user { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; }
        .message-avatar img { width: 100%; height: 100%; object-fit: cover; }

        .message-content { display: flex; flex-direction: column; gap: 4px; min-width: 0; }
        .message-sender { font-size: 12px; font-weight: 600; color: #64748b; padding: 0 4px; }
        .message-wrapper.user .message-sender { text-align: right; }

        .message {
            padding: 12px 16px; border-radius: 16px; font-size: 14px; line-height: 1.5;
            word-wrap: break-word; white-space: pre-wrap;
        }
        .message.agent { background: white; color: #2d3748; border-bottom-left-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
        .message.user { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-bottom-right-radius: 4px; }
        .message.system {
            align-self: center; background: #e2e8f0; color: #64748b; font-size: 12px;
            padding: 6px 12px; border-radius: 12px; max-width: none;
        }

        .message-time { font-size: 10px; color: #94a3b8; padding: 0 4px; }
        .message-wrapper.user .message-time { text-align: right; }

        /* Image message styles */
        .message-image-container { display: flex; flex-direction: column; gap: 4px; }
        .message-image {
            max-width: 200px; max-height: 200px; border-radius: 12px; cursor: pointer;
            transition: transform 0.2s; object-fit: contain;
        }
        .message-image:hover { transform: scale(1.02); }
        .message-file-info { font-size: 11px; color: #64748b; padding: 0 4px; }

        .typing-indicator { display: none; padding: 8px 0; align-items: center; gap: 8px; }
        .typing-indicator.active { display: flex; }
        .typing-dots { display: flex; gap: 4px; padding: 12px 16px; background: white; border-radius: 16px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); margin-left: 46px; }
        .typing-dots span {
            width: 8px; height: 8px; background: #a0aec0; border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out;
        }
        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }

        /* Input area */
        .chat-input-area {
            display: none; padding: 12px 16px 16px; background: white;
            border-top: 1px solid #e2e8f0; flex-direction: column; gap: 10px;
        }
        .chat-input-area.active { display: flex; }

        .chat-input-wrapper { display: flex; flex-direction: column; gap: 10px; }

        .message-input {
            width: 100%; min-height: 60px; max-height: 120px; padding: 12px 14px;
            border: 1px solid #e2e8f0; border-radius: 12px; font-size: 14px;
            resize: none; font-family: inherit; line-height: 1.4; overflow-y: auto;
        }
        .message-input:focus { outline: none; border-color: #667eea; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); }
        .message-input::placeholder { color: #a0aec0; }

        .input-bottom-row { display: flex; align-items: center; justify-content: space-between; }

        .input-actions { display: flex; gap: 4px; }
        .action-btn {
            width: 36px; height: 36px; border: none; background: transparent;
            border-radius: 8px; cursor: pointer; display: flex; align-items: center;
            justify-content: center; color: #64748b; transition: all 0.2s;
        }
        .action-btn:hover { background: #f1f5f9; color: #667eea; }
        .action-btn svg { width: 20px; height: 20px; fill: currentColor; }
        /* Voice button active state */
        .action-btn.recording { background: #fee2e2; color: #ef4444; }
        .action-btn.recording svg { animation: pulse-mic 1s infinite; }
        @keyframes pulse-mic { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        /* SUBTLE MODERN Send button */
        .send-btn {
            width: 40px; height: 40px; border-radius: 10px;
            background: transparent; border: none; cursor: pointer; 
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s ease; color: #667eea;
        }
        .send-btn:hover { background: rgba(102, 126, 234, 0.1); }
        .send-btn:active { transform: scale(0.95); }
        .send-btn svg { width: 22px; height: 22px; fill: currentColor; }

        /* Emoji picker */
        .emoji-picker {
            position: absolute; bottom: 100%; left: 12px; width: 300px; max-height: 250px;
            background: white; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 12px; display: none; z-index: 100; overflow: hidden;
        }
        .emoji-picker.show { display: block; }
        .emoji-grid { 
            display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; 
            max-height: 200px; overflow-y: auto; padding-right: 4px;
        }
        .emoji-item {
            width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; border-radius: 6px; font-size: 20px; transition: background 0.2s;
        }
        .emoji-item:hover { background: #f1f5f9; transform: scale(1.1); }

        /* Voice recording indicator - IMPROVED visibility */
        .voice-recording {
            position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
            background: #ef4444; color: white; padding: 10px 20px; border-radius: 24px;
            display: none; align-items: center; gap: 10px; font-size: 14px; font-weight: 500;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
        }
        .voice-recording.show { display: flex; animation: slideDown 0.3s ease; }
        @keyframes slideDown { from { opacity: 0; transform: translateX(-50%) translateY(10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
        .voice-dot { width: 10px; height: 10px; background: white; border-radius: 50%; animation: pulse-dot 1s infinite; }
        @keyframes pulse-dot { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(0.8); } }
        .voice-waveform { display: flex; gap: 2px; align-items: center; }
        .voice-waveform span { width: 3px; background: white; border-radius: 2px; animation: wave 0.6s infinite ease-in-out; }
        .voice-waveform span:nth-child(1) { height: 8px; animation-delay: 0s; }
        .voice-waveform span:nth-child(2) { height: 16px; animation-delay: 0.1s; }
        .voice-waveform span:nth-child(3) { height: 12px; animation-delay: 0.2s; }
        .voice-waveform span:nth-child(4) { height: 20px; animation-delay: 0.3s; }
        .voice-waveform span:nth-child(5) { height: 12px; animation-delay: 0.4s; }
        @keyframes wave { 0%, 100% { transform: scaleY(1); } 50% { transform: scaleY(0.5); } }
        .stop-voice-btn {
            background: rgba(255,255,255,0.2); border: none; padding: 6px 12px;
            border-radius: 6px; color: white; cursor: pointer; font-size: 12px; font-weight: 500;
            transition: background 0.2s;
        }
        .stop-voice-btn:hover { background: rgba(255,255,255,0.3); }

        /* Confirm modal */
        .confirm-modal {
            position: absolute; inset: 0; background: rgba(0,0,0,0.5); display: none;
            align-items: center; justify-content: center; z-index: 200;
        }
        .confirm-modal.show { display: flex; }
        .confirm-content {
            background: white; padding: 24px; border-radius: 16px; text-align: center;
            max-width: 280px; margin: 20px;
        }
        .confirm-title { font-size: 16px; font-weight: 600; color: #2d3748; margin-bottom: 8px; }
        .confirm-text { font-size: 14px; color: #64748b; margin-bottom: 20px; }
        .confirm-buttons { display: flex; gap: 12px; justify-content: center; }
        .confirm-btn {
            padding: 10px 24px; border-radius: 8px; font-size: 14px; font-weight: 500;
            cursor: pointer; transition: all 0.2s; border: none;
        }
        .confirm-btn.cancel { background: #e2e8f0; color: #4a5568; }
        .confirm-btn.cancel:hover { background: #cbd5e1; }
        .confirm-btn.end { background: #ef4444; color: white; }
        .confirm-btn.end:hover { background: #dc2626; }
        
        /* Adaptive Card Styles */
        .ac-container {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 16px;
            margin: 4px 0;
            font-family: inherit;
        }
        .ac-container .ac-textBlock {
            margin-bottom: 12px;
            color: #2d3748;
            line-height: 1.5;
        }
        .ac-container .ac-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 14px;
            font-family: inherit;
            transition: border-color 0.2s;
        }
        .ac-container .ac-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .ac-container .ac-input.ac-multichoiceInput {
            padding: 8px 12px;
        }
        .ac-container label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #4a5568;
            margin-bottom: 6px;
        }
        .ac-container .ac-pushButton {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            margin-top: 8px;
        }
        .ac-container .ac-pushButton:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        .ac-container .ac-pushButton:active {
            transform: translateY(0);
        }
        .ac-container .ac-actionSet {
            margin-top: 12px;
        }
        .ac-container select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 14px;
            font-family: inherit;
            background: white;
            cursor: pointer;
        }
        .ac-container select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
    </style>
</head>
<body>
    <!-- Background screenshot -->
    <div id="demoBackground"></div>

    <button class="chat-launcher" id="chatLauncher">
        <span class="chat-badge" id="chatBadge">0</span>
        <svg class="chat-icon" viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>
        <svg class="close-icon" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
    </button>

    <div class="chat-container" id="chatContainer">
        <div class="chat-header">
            <div class="header-avatar" id="headerAvatar">
                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/></svg>
            </div>
            <div class="header-info">
                <div class="header-title" id="headerTitle">Support Chat</div>
                <div class="header-status" id="headerStatus">We're here to help</div>
            </div>
            <div class="header-actions">
                <!-- Download transcript button -->
                <button class="header-btn" id="downloadChat" title="Download transcript" style="display:none;">
                    <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                </button>
                <!-- Voice/Video call buttons removed - only agents can initiate calls -->
                <button class="header-btn" id="minimizeChat" title="Minimize">
                    <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
                </button>
                <button class="header-btn" id="closeChat" title="Close">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
                </button>
            </div>
        </div>

        <div class="chat-body">
            <!-- Incoming Call Notification -->
            <div class="incoming-call-notification" id="incomingCallNotification" style="display:none;">
                <div class="incoming-call-content">
                    <div class="incoming-call-header">
                        <div class="incoming-call-icon">
                            <svg viewBox="0 0 24 24" width="22" height="22"><path fill="white" d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-1.57 1.97c-2.83-1.35-5.48-3.9-6.89-6.83l1.95-1.66c.27-.28.35-.67.24-1.02-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19C3.65 3 3 3.24 3 3.99 3 13.28 10.73 21 20.01 21c.71 0 .99-.63.99-1.18v-3.45c0-.54-.45-.99-.99-.99z"/></svg>
                        </div>
                        <div class="incoming-call-info">
                            <div class="incoming-call-title" id="incomingCallTitle">Incoming Call</div>
                            <div class="incoming-call-subtitle" id="incomingCallSubtitle">Agent is calling...</div>
                        </div>
                    </div>
                    <div class="incoming-call-actions">
                        <button class="accept-video-btn" id="acceptVideoBtn" title="Accept with video">
                            <svg viewBox="0 0 24 24" width="16" height="16"><path fill="white" d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>
                            Video
                        </button>
                        <button class="accept-call-btn" id="acceptCallBtn" title="Accept voice only">
                            <svg viewBox="0 0 24 24" width="16" height="16"><path fill="white" d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-1.57 1.97c-2.83-1.35-5.48-3.9-6.89-6.83l1.95-1.66c.27-.28.35-.67.24-1.02-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19C3.65 3 3 3.24 3 3.99 3 13.28 10.73 21 20.01 21c.71 0 .99-.63.99-1.18v-3.45c0-.54-.45-.99-.99-.99z"/></svg>
                            Voice
                        </button>
                        <button class="decline-call-btn" id="declineCallBtn" title="Decline call">
                            <svg viewBox="0 0 24 24" width="16" height="16"><path fill="white" d="M12 9c-1.6 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.27 0-.52-.11-.7-.28-.79-.74-1.69-1.36-2.67-1.85-.33-.16-.56-.5-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z"/></svg>
                            Decline
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Voice/Video Call Container -->
            <div class="call-container" id="callContainer">
                <div class="call-header">
                    <div class="call-info">
                        <div class="call-status" id="callStatus">Connecting...</div>
                        <div class="call-duration" id="callDuration">00:00</div>
                    </div>
                </div>
                <div class="call-video-area" id="callVideoArea">
                    <div class="call-connecting" id="callConnecting">
                        <div class="spinner"></div>
                        <div>Connecting to agent...</div>
                    </div>
                    <div class="call-avatar" id="callAvatar" style="display:none;">A</div>
                    <video id="remoteVideo" class="remote-video" autoplay playsinline style="display:none;"></video>
                    <video id="localVideo" class="local-video" autoplay playsinline muted style="display:none;"></video>
                </div>
                <div class="call-controls">
                    <button class="call-btn" id="muteMicBtn" title="Mute microphone">
                        <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
                    </button>
                    <button class="call-btn" id="toggleCameraBtn" title="Turn off camera" style="display:none;">
                        <svg viewBox="0 0 24 24"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>
                    </button>
                    <button class="call-btn end-call" id="endCallBtn" title="End call">
                        <svg viewBox="0 0 24 24"><path d="M12 9c-1.6 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.27 0-.52-.11-.7-.28-.79-.74-1.69-1.36-2.67-1.85-.33-.16-.56-.5-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z"/></svg>
                    </button>
                </div>
            </div>
            
            <form class="prechat-form" id="prechatForm" onsubmit="return false;">
                <div class="form-title"> Welcome!</div>
                <div class="form-subtitle">Please fill in your details to start chatting with us.</div>
                <div class="form-group">
                    <label for="userName">Name *</label>
                    <input type="text" id="userName" placeholder="Enter your name" required>
                </div>
                <div class="form-group">
                    <label for="userEmail">Email *</label>
                    <input type="email" id="userEmail" placeholder="Enter your email" required>
                </div>
                <div class="form-group">
                    <label for="userQuestion">How can we help? (optional)</label>
                    <textarea id="userQuestion" placeholder="Describe your question..."></textarea>
                </div>
                <button type="button" class="start-btn" id="startBtn">Start Chat</button>
            </form>

            <div class="connecting-view" id="connectingView">
                <div class="spinner"></div>
                <div class="connecting-text">Connecting you with an agent...</div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="typing-indicator" id="typingIndicator">
                    <div class="typing-dots"><span></span><span></span><span></span></div>
                </div>
            </div>

            <div class="chat-input-area" id="chatInputArea">
                <div class="emoji-picker" id="emojiPicker">
                    <div class="emoji-grid" id="emojiGrid"></div>
                </div>
                <div class="voice-recording" id="voiceRecording">
                    <div class="voice-dot"></div>
                    <div class="voice-waveform"><span></span><span></span><span></span><span></span><span></span></div>
                    <span>Recording...</span>
                    <button class="stop-voice-btn" id="stopVoiceBtn">Stop</button>
                </div>
                <div class="chat-input-wrapper">
                    <textarea class="message-input" id="messageInput" placeholder="Type your message..." rows="3"></textarea>
                    <div class="input-bottom-row">
                        <div class="input-actions">
                            <input type="file" id="fileInput" hidden>
                            <button type="button" class="action-btn" id="attachBtn" title="Attach file">
                                <svg viewBox="0 0 24 24"><path d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6h-1.5z"/></svg>
                            </button>
                            <button type="button" class="action-btn" id="emojiBtn" title="Emoji">
                                <svg viewBox="0 0 24 24"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"/></svg>
                            </button>
                            <button type="button" class="action-btn" id="voiceBtn" title="Voice input">
                                <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.91-3c-.49 0-.9.36-.98.85C16.52 14.2 14.47 16 12 16s-4.52-1.8-4.93-4.15c-.08-.49-.49-.85-.98-.85-.61 0-1.09.54-1 1.14.49 3 2.89 5.35 5.91 5.78V20c0 .55.45 1 1 1s1-.45 1-1v-2.08c3.02-.43 5.42-2.78 5.91-5.78.1-.6-.39-1.14-1-1.14z"/></svg>
                            </button>
                        </div>
                        <button type="button" class="send-btn" id="sendBtn" title="Send">
                            <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
                        </button>
                    </div>
                </div>
            </div>

            <div class="chat-ended" id="chatEnded">
                <div class="ended-icon"></div>
                <div class="ended-title">Chat Ended</div>
                <div class="ended-text">Thank you for chatting with us!</div>
                <button class="new-chat-btn" id="newChatBtn">Start New Chat</button>
            </div>
        </div>

        <div class="confirm-modal" id="confirmModal">
            <div class="confirm-content">
                <div class="confirm-title">End Chat?</div>
                <div class="confirm-text">Are you sure you want to end this conversation?</div>
                <div class="confirm-buttons">
                    <button class="confirm-btn cancel" id="confirmNo">Cancel</button>
                    <button class="confirm-btn end" id="confirmYes">End Chat</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        // ============ LOAD ADMIN SETTINGS ============
        function loadAdminSettings() {
            const saved = localStorage.getItem('chatWidgetSettings');
            console.log('Loading admin settings from localStorage:', saved ? 'Found' : 'Not found');
            if (!saved) return null;
            try {
                const parsed = JSON.parse(saved);
                console.log('Parsed admin settings:', parsed);
                return parsed;
            } catch (e) {
                console.error('Error loading admin settings:', e);
                return null;
            }
        }

        const adminSettings = loadAdminSettings();

        // Load background screenshot if configured
        const demoBackground = document.getElementById('demoBackground');
        
        if (adminSettings?.backgroundImageUrl && adminSettings.backgroundImageUrl.trim()) {
            let imageUrl = adminSettings.backgroundImageUrl.trim();
            console.log('Loading background screenshot:', imageUrl);
            
            // Convert Windows path to file:/// URL format
            if (imageUrl.match(/^[A-Za-z]:\\/)) {
                imageUrl = 'file:///' + imageUrl.replace(/\\/g, '/');
            }
            
            demoBackground.style.backgroundImage = `url('${imageUrl}')`;
            demoBackground.classList.add('active');
        }

        // ============ WIDGET MODE CHECK ============
        const widgetMode = adminSettings?.widgetMode || 'custom';
        console.log('Widget mode:', widgetMode);

        if (widgetMode === 'standard') {
            // Hide custom widget elements but keep the background
            document.querySelector('.chat-launcher')?.remove();
            document.querySelector('.chat-container')?.remove();
            // Keep demoBackground for the screenshot background
            
            // Load the standard D365 Live Chat Widget
            if (adminSettings?.lcwCode) {
                // Parse the lcwCode to extract the script attributes
                const parser = new DOMParser();
                const doc = parser.parseFromString(adminSettings.lcwCode, 'text/html');
                const scriptTag = doc.querySelector('script[id="Microsoft_Omnichannel_LCWidget"]');
                
                if (scriptTag) {
                    const lcwScript = document.createElement('script');
                    lcwScript.id = 'Microsoft_Omnichannel_LCWidget';
                    lcwScript.src = scriptTag.getAttribute('src');
                    lcwScript.setAttribute('data-app-id', scriptTag.getAttribute('data-app-id'));
                    lcwScript.setAttribute('data-org-id', scriptTag.getAttribute('data-org-id'));
                    lcwScript.setAttribute('data-org-url', scriptTag.getAttribute('data-org-url'));
                    document.head.appendChild(lcwScript);
                    console.log('‚úÖ Standard D365 LCW widget loaded');
                    
                    // Set up D365 context provider to pass pre-chat form data for contact authentication
                    window.addEventListener("lcw:ready", function handleLivechatReadyEvent() {
                        console.log('‚úÖ LCW Ready - Setting up context provider');
                        
                        Microsoft.Omnichannel.LiveChatWidget.SDK.setContextProvider(function contextProvider() {
                            // Check if standard widget auto-authentication is enabled
                            if (adminSettings?.enableStandardAuth === true) {
                                const authName = adminSettings.standardAuthName || 'Anonymous User';
                                const authEmail = adminSettings.standardAuthEmail || 'anonymous@example.com';
                                console.log('üîí Using standard widget auto-authentication:', { authName, authEmail });
                                
                                return {
                                    'emailaddress1': authEmail, // Contact email in Dynamics 365
                                    'Name': { value: authName, isDisplayable: true }, // Contact name in Dynamics 365
                                    'Authenticated': { value: 'Authenticated', isDisplayable: true } // Authentication status
                                };
                            }
                            
                            // If auto-auth is disabled, return empty context (native LCW pre-chat form will be used)
                            console.log('‚ÑπÔ∏è Standard widget auth disabled - using native D365 pre-chat form');
                            return {};
                        });
                        
                        console.log('‚úÖ Context provider configured for D365 standard widget');
                    });
                    
                    // Listen for pre-chat form submission to capture user data
                    window.addEventListener("lcw:startChat", function handleStartChat() {
                        // This event fires when user starts the chat via native LCW widget
                        console.log('‚úÖ LCW Start Chat event - context will be passed to D365');
                    });
                    
                } else {
                    console.error('‚ùå Could not parse LCW code');
                }
            } else {
                console.warn('‚ö†Ô∏è No LCW code configured - cannot load standard widget');
            }
            
            // Stop execution here for standard mode
            throw new Error('Standard mode - stopping custom widget initialization');
        }

        // ============ MICROSOFT D365 CONFIGURATION ============
        // D365 Configuration - use admin settings if available
        const omnichannelConfig = {
            orgId: adminSettings?.orgId || '6f473421-f852-f011-8ee4-00224820bd14',
            widgetId: adminSettings?.widgetId || '4fea0c57-e7c2-4fe0-b274-327396965b3c',
            orgUrl: adminSettings?.orgUrl || 'https://m-6f473421-f852-f011-8ee4-00224820bd14.us.omnichannelengagementhub.com'
        };

        let chatSDK = null, chatStarted = false, unreadCount = 0, isMinimized = false, userName = '', userEmail = '', chatMessages = [];
        let processedMessageIds = new Set(); // Track processed message IDs to avoid duplicates
        
        // Initialize Adaptive Cards
        let adaptiveCardRenderer = null;
        if (typeof AdaptiveCards !== 'undefined') {
            adaptiveCardRenderer = new AdaptiveCards.AdaptiveCard();
            adaptiveCardRenderer.hostConfig = new AdaptiveCards.HostConfig({
                fontFamily: "inherit",
                spacing: {
                    small: 8,
                    default: 12,
                    medium: 16,
                    large: 20,
                    extraLarge: 24,
                    padding: 16
                },
                separator: {
                    lineThickness: 1,
                    lineColor: "#e2e8f0"
                },
                fontSizes: {
                    small: 12,
                    default: 14,
                    medium: 16,
                    large: 18,
                    extraLarge: 20
                },
                containerStyles: {
                    default: {
                        backgroundColor: "#f8f9fa",
                        foregroundColors: {
                            default: {
                                default: "#2d3748",
                                subtle: "#64748b"
                            }
                        }
                    }
                }
            });
        }

        // DOM elements
        const launcher = document.getElementById('chatLauncher');
        const container = document.getElementById('chatContainer');
        const badge = document.getElementById('chatBadge');
        const prechatForm = document.getElementById('prechatForm');
        const connectingView = document.getElementById('connectingView');
        const messagesContainer = document.getElementById('chatMessages');
        const inputArea = document.getElementById('chatInputArea');
        const typingIndicator = document.getElementById('typingIndicator');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const startBtn = document.getElementById('startBtn');
        const closeBtn = document.getElementById('closeChat');
        const minimizeBtn = document.getElementById('minimizeChat');
        const confirmModal = document.getElementById('confirmModal');
        const confirmYes = document.getElementById('confirmYes');
        const confirmNo = document.getElementById('confirmNo');
        const headerTitle = document.getElementById('headerTitle');
        const headerStatus = document.getElementById('headerStatus');
        const headerAvatar = document.getElementById('headerAvatar');
        const chatEndedView = document.getElementById('chatEnded');
        const newChatBtn = document.getElementById('newChatBtn');
        const attachBtn = document.getElementById('attachBtn');
        const fileInput = document.getElementById('fileInput');
        const emojiBtn = document.getElementById('emojiBtn');
        const emojiPicker = document.getElementById('emojiPicker');
        const emojiGrid = document.getElementById('emojiGrid');
        const voiceBtn = document.getElementById('voiceBtn');
        const voiceRecording = document.getElementById('voiceRecording');
        const stopVoiceBtn = document.getElementById('stopVoiceBtn');
        const downloadChatBtn = document.getElementById('downloadChat');
        
        // Voice/Video Call elements (agent-initiated only - customer cannot start calls)
        const callContainer = document.getElementById('callContainer');
        const callStatus = document.getElementById('callStatus');
        const callDuration = document.getElementById('callDuration');
        const callConnecting = document.getElementById('callConnecting');
        const callAvatar = document.getElementById('callAvatar');
        const remoteVideo = document.getElementById('remoteVideo');
        const localVideo = document.getElementById('localVideo');
        const muteMicBtn = document.getElementById('muteMicBtn');
        const toggleCameraBtn = document.getElementById('toggleCameraBtn');
        const endCallBtn = document.getElementById('endCallBtn');
        
        // Incoming call elements
        const incomingCallNotification = document.getElementById('incomingCallNotification');
        const incomingCallTitle = document.getElementById('incomingCallTitle');
        const incomingCallSubtitle = document.getElementById('incomingCallSubtitle');
        const acceptCallBtn = document.getElementById('acceptCallBtn');
        const declineCallBtn = document.getElementById('declineCallBtn');
        
        // Call state
        let isInCall = false;
        let isVideoCall = false;
        let isMicMuted = false;
        let isCameraOff = false;
        let callStartTime = null;
        let callDurationInterval = null;
        let localStream = null;
        let remoteStream = null;
        let pendingCallData = null; // Store incoming call data
        let currentAgentName = 'Agent'; // Track the current agent name for calls

        // FIXED: Actual emoji array with real emojis
        const emojis = [
            'üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'ü§£', 'üòÇ',
            'üôÇ', 'üòâ', 'üòä', 'üòá', 'ü•∞', 'üòç', 'ü§©', 'üòò',
            'üòó', 'üòö', 'üòã', 'üòõ', 'üòú', 'ü§™', 'üòù', 'ü§ë',
            'ü§ó', 'ü§≠', 'ü§´', 'ü§î', 'ü§ê', 'ü§®', 'üòê', 'üòë',
            'üò∂', 'üòè', 'üòí', 'üôÑ', 'üò¨', 'ü§•', 'üòå', 'üòî',
            'üò™', 'ü§§', 'üò¥', 'üò∑', 'ü§í', 'ü§ï', 'ü§¢', 'ü§Æ',
            'üëç', 'üëé', 'üëå', '‚úåÔ∏è', 'ü§û', 'ü§ü', 'ü§ò', 'üëã',
            '‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç'
        ];

        function getInitials(name) {
            if (!name || typeof name !== 'string') return '?';
            const trimmed = name.trim();
            if (!trimmed) return '?';
            const parts = trimmed.split(' ');
            if (parts.length >= 2) return (parts[0][0] + parts[parts.length-1][0]).toUpperCase();
            return trimmed.substring(0, 2).toUpperCase();
        }

        function formatTime(date) {
            return new Date(date).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        // Event listeners
        launcher.addEventListener('click', () => {
            const isOpen = container.classList.contains('open');
            container.classList.toggle('open');
            launcher.classList.toggle('open');
            if (!isOpen) { 
                unreadCount = 0; 
                badge.textContent = '0'; 
                badge.classList.remove('show'); 
                isMinimized = false;
                
                // Check if pre-chat form is disabled - if so, auto-start chat
                if (adminSettings?.enablePrechatForm === false) {
                    const defaultName = adminSettings.defaultContactName || 'Anonymous User';
                    const defaultEmail = adminSettings.defaultContactEmail || 'anonymous@example.com';
                    console.log('üöÄ Pre-chat form disabled - auto-starting chat with:', { defaultName, defaultEmail });
                    initializeChat(defaultName, defaultEmail, '');
                }
            }
        });

        minimizeBtn.addEventListener('click', () => {
            container.classList.remove('open');
            launcher.classList.remove('open');
            isMinimized = true;
        });

        closeBtn.addEventListener('click', () => {
            if (chatStarted) { confirmModal.classList.add('show'); }
            else { container.classList.remove('open'); launcher.classList.remove('open'); }
        });

        confirmNo.addEventListener('click', () => confirmModal.classList.remove('show'));
        confirmYes.addEventListener('click', async () => {
            confirmModal.classList.remove('show');
            
            // End any active call first
            if (isInCall) {
                await endCall();
            }
            
            // Close VoiceVideoCallingSDK
            if (VoiceVideoCallingSDK && VoiceVideoCallingSDK.close) {
                try {
                    VoiceVideoCallingSDK.close();
                    console.log('‚úÖ VoiceVideoCallingSDK closed');
                } catch (e) {
                    console.log('VoiceVideoCallingSDK close error:', e);
                }
            }
            VoiceVideoCallingSDK = null;
            
            if (chatSDK) { try { await chatSDK.endChat(); } catch (e) { console.log('End chat error:', e); } }
            localStorage.removeItem('chatWidgetSession'); // Clear saved session
            showView('ended');
        });

        sendBtn.addEventListener('click', sendMessage);
        messageInput.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });

        startBtn.addEventListener('click', async () => {
            userName = document.getElementById('userName').value.trim();
            userEmail = document.getElementById('userEmail').value.trim();
            const question = document.getElementById('userQuestion').value.trim();
            if (!userName || !userEmail) { alert('Please fill in all required fields'); return; }
            startBtn.disabled = true; startBtn.textContent = 'Starting...';
            await initializeChat(userName, userEmail, question);
        });

        attachBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelect);
        
        // In-call controls (for agent-initiated calls)
        muteMicBtn.addEventListener('click', toggleMic);
        toggleCameraBtn.addEventListener('click', toggleCamera);
        endCallBtn.addEventListener('click', endCall);
        
        // Accept call buttons - customer chooses how to answer
        const acceptVideoBtn = document.getElementById('acceptVideoBtn');
        acceptCallBtn.addEventListener('click', () => acceptIncomingCall(false)); // Voice only
        acceptVideoBtn.addEventListener('click', () => acceptIncomingCall(true));  // With video
        declineCallBtn.addEventListener('click', declineIncomingCall);

        // Download transcript
        downloadChatBtn.addEventListener('click', downloadTranscript);

        function downloadTranscript() {
            if (chatMessages.length === 0) { alert('No messages to download'); return; }
            let transcript = `Chat Transcript\n`;
            transcript += `Date: ${new Date().toLocaleDateString()}\n`;
            transcript += `User: ${userName}\n`;
            transcript += `Email: ${userEmail}\n`;
            transcript += `${'='.repeat(50)}\n\n`;
            chatMessages.forEach(msg => {
                const time = formatTime(msg.timestamp);
                const sender = msg.isUser ? userName : (msg.senderName || 'Agent');
                transcript += `[${time}] ${sender}:\n${msg.content}\n\n`;
            });
            transcript += `${'='.repeat(50)}\n`;
            transcript += `End of transcript`;
            const blob = new Blob([transcript], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chat-transcript-${new Date().toISOString().slice(0,10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showView(view) {
            prechatForm.classList.add('hidden');
            connectingView.classList.remove('active');
            messagesContainer.classList.remove('active');
            inputArea.classList.remove('active');
            chatEndedView.classList.remove('active');
            downloadChatBtn.style.display = 'none';
            
            // Skip pre-chat form if disabled in settings
            if (view === 'prechat' && adminSettings?.enablePrechatForm === false) {
                console.log('‚è© Skipping pre-chat form - disabled in settings');
                return; // Don't show anything, chat auto-starts on launcher click
            }
            
            if (view === 'prechat') { prechatForm.classList.remove('hidden'); headerTitle.textContent = 'Support Chat'; headerStatus.textContent = "We're here to help"; }
            else if (view === 'connecting') { connectingView.classList.add('active'); headerTitle.textContent = 'Connecting...'; headerStatus.textContent = 'Please wait'; }
            else if (view === 'chat') { messagesContainer.classList.add('active'); inputArea.classList.add('active'); downloadChatBtn.style.display = 'flex'; }
            else if (view === 'ended') { chatEndedView.classList.add('active'); chatStarted = false; headerTitle.textContent = 'Chat Ended'; headerStatus.textContent = 'Session closed'; downloadChatBtn.style.display = 'flex'; }
        }

        function updateHeaderWithAgent(agentName, agentImage) {
            // Ensure agentName is a string
            const name = (typeof agentName === 'string') ? agentName : 'Support Agent';
            headerTitle.textContent = name || 'Support Agent';
            headerStatus.textContent = 'Online';
            
            // Update the global currentAgentName for use in calls
            currentAgentName = name || 'Agent';
            
            if (agentImage) { headerAvatar.innerHTML = `<img src="${agentImage}" alt="${name}">`; }
            else { headerAvatar.innerHTML = `<span style="color:white;font-weight:600;font-size:14px;">${getInitials(name)}</span>`; }
        }

        function createAvatarElement(isUser, senderName, senderImage) {
            const avatar = document.createElement('div');
            avatar.className = `message-avatar ${isUser ? 'user' : 'agent'}`;
            if (senderImage) { avatar.innerHTML = `<img src="${senderImage}" alt="${senderName}">`; }
            else { avatar.textContent = getInitials(senderName || (isUser ? userName : 'Agent')); }
            return avatar;
        }
        
        // Adaptive Card Support Functions
        function isAdaptiveCardContent(content) {
            if (!content || typeof content !== 'string') return false;
            try {
                const parsed = JSON.parse(content);
                // Check if it's an Adaptive Card directly or has attachments with Adaptive Cards
                if (parsed.type === 'AdaptiveCard') return true;
                if (parsed.attachments && Array.isArray(parsed.attachments)) {
                    return parsed.attachments.some(att => 
                        att.contentType === 'application/vnd.microsoft.card.adaptive' ||
                        (att.content && att.content.type === 'AdaptiveCard')
                    );
                }
                return false;
            } catch (e) {
                return false;
            }
        }
        
        function addAdaptiveCardMessage(content, isUser, senderName, senderImage) {
            const now = new Date();
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${isUser ? 'user' : 'agent'}`;
            
            const avatarImage = senderImage || (isUser ? adminSettings?.customerAvatar : adminSettings?.agentAvatar);
            const avatar = createAvatarElement(isUser, senderName, avatarImage);
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const senderDiv = document.createElement('div');
            senderDiv.className = 'message-sender';
            senderDiv.textContent = isUser ? userName : (senderName || 'Agent');
            
            const cardContainer = document.createElement('div');
            cardContainer.className = 'message adaptive-card-message';
            
            try {
                const parsed = JSON.parse(content);
                let cardPayload = null;
                
                // Extract the Adaptive Card payload
                if (parsed.type === 'AdaptiveCard') {
                    cardPayload = parsed;
                } else if (parsed.attachments && Array.isArray(parsed.attachments)) {
                    const cardAttachment = parsed.attachments.find(att => 
                        att.contentType === 'application/vnd.microsoft.card.adaptive' && att.content
                    );
                    if (cardAttachment) {
                        cardPayload = cardAttachment.content;
                    }
                }
                
                if (cardPayload && adaptiveCardRenderer) {
                    adaptiveCardRenderer.parse(cardPayload);
                    
                    // Set up action handlers
                    adaptiveCardRenderer.onExecuteAction = async (action) => {
                        console.log('Adaptive Card action executed:', action);
                        
                        if (action instanceof AdaptiveCards.SubmitAction) {
                            const data = action.data;
                            console.log('Submit action data:', data);
                            
                            // Send the form data as a message to the chat
                            if (data) {
                                const formattedData = Object.entries(data)
                                    .filter(([key, value]) => key !== 'actionSubmitId' && value)
                                    .map(([key, value]) => `${key}: ${value}`)
                                    .join('\n');
                                
                                if (formattedData) {
                                    // Send the data via SDK
                                    if (chatSDK && chatStarted) {
                                        try {
                                            await chatSDK.sendMessage({
                                                content: formattedData,
                                                contentType: 'text',
                                                metadata: {
                                                    adaptiveCardData: data
                                                }
                                            });
                                            
                                            // Show in UI
                                            addMessage(formattedData, true, userName, null);
                                        } catch (error) {
                                            console.error('Error sending adaptive card data:', error);
                                        }
                                    }
                                }
                            }
                        }
                    };
                    
                    const renderedCard = adaptiveCardRenderer.render();
                    if (renderedCard) {
                        cardContainer.appendChild(renderedCard);
                    } else {
                        cardContainer.innerHTML = '<p style="color: #e74c3c;">‚ö†Ô∏è Could not render card</p>';
                    }
                } else {
                    cardContainer.innerHTML = '<p style="color: #e74c3c;">‚ö†Ô∏è Invalid Adaptive Card format</p>';
                }
            } catch (error) {
                console.error('Error rendering Adaptive Card:', error);
                cardContainer.innerHTML = '<p style="color: #e74c3c;">‚ö†Ô∏è Error displaying card</p>';
            }
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'message-time';
            timeDiv.textContent = formatTime(now);
            
            contentDiv.appendChild(senderDiv);
            contentDiv.appendChild(cardContainer);
            contentDiv.appendChild(timeDiv);
            
            wrapper.appendChild(avatar);
            wrapper.appendChild(contentDiv);
            
            typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Save to chat history (store original JSON)
            chatMessages.push({ 
                isUser, 
                content: content, 
                isAdaptiveCard: true,
                senderName: isUser ? userName : senderName, 
                timestamp: now 
            });
            saveChatSession();
            
            if (!isUser && !container.classList.contains('open')) {
                unreadCount++; 
                badge.textContent = unreadCount; 
                badge.classList.add('show');
            }
        }

        function addImageMessage(fileInfo, isUser, senderName, senderImage) {
            const now = new Date();
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${isUser ? 'user' : 'agent'}`;
            // Use admin-configured avatars if no senderImage provided
            const avatarImage = senderImage || (isUser ? adminSettings?.customerAvatar : adminSettings?.agentAvatar);
            const avatar = createAvatarElement(isUser, senderName, avatarImage);
            const content = document.createElement('div');
            content.className = 'message-content';
            content.innerHTML = `
                <div class="message-sender">${isUser ? userName : (senderName || 'Agent')}</div>
                <div class="message-image-container">
                    <img src="${fileInfo.url}" class="message-image" alt="${fileInfo.name}" onclick="window.open('${fileInfo.url}', '_blank')">
                    <div class="message-file-info">${fileInfo.name}</div>
                </div>
                <div class="message-time">${formatTime(now)}</div>
            `;
            wrapper.appendChild(avatar);
            wrapper.appendChild(content);
            typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            chatMessages.push({ isUser, content: `[Image: ${fileInfo.name}]`, senderName: isUser ? userName : senderName, timestamp: now });
        }

        function addMessage(text, isUser = false, senderName = null, senderImage = null) {
            const now = new Date();
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${isUser ? 'user' : 'agent'}`;
            // Use admin-configured avatars if no senderImage provided
            const avatarImage = senderImage || (isUser ? adminSettings?.customerAvatar : adminSettings?.agentAvatar);
            const avatar = createAvatarElement(isUser, senderName, avatarImage);
            const content = document.createElement('div');
            content.className = 'message-content';
            content.innerHTML = `
                <div class="message-sender">${isUser ? userName : (senderName || 'Agent')}</div>
                <div class="message ${isUser ? 'user' : 'agent'}">${text}</div>
                <div class="message-time">${formatTime(now)}</div>
            `;
            wrapper.appendChild(avatar);
            wrapper.appendChild(content);
            typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            chatMessages.push({ isUser, content: text, senderName: isUser ? userName : senderName, timestamp: now });
            saveChatSession(); // Save after adding message
            if (!isUser && !container.classList.contains('open')) {
                unreadCount++; badge.textContent = unreadCount; badge.classList.add('show');
            }
        }

        function processMessage(message) {
            if (!message) return;
            
            // Get message ID - try various possible ID fields
            const messageId = message.messageId || message.id || message.clientmessageid || message.messageid;
            
            // Skip if already processed
            if (messageId && processedMessageIds.has(messageId)) {
                console.log('Skipping already processed message:', messageId);
                return;
            }
            
            // Mark as processed
            if (messageId) {
                processedMessageIds.add(messageId);
            }
            
            // üéØ CHECK FOR INCOMING VOICE/VIDEO CALL
            // Check if message contains call invitation tags or metadata
            const tags = message.tags || [];
            const metadata = message.metadata || message.properties || {};
            const messageType = message.messageType || message.type || metadata.messageType;
            
            if (tags.includes('voicecall') || tags.includes('videocall') || 
                messageType === 'VoiceVideoCall' || messageType === 'voicecall' || messageType === 'videocall' ||
                metadata.isVoiceCall || metadata.isVideoCall) {
                console.log('üìû INCOMING CALL DETECTED in message:', message);
                const isVideo = tags.includes('videocall') || messageType === 'videocall' || metadata.isVideoCall;
                const senderName = message.senderDisplayName || message.sender?.displayName || 'Agent';
                showIncomingCallNotification({ 
                    isVideo, 
                    agentName: senderName,
                    messageData: message,
                    callId: messageId
                });
                return; // Don't process as regular message
            }
            
            // Get message content - try various possible content fields
            const content = message.content || message.text || message.body;
            
            // Check for file attachments (images, files sent by agent)
            const fileMetadata = message.fileMetadata || message.attachments || message.attachment;
            
            // Log full message if no content (helps debug attachment structure)
            if (!content && !fileMetadata) {
                console.log('Message has no content or attachments - full object:', JSON.stringify(message, null, 2));
                return;
            }
            
            // Determine message role
            const role = message.role || message.senderRole || message.deliveryMode;
            
            // Extract sender info - senderId can be an object with displayName
            const senderId = message.senderId || message.sender;
            let senderName = 'Agent';
            if (typeof senderId === 'object' && senderId !== null) {
                senderName = senderId.displayName || senderId.name || 'Agent';
            } else if (typeof senderId === 'string') {
                senderName = senderId;
            }
            // Also check direct senderDisplayName field
            if (message.senderDisplayName) {
                senderName = message.senderDisplayName;
            }
            
            console.log('Processing message - role:', role, 'senderName:', senderName, 'content:', content, 'fileMetadata:', fileMetadata);
            
            const isFromUser = role === 'user' || role === 'User' || role === 1;
            const isFromBot = role === 'bot' || role === 'Bot' || role === 2;
            const isFromAgent = role === 'agent' || role === 'Agent' || role === 3;
            const isSystem = role === 'system' || role === 'System';
            
            // Skip user messages (those are added when sent)
            if (isFromUser) {
                console.log('Skipping user message');
                return;
            }
            
            // Handle system messages
            if (isSystem) {
                addSystemMessage(content);
                return;
            }
            
            // Handle agent/bot messages
            if (isFromBot || isFromAgent || !isFromUser) {
                // Only update header for actual agent (not system)
                if (isFromAgent && senderName && senderName !== '__agent__') {
                    updateHeaderWithAgent(senderName, null);
                }
                
                // Handle file/image attachments
                if (fileMetadata) {
                    handleAgentAttachment(fileMetadata, senderName);
                }
                
                // Handle text content - check if it's an Adaptive Card first
                if (content) {
                    if (isAdaptiveCardContent(content)) {
                        console.log('üìã Detected Adaptive Card in message content');
                        addAdaptiveCardMessage(content, false, senderName, null);
                    } else {
                        addMessage(content, false, senderName, null);
                    }
                }
            }
        }
        
        function handleAgentAttachment(fileMetadata, senderName) {
            console.log('Handling agent attachment:', fileMetadata);
            
            // fileMetadata can be a single object or an array
            const attachments = Array.isArray(fileMetadata) ? fileMetadata : [fileMetadata];
            
            attachments.forEach(async (attachment) => {
                const fileName = attachment.name || attachment.fileName || attachment.filePath || 'File';
                const fileType = attachment.type || attachment.contentType || attachment.mimeType || '';
                const fileId = attachment.id;
                
                console.log('Attachment details - name:', fileName, 'id:', fileId, 'type:', fileType);
                
                // Check if there's a direct URL first
                let fileUrl = attachment.url || attachment.downloadUrl || attachment.filePath;
                
                // If no direct URL but we have an ID, use SDK to download the file
                if (!fileUrl && fileId && chatSDK) {
                    try {
                        console.log('Downloading attachment via SDK...');
                        const blob = await chatSDK.downloadFileAttachment(attachment);
                        console.log('Downloaded blob:', blob);
                        
                        if (blob) {
                            // Create a blob URL from the downloaded content
                            fileUrl = URL.createObjectURL(blob);
                            console.log('Created blob URL:', fileUrl);
                        }
                    } catch (err) {
                        console.error('Error downloading attachment:', err);
                    }
                }
                
                if (fileUrl) {
                    if (fileType.startsWith('image/') || /\.(jpg|jpeg|png|gif|webp|bmp)$/i.test(fileName)) {
                        // It's an image
                        addImageMessage({ name: fileName, url: fileUrl }, false, senderName, null);
                    } else {
                        // It's a file - show as downloadable link
                        addFileMessage({ name: fileName, url: fileUrl, type: fileType }, false, senderName, null);
                    }
                } else {
                    console.log('Could not get URL for attachment:', attachment);
                    // Show a placeholder message indicating a file was received but couldn't be loaded
                    addMessage(`?? ${fileName} (file could not be loaded)`, false, senderName, null);
                }
            });
        }
        
        function addFileMessage(fileInfo, isUser, senderName, senderImage) {
            const now = new Date();
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${isUser ? 'user' : 'agent'}`;
            const avatar = createAvatarElement(isUser, senderName, senderImage);
            const content = document.createElement('div');
            content.className = 'message-content';
            content.innerHTML = `
                <div class="message-sender">${isUser ? userName : (senderName || 'Agent')}</div>
                <div class="message ${isUser ? 'user' : 'agent'}">
                    <a href="${fileInfo.url}" target="_blank" style="color: inherit; text-decoration: underline;">
                        ?? ${fileInfo.name}
                    </a>
                </div>
                <div class="message-time">${formatTime(now)}</div>
            `;
            wrapper.appendChild(avatar);
            wrapper.appendChild(content);
            typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            chatMessages.push({ isUser, content: `[File: ${fileInfo.name}]`, senderName: isUser ? userName : senderName, timestamp: now });
        }
        
        function addSystemMessage(text) {
            const wrapper = document.createElement('div');
            wrapper.className = 'message-wrapper';
            wrapper.style.justifyContent = 'center';
            wrapper.style.maxWidth = '100%';
            
            const msg = document.createElement('div');
            msg.className = 'message system';
            msg.textContent = text;
            
            wrapper.appendChild(msg);
            typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        async function pollMessages() {
            if (!chatSDK || !chatStarted) return;
            try {
                const messages = await chatSDK.getMessages();
                console.log('Polled messages:', messages);
                if (messages && messages.length) {
                    messages.forEach(msg => {
                        processMessage(msg);
                    });
                }
            } catch (e) { console.log('Poll error:', e); }
        }

        // ============ SESSION PERSISTENCE ============
        let liveChatContext = null; // Store live chat context for reconnection
        
        async function saveChatSession() {
            if (!chatStarted || !chatSDK) {
                localStorage.removeItem('chatWidgetSession');
                return;
            }
            
            // Get live chat context from SDK for reconnection
            try {
                liveChatContext = await chatSDK.getCurrentLiveChatContext();
                console.log('üìç Got live chat context:', liveChatContext);
            } catch (e) {
                console.log('‚ö†Ô∏è Could not get live chat context:', e);
            }
            
            const session = {
                userName,
                userEmail,
                chatStarted,
                messages: chatMessages,
                processedIds: Array.from(processedMessageIds),
                liveChatContext: liveChatContext, // Save context for reconnection
                timestamp: Date.now()
            };
            
            localStorage.setItem('chatWidgetSession', JSON.stringify(session));
            console.log('üíæ Chat session saved with context');
        }

        async function restoreChatSession() {
            const saved = localStorage.getItem('chatWidgetSession');
            if (!saved) return false;
            
            try {
                const session = JSON.parse(saved);
                
                // Check if session is recent (less than 1 hour old)
                const oneHour = 60 * 60 * 1000;
                if (Date.now() - session.timestamp > oneHour) {
                    console.log('‚è∞ Session expired - clearing');
                    localStorage.removeItem('chatWidgetSession');
                    return false;
                }
                
                // Check if we have live chat context to reconnect
                if (!session.liveChatContext) {
                    console.log('‚ö†Ô∏è No live chat context - cannot reconnect');
                    localStorage.removeItem('chatWidgetSession');
                    return false;
                }
                
                // Restore session state
                userName = session.userName || '';
                userEmail = session.userEmail || '';
                liveChatContext = session.liveChatContext;
                chatMessages = session.messages || [];
                processedMessageIds = new Set(session.processedIds || []);
                
                // Try to reconnect to existing chat session
                console.log('üîÑ Attempting to reconnect to existing chat...');
                showView('connecting');
                
                try {
                    const OmnichannelChatSDK = window.OmnichannelChatSDK;
                    chatSDK = new OmnichannelChatSDK(omnichannelConfig);
                    await chatSDK.initialize();
                    
                    // Set up message listener
                    chatSDK.onNewMessage((msg) => {
                        console.log('üì® onNewMessage event received:', msg);
                        console.log('üì® Message details - tags:', msg?.tags, 'type:', msg?.type || msg?.messageType, 'metadata:', msg?.metadata);
                        if (msg) processMessage(msg);
                    });
                    
                    chatSDK.onTypingEvent(() => {
                        typingIndicator.classList.add('active');
                        setTimeout(() => typingIndicator.classList.remove('active'), 3000);
                    });
                    
                    chatSDK.onAgentEndSession(() => { 
                        console.log('Agent ended session');
                        localStorage.removeItem('chatWidgetSession');
                        showView('ended'); 
                    });
                    
                    // VoiceVideoCallingSDK will be initialized after chat reconnects
                    // Incoming call listener is set up in initializeVoiceVideoCallingSDK
                    
                    // Reconnect to existing chat using saved context
                    await chatSDK.startChat({ liveChatContext: session.liveChatContext });
                    console.log('‚úÖ Reconnected to existing chat session!');
                    
                    // Initialize VoiceVideoCallingSDK for incoming calls (after startChat)
                    await initializeVoiceVideoCallingSDK(chatSDK);
                    
                    chatStarted = true;
                    chatMessages = session.messages || [];
                    
                    // Restore UI - rebuild message display
                    showView('chat');
                    chatMessages.forEach(msg => {
                        if (msg.content) {
                            // Check if this is an Adaptive Card message
                            if (msg.isAdaptiveCard) {
                                // Re-render the Adaptive Card
                                const now = msg.timestamp ? new Date(msg.timestamp) : new Date();
                                const wrapper = document.createElement('div');
                                wrapper.className = `message-wrapper ${msg.isUser ? 'user' : 'agent'}`;
                                
                                const avatarImage = msg.isUser ? adminSettings?.customerAvatar : adminSettings?.agentAvatar;
                                const avatar = createAvatarElement(msg.isUser, msg.senderName, avatarImage);
                                
                                const contentDiv = document.createElement('div');
                                contentDiv.className = 'message-content';
                                
                                const senderDiv = document.createElement('div');
                                senderDiv.className = 'message-sender';
                                senderDiv.textContent = msg.isUser ? userName : (msg.senderName || 'Agent');
                                
                                const cardContainer = document.createElement('div');
                                cardContainer.className = 'message adaptive-card-message';
                                
                                try {
                                    const parsed = JSON.parse(msg.content);
                                    let cardPayload = null;
                                    
                                    if (parsed.type === 'AdaptiveCard') {
                                        cardPayload = parsed;
                                    } else if (parsed.attachments && Array.isArray(parsed.attachments)) {
                                        const cardAttachment = parsed.attachments.find(att => 
                                            att.contentType === 'application/vnd.microsoft.card.adaptive' && att.content
                                        );
                                        if (cardAttachment) {
                                            cardPayload = cardAttachment.content;
                                        }
                                    }
                                    
                                    if (cardPayload && adaptiveCardRenderer) {
                                        adaptiveCardRenderer.parse(cardPayload);
                                        const renderedCard = adaptiveCardRenderer.render();
                                        if (renderedCard) {
                                            cardContainer.appendChild(renderedCard);
                                        }
                                    }
                                } catch (error) {
                                    console.error('Error re-rendering Adaptive Card:', error);
                                    cardContainer.innerHTML = '<p style="color: #e74c3c;">‚ö†Ô∏è Card could not be restored</p>';
                                }
                                
                                const timeDiv = document.createElement('div');
                                timeDiv.className = 'message-time';
                                timeDiv.textContent = formatTime(now);
                                
                                contentDiv.appendChild(senderDiv);
                                contentDiv.appendChild(cardContainer);
                                contentDiv.appendChild(timeDiv);
                                
                                wrapper.appendChild(avatar);
                                wrapper.appendChild(contentDiv);
                                typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
                            } else {
                                // Regular text message
                                const now = msg.timestamp ? new Date(msg.timestamp) : new Date();
                                const wrapper = document.createElement('div');
                                wrapper.className = `message-wrapper ${msg.isUser ? 'user' : 'agent'}`;
                                
                                const avatarImage = msg.isUser ? adminSettings?.customerAvatar : adminSettings?.agentAvatar;
                                const avatar = createAvatarElement(msg.isUser, msg.senderName, avatarImage);
                                
                                const content = document.createElement('div');
                                content.className = 'message-content';
                                content.innerHTML = `
                                    <div class="message-sender">${msg.isUser ? userName : (msg.senderName || 'Agent')}</div>
                                    <div class="message ${msg.isUser ? 'user' : 'agent'}">${msg.content}</div>
                                    <div class="message-time">${formatTime(now)}</div>
                                `;
                                wrapper.appendChild(avatar);
                                wrapper.appendChild(content);
                                typingIndicator.parentNode.insertBefore(wrapper, typingIndicator);
                            }
                        }
                    });
                    
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    
                    // Start polling for new messages
                    setInterval(pollMessages, 3000);
                    
                    console.log('‚úÖ Chat session fully restored with', chatMessages.length, 'messages');
                    return true;
                    
                } catch (reconnectError) {
                    console.error('‚ùå Failed to reconnect:', reconnectError);
                    localStorage.removeItem('chatWidgetSession');
                    showView('prechat');
                    return false;
                }
                
            } catch (error) {
                console.error('‚ùå Error restoring session:', error);
                localStorage.removeItem('chatWidgetSession');
            }
            
            return false;
        }

        async function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file || !chatSDK || !chatStarted) return;
            try {
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    if (file.type.startsWith('image/')) { addImageMessage({ name: file.name, url: ev.target.result }, true, userName, null); }
                };
                reader.readAsDataURL(file);
                await chatSDK.uploadFileAttachment(file);
            } catch (err) { console.error('File upload error:', err); alert('Failed to upload file'); }
            fileInput.value = '';
        }

        async function initializeChat(name, email, question) {
            try {
                showView('connecting');
                chatMessages = [];
                processedMessageIds.clear(); // Clear any previously tracked messages
                const OmnichannelChatSDK = window.OmnichannelChatSDK;
                chatSDK = new OmnichannelChatSDK(omnichannelConfig);
                await chatSDK.initialize();
                console.log('SDK initialized');
                
                // Set up message listener BEFORE starting chat
                chatSDK.onNewMessage((msg) => {
                    console.log('üì® onNewMessage event received:', msg);
                    console.log('üì® Message details - tags:', msg?.tags, 'type:', msg?.type || msg?.messageType, 'metadata:', msg?.metadata, 'role:', msg?.role, 'id:', msg?.messageId || msg?.id);
                    if (msg) {
                        processMessage(msg);
                    }
                });
                
                chatSDK.onTypingEvent(() => {
                    console.log('Typing event received');
                    typingIndicator.classList.add('active');
                    setTimeout(() => typingIndicator.classList.remove('active'), 3000);
                });
                
                chatSDK.onAgentEndSession(() => { 
                    console.log('Agent ended session');
                    localStorage.removeItem('chatWidgetSession'); // Clear session when ended
                    showView('ended'); 
                });
                
                // Pre-load the VoiceVideoCallingSDK (but don't initialize yet - needs chat token from startChat)
                await preloadVoiceVideoCallingSDK(chatSDK);
                
                // D365 Context - uses proper field identifiers for contact authentication
                // 'Name' and 'emailaddress1' allow D365 to automatically populate contact records
                const customContext = {
                    'emailaddress1': { value: email, isDisplayable: true }, // Contact email in Dynamics 365
                    'Name': { value: name, isDisplayable: true }, // Contact name in Dynamics 365
                    'Authenticated': { value: 'Authenticated', isDisplayable: true }, // Authentication status
                    'InitialQuestion': { value: question || '', isDisplayable: true }
                };
                
                // Also store in localStorage for standard mode context provider
                localStorage.setItem('d365ChatContext', JSON.stringify({ name, email, question }));
                
                await chatSDK.startChat({ customContext });
                console.log('Chat started with D365 context:', customContext);
                chatStarted = true;
                
                // NOW initialize VoiceVideoCallingSDK (AFTER startChat - chat token is now valid)
                await initializeVoiceVideoCallingSDK(chatSDK);
                
                // Voice/video call buttons removed - only agents can initiate calls
                
                saveChatSession(); // Save initial session state
                showView('chat');
                if (question) { await sendMessageText(question); }
                setInterval(pollMessages, 3000);
            } catch (error) {
                console.error('Chat init error:', error);
                alert('Failed to start chat. Please try again.');
                showView('prechat');
                startBtn.disabled = false; startBtn.textContent = 'Start Chat';
            }
        }

        async function sendMessageText(text) {
            if (!text || !chatSDK || !chatStarted) return;
            addMessage(text, true, userName, null);
            try { await chatSDK.sendMessage({ content: text }); } catch (e) { console.error('Send error:', e); }
        }
        
        // ============ INCOMING CALL HANDLING (Agent-Initiated) ============
        
        // Global VoiceVideoCallingSDK instance
        let VoiceVideoCallingSDK = null;
        
        // Step 1: Pre-load the SDK before startChat (but don't initialize)
        async function preloadVoiceVideoCallingSDK(sdk) {
            console.log('üìû Pre-loading VoiceVideoCallingSDK...');
            
            try {
                if (!sdk.getVoiceVideoCalling) {
                    console.log('‚ö†Ô∏è getVoiceVideoCalling not available on SDK');
                    return;
                }
                
                VoiceVideoCallingSDK = await sdk.getVoiceVideoCalling();
                console.log('üìû VoiceVideoCallingSDK pre-loaded:', VoiceVideoCallingSDK ? 'Yes' : 'No');
                
            } catch (err) {
                console.log('‚ö†Ô∏è VoiceVideoCalling pre-load error:', err);
                
                if (err.message === 'UnsupportedPlatform') {
                    console.log('‚ö†Ô∏è Voice/Video calling not supported on this platform');
                } else if (err.message === 'FeatureDisabled') {
                    console.log('‚ö†Ô∏è Voice/Video calling is disabled in admin settings');
                }
            }
        }
        
        // Step 2: Initialize the SDK AFTER startChat (chat token is now valid)
        async function initializeVoiceVideoCallingSDK(sdk) {
            console.log('üìû Initializing VoiceVideoCallingSDK...');
            
            if (!VoiceVideoCallingSDK) {
                console.log('‚ö†Ô∏è VoiceVideoCallingSDK was not pre-loaded');
                return;
            }
            
            try {
                // Get chat token - THIS IS ONLY VALID AFTER startChat()
                const chatToken = await sdk.getChatToken();
                console.log('üìû Chat token obtained:', chatToken ? 'Yes' : 'No');
                
                if (!chatToken) {
                    console.error('‚ùå Failed to get chat token for VoiceVideoCalling');
                    return;
                }
                
                // Initialize VoiceVideoCallingSDK with required parameters
                // This registers the customer endpoint with ACS (Azure Communication Services)
                await VoiceVideoCallingSDK.initialize({
                    chatToken: chatToken,
                    selfVideoHTMLElementId: 'localVideo',      // HTML element for local video
                    remoteVideoHTMLElementId: 'remoteVideo',   // HTML element for remote video
                    OCClient: sdk.OCClient
                });
                console.log('‚úÖ VoiceVideoCallingSDK initialized successfully');
                
                // IMPORTANT: Also set element IDs on proxyInstance directly
                if (VoiceVideoCallingSDK.proxyInstance) {
                    VoiceVideoCallingSDK.proxyInstance._selfVideoHTMLElementId = 'localVideo';
                    VoiceVideoCallingSDK.proxyInstance._remoteVideoHTMLElementId = 'remoteVideo';
                    console.log('üìπ Video element IDs configured on proxyInstance');
                }
                
                // Log available SDK methods to help debug video detection
                console.log('üìû Available SDK methods:', Object.keys(VoiceVideoCallingSDK).filter(k => typeof VoiceVideoCallingSDK[k] === 'function'));
                
                // Set up incoming call listener - THIS IS THE KEY PART
                // This registers the callback that fires when agent initiates a call
                VoiceVideoCallingSDK.onCallAdded((callInfo) => {
                    console.log('üìû ========================================');
                    console.log('üìû INCOMING CALL DETECTED via onCallAdded!');
                    console.log('üìû ========================================');
                    
                    try {
                        // DEEP INSPECTION: Log everything about callInfo
                        console.log('üìû callInfo raw:', callInfo);
                        console.log('üìû callInfo type:', typeof callInfo);
                        
                        if (callInfo) {
                            // All own properties
                            console.log('üìû callInfo keys:', Object.keys(callInfo));
                            
                            // Full JSON dump
                            try {
                                console.log('üìû callInfo JSON:', JSON.stringify(callInfo, null, 2));
                            } catch (e) {
                                console.log('üìû callInfo not JSON-serializable');
                            }
                            
                            // Check all properties including nested
                            for (const key of Object.keys(callInfo)) {
                                const val = callInfo[key];
                                console.log(`üìû callInfo.${key}:`, val, '(type:', typeof val + ')');
                                // If it's an object, dive deeper
                                if (val && typeof val === 'object') {
                                    try {
                                        console.log(`üìû   ${key} nested keys:`, Object.keys(val));
                                        for (const subKey of Object.keys(val)) {
                                            console.log(`üìû   ${key}.${subKey}:`, val[subKey]);
                                        }
                                    } catch (e) {}
                                }
                            }
                            
                            // Check prototype methods
                            const proto = Object.getPrototypeOf(callInfo);
                            if (proto && proto !== Object.prototype) {
                                console.log('üìû callInfo prototype methods:', Object.getOwnPropertyNames(proto));
                            }
                        }
                        
                        // DEEP INSPECTION: Check VoiceVideoCallingSDK for any call-related state
                        console.log('üìû VoiceVideoCallingSDK methods:', Object.keys(VoiceVideoCallingSDK));
                        
                        // Try to access any call state
                        const sdkMethods = ['getCurrentCall', 'getCall', 'getCallInfo', 'getIncomingCall',
                                           'getCallState', 'getCallType', 'getMediaType', 'getVideoState',
                                           'isVideoEnabled', 'hasVideoCapability', 'getCallFeatures'];
                        for (const method of sdkMethods) {
                            if (typeof VoiceVideoCallingSDK[method] === 'function') {
                                try {
                                    const result = VoiceVideoCallingSDK[method]();
                                    console.log(`üìû SDK.${method}():`, result);
                                    if (result && typeof result === 'object') {
                                        console.log(`üìû   ${method} keys:`, Object.keys(result));
                                    }
                                } catch (e) {
                                    console.log(`üìû SDK.${method}() error:`, e.message);
                                }
                            }
                        }
                        
                        // Determine if video call - check multiple indicators
                        let hasVideo = false;
                        
                        // Check the callInfo parameter passed to onCallAdded
                        if (callInfo) {
                            hasVideo = callInfo.isVideoCall || callInfo.hasVideo || 
                                       callInfo.videoEnabled || callInfo.isVideo ||
                                       callInfo.callType === 'video' || callInfo.type === 'video' ||
                                       callInfo.mediaType === 'video' || callInfo.withVideo ||
                                       (callInfo.callClientName && callInfo.callClientName.toLowerCase().includes('video')) ||
                                       false;
                                       
                            // Check nested objects for video indicators
                            if (!hasVideo && callInfo.options) {
                                hasVideo = callInfo.options.videoEnabled || callInfo.options.isVideo || 
                                           callInfo.options.withVideo || false;
                            }
                            if (!hasVideo && callInfo.callOptions) {
                                hasVideo = callInfo.callOptions.videoEnabled || callInfo.callOptions.isVideo ||
                                           callInfo.callOptions.withVideo || false;
                            }
                            if (!hasVideo && callInfo.mediaOptions) {
                                hasVideo = callInfo.mediaOptions.video || callInfo.mediaOptions.videoEnabled || false;
                            }
                        }
                        
                        // Try to get call info from SDK methods
                        if (!hasVideo && VoiceVideoCallingSDK.isRemoteVideoEnabled) {
                            try {
                                hasVideo = VoiceVideoCallingSDK.isRemoteVideoEnabled();
                                console.log('üìû isRemoteVideoEnabled():', hasVideo);
                            } catch (e) { console.log('üìû isRemoteVideoEnabled error:', e); }
                        }
                        
                        // Check SDK state for video capability
                        if (!hasVideo && VoiceVideoCallingSDK.isVideoCall) {
                            try {
                                hasVideo = VoiceVideoCallingSDK.isVideoCall();
                                console.log('üìû isVideoCall():', hasVideo);
                            } catch (e) { console.log('üìû isVideoCall error:', e); }
                        }
                        
                        // Check if local video is being requested
                        if (!hasVideo && VoiceVideoCallingSDK.isLocalVideoEnabled) {
                            try {
                                hasVideo = VoiceVideoCallingSDK.isLocalVideoEnabled();
                                console.log('üìû isLocalVideoEnabled():', hasVideo);
                            } catch (e) { console.log('üìû isLocalVideoEnabled error:', e); }
                        }
                        
                        console.log('üìû ========================================');
                        console.log('üìû Final video call detection:', hasVideo);
                        console.log('üìû ========================================');
                        
                        showIncomingCallNotification({ 
                            isVideo: hasVideo, 
                            agentName: currentAgentName || 'Agent',
                            sdk: VoiceVideoCallingSDK
                        });
                    } catch (err) {
                        console.error('‚ùå Error in onCallAdded handler:', err);
                    }
                });
                
                // Set up call disconnected listener - handles both connected calls ending 
                // AND when agent cancels before customer answers
                VoiceVideoCallingSDK.onCallDisconnected(() => {
                    console.log('üìû Call disconnected by remote party');
                    
                    // Hide incoming call notification if it's still showing
                    const notification = document.getElementById('incomingCallNotification');
                    if (notification && notification.style.display !== 'none') {
                        console.log('üìû Hiding incoming call notification (agent cancelled)');
                        notification.style.display = 'none';
                        pendingCallData = null;
                    }
                    
                    // End the call if we're in a call
                    if (isInCall) {
                        endCall();
                    }
                });
                
                // Set up call removed listener (if available) - fires when call is cancelled
                if (VoiceVideoCallingSDK.onCallRemoved) {
                    VoiceVideoCallingSDK.onCallRemoved(() => {
                        console.log('üìû Call removed (agent cancelled the call)');
                        
                        // Hide incoming call notification
                        const notification = document.getElementById('incomingCallNotification');
                        if (notification) {
                            notification.style.display = 'none';
                        }
                        pendingCallData = null;
                        
                        if (isInCall) {
                            endCall();
                        }
                    });
                }
                
                // Set up call ended listener (if available)
                if (VoiceVideoCallingSDK.onCallEnded) {
                    VoiceVideoCallingSDK.onCallEnded(() => {
                        console.log('üìû Call ended event received');
                        
                        // Hide incoming call notification if showing
                        const notification = document.getElementById('incomingCallNotification');
                        if (notification) {
                            notification.style.display = 'none';
                        }
                        pendingCallData = null;
                        
                        if (isInCall) {
                            endCall();
                        }
                    });
                }
                
                // Set up call connected listener to start video after connection
                if (VoiceVideoCallingSDK.onCallConnected) {
                    VoiceVideoCallingSDK.onCallConnected(async () => {
                        console.log('üìû Call connected event received');
                        callStatus.textContent = 'Connected';
                        
                        // If this is a video call, ensure video is started
                        if (isVideoCall && VoiceVideoCallingSDK.startVideo) {
                            console.log('üìπ Auto-starting video after call connected...');
                            try {
                                await VoiceVideoCallingSDK.startVideo();
                                console.log('‚úÖ Video started after connection');
                            } catch (err) {
                                console.warn('‚ö†Ô∏è Could not auto-start video:', err);
                            }
                        }
                    });
                }
                
                // Set up remote video stream listeners
                if (VoiceVideoCallingSDK.onRemoteVideoStreamAdded) {
                    VoiceVideoCallingSDK.onRemoteVideoStreamAdded(async (streamInfo) => {
                        console.log('üìπ Remote video stream added - showing remote video');
                        console.log('üìπ Stream info:', streamInfo);
                        console.log('üìπ Stream info type:', typeof streamInfo);
                        if (streamInfo) {
                            console.log('üìπ Stream info keys:', Object.keys(streamInfo));
                        }
                        
                        remoteVideo.style.display = 'block';
                        callAvatar.style.display = 'none';
                        
                        // IMPORTANT: Ensure element IDs are set on proxyInstance
                        if (VoiceVideoCallingSDK.proxyInstance) {
                            VoiceVideoCallingSDK.proxyInstance._selfVideoHTMLElementId = 'localVideo';
                            VoiceVideoCallingSDK.proxyInstance._remoteVideoHTMLElementId = 'remoteVideo';
                            console.log('üìπ Element IDs confirmed on proxyInstance');
                        }
                        
                        // Try to get the actual call object and render remote video
                        if (VoiceVideoCallingSDK.proxyInstance?._callClients) {
                            for (const [clientName, client] of VoiceVideoCallingSDK.proxyInstance._callClients) {
                                if (client._calls) {
                                    for (const [callId, call] of client._calls) {
                                        console.log('üìπ Found call in onRemoteVideoStreamAdded:', callId);
                                        
                                        // Try to access remote participants
                                        if (call.remoteParticipants) {
                                            console.log('üìπ Remote participants:', call.remoteParticipants.length);
                                            
                                            for (const participant of call.remoteParticipants) {
                                                console.log('üìπ Checking participant:', participant);
                                                
                                                if (participant.videoStreams) {
                                                    for (const stream of participant.videoStreams) {
                                                        console.log('üìπ Found video stream:', stream);
                                                        console.log('üìπ Stream.isAvailable:', stream.isAvailable);
                                                        
                                                        if (stream.isAvailable) {
                                                            // Try getMediaStream
                                                            if (typeof stream.getMediaStream === 'function') {
                                                                try {
                                                                    const ms = await stream.getMediaStream();
                                                                    if (ms instanceof MediaStream) {
                                                                        console.log('‚úÖ Got MediaStream in onRemoteVideoStreamAdded!');
                                                                        remoteVideo.srcObject = ms;
                                                                        remoteVideo.play().catch(e => {});
                                                                    }
                                                                } catch (e) {
                                                                    console.log('üìπ getMediaStream error:', e);
                                                                }
                                                            }
                                                        }
                                                        
                                                        // Set up listener for when stream becomes available
                                                        if (stream.on) {
                                                            stream.on('isAvailableChanged', async () => {
                                                                console.log('üìπ Stream availability changed:', stream.isAvailable);
                                                                if (stream.isAvailable && typeof stream.getMediaStream === 'function') {
                                                                    try {
                                                                        const ms = await stream.getMediaStream();
                                                                        if (ms instanceof MediaStream) {
                                                                            console.log('‚úÖ Got MediaStream after availability change!');
                                                                            remoteVideo.srcObject = ms;
                                                                            remoteVideo.play().catch(e => {});
                                                                        }
                                                                    } catch (e) {
                                                                        console.log('üìπ getMediaStream error:', e);
                                                                    }
                                                                }
                                                            });
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Call renderVideoStreams as backup
                        if (VoiceVideoCallingSDK.renderVideoStreams) {
                            try {
                                console.log('üìπ Calling renderVideoStreams...');
                                await VoiceVideoCallingSDK.renderVideoStreams();
                                console.log('‚úÖ renderVideoStreams completed');
                            } catch (err) {
                                console.warn('‚ö†Ô∏è renderVideoStreams error:', err);
                            }
                        }
                        
                        // Also update the call status to indicate video is active
                        if (isInCall) {
                            callStatus.textContent = 'Video Call - Connected';
                            isVideoCall = true;
                        }
                    });
                }
                
                if (VoiceVideoCallingSDK.onRemoteVideoStreamRemoved) {
                    VoiceVideoCallingSDK.onRemoteVideoStreamRemoved(() => {
                        console.log('üìπ Remote video stream removed');
                        remoteVideo.style.display = 'none';
                        if (isInCall) {
                            callAvatar.style.display = 'flex';
                        }
                    });
                }
                
                // Set up local video stream listeners
                if (VoiceVideoCallingSDK.onLocalVideoStreamAdded) {
                    VoiceVideoCallingSDK.onLocalVideoStreamAdded(async (streamInfo) => {
                        console.log('üìπ Local video stream added');
                        console.log('üìπ Local stream info:', streamInfo);
                        if (streamInfo) {
                            console.log('üìπ Local stream info keys:', Object.keys(streamInfo));
                        }
                        
                        localVideo.style.display = 'block';
                        
                        // Try createView for local video
                        if (VoiceVideoCallingSDK.createView) {
                            try {
                                console.log('üìπ Attempting SDK createView for local video...');
                                const view = await VoiceVideoCallingSDK.createView(streamInfo, { 
                                    scalingMode: 'Fit',
                                    isMirrored: true 
                                });
                                if (view && view.target) {
                                    localVideo.parentElement.appendChild(view.target);
                                    console.log('‚úÖ Local video rendered via createView');
                                }
                            } catch (err) {
                                console.warn('‚ö†Ô∏è Local createView failed:', err);
                            }
                        }
                        
                        // Try renderLocalVideo if available
                        if (VoiceVideoCallingSDK.renderLocalVideo) {
                            try {
                                console.log('üìπ Attempting SDK renderLocalVideo...');
                                await VoiceVideoCallingSDK.renderLocalVideo(localVideo);
                                console.log('‚úÖ Local video rendered via renderLocalVideo');
                            } catch (err) {
                                console.warn('‚ö†Ô∏è renderLocalVideo failed:', err);
                            }
                        }
                        
                        // Try various methods to get MediaStream
                        const localMethods = ['getLocalVideoStream', 'getLocalStream', 'getLocalMediaStream'];
                        for (const method of localMethods) {
                            if (typeof VoiceVideoCallingSDK[method] === 'function') {
                                try {
                                    const ms = await VoiceVideoCallingSDK[method]();
                                    if (ms instanceof MediaStream) {
                                        localVideo.srcObject = ms;
                                        console.log(`‚úÖ Local stream via ${method}`);
                                        break;
                                    }
                                } catch (err) {
                                    console.log(`üìπ ${method} error:`, err.message);
                                }
                            }
                        }
                        
                        // Check streamInfo for MediaStream
                        if (streamInfo) {
                            if (streamInfo instanceof MediaStream) {
                                localVideo.srcObject = streamInfo;
                                console.log('‚úÖ Local streamInfo was MediaStream');
                            } else if (typeof streamInfo.getMediaStream === 'function') {
                                try {
                                    localVideo.srcObject = await streamInfo.getMediaStream();
                                    console.log('‚úÖ Local stream via streamInfo.getMediaStream()');
                                } catch (e) {}
                            } else if (streamInfo.stream instanceof MediaStream) {
                                localVideo.srcObject = streamInfo.stream;
                                console.log('‚úÖ Local stream via streamInfo.stream');
                            }
                        }
                    });
                }
                
                if (VoiceVideoCallingSDK.onLocalVideoStreamRemoved) {
                    VoiceVideoCallingSDK.onLocalVideoStreamRemoved(() => {
                        console.log('üìπ Local video stream removed');
                        localVideo.style.display = 'none';
                        localVideo.srcObject = null;
                    });
                }
                
                console.log('‚úÖ All VoiceVideoCallingSDK event listeners configured');
                
            } catch (err) {
                console.error('‚ùå VoiceVideoCallingSDK initialization error:', err);
            }
        }
        
        function showIncomingCallNotification(callData) {
            console.log('üìû showIncomingCallNotification called with:', callData);
            
            try {
                // Get DOM elements (in case they weren't captured at init time)
                const notificationEl = document.getElementById('incomingCallNotification');
                const titleEl = document.getElementById('incomingCallTitle');
                const subtitleEl = document.getElementById('incomingCallSubtitle');
                const containerEl = document.getElementById('chatContainer');
                
                console.log('üìû DOM elements found - notification:', !!notificationEl, 'title:', !!titleEl, 'subtitle:', !!subtitleEl, 'container:', !!containerEl);
                
                if (!notificationEl) {
                    console.error('‚ùå incomingCallNotification element not found!');
                    return;
                }
                
                // Make sure the chat container is open
                if (containerEl && !containerEl.classList.contains('open')) {
                    console.log('üìû Opening chat container for incoming call...');
                    containerEl.classList.add('open');
                }
                
                pendingCallData = callData;
                
                // Note: D365 SDK doesn't reliably tell us if it's video or voice
                // So we show a generic "Incoming Call" and let user choose how to answer
                const agentName = callData?.agentName || callData?.from || 'Agent';
                
                console.log('üìû Setting notification for incoming call from:', agentName);
                
                if (titleEl) titleEl.textContent = 'Incoming Call';
                if (subtitleEl) subtitleEl.textContent = `${agentName} is calling you...`;
                
                // Use a combined phone/video icon
                const iconEl = notificationEl.querySelector('.incoming-call-icon');
                if (iconEl) {
                    // Phone icon - user will choose video or voice when accepting
                    iconEl.innerHTML = '<svg viewBox="0 0 24 24" width="22" height="22"><path fill="white" d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-1.57 1.97c-2.83-1.35-5.48-3.9-6.89-6.83l1.95-1.66c.27-.28.35-.67.24-1.02-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19C3.65 3 3 3.24 3 3.99 3 13.28 10.73 21 20.01 21c.71 0 .99-.63.99-1.18v-3.45c0-.54-.45-.99-.99-.99z"/></svg>';
                }
                
                // Make sure the notification is visible with high z-index
                notificationEl.style.display = 'block';
                notificationEl.style.visibility = 'visible';
                notificationEl.style.opacity = '1';
                notificationEl.style.zIndex = '10000';
                notificationEl.style.position = 'absolute';
                notificationEl.style.top = '60px';
                notificationEl.style.left = '0';
                notificationEl.style.right = '0';
                
                console.log('üìû Notification display set to:', notificationEl.style.display);
                console.log('üìû Notification offsetHeight:', notificationEl.offsetHeight);
                console.log('‚úÖ Notification banner should now be visible');
                
                // Play notification sound if available
                playNotificationSound();
                
            } catch (err) {
                console.error('‚ùå Error showing incoming call notification:', err);
            }
        }
        
        async function acceptIncomingCall(withVideo = false) {
            console.log('‚úÖ Accepting incoming call...');
            console.log('üìû VoiceVideoCallingSDK available:', !!VoiceVideoCallingSDK);
            console.log('üìû pendingCallData:', pendingCallData);
            console.log('üìû User chose to accept with video:', withVideo);
            
            // Set isVideoCall based on user's choice
            isVideoCall = withVideo;
            
            incomingCallNotification.style.display = 'none';
            
            try {
                // Request permissions based on user's choice
                if (withVideo) {
                    console.log('üìπ Requesting camera and microphone permissions...');
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            video: true, 
                            audio: true 
                        });
                        console.log('‚úÖ Camera and microphone permissions granted');
                        // Stop the test stream - the SDK will create its own
                        stream.getTracks().forEach(track => track.stop());
                    } catch (permErr) {
                        console.warn('‚ö†Ô∏è Could not get media permissions:', permErr);
                        // Continue anyway - SDK might handle this
                    }
                } else {
                    // Voice only - just request microphone
                    console.log('üé§ Requesting microphone permission...');
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        console.log('‚úÖ Microphone permission granted');
                        stream.getTracks().forEach(track => track.stop());
                    } catch (permErr) {
                        console.warn('‚ö†Ô∏è Could not get microphone permission:', permErr);
                    }
                }
                
                // Show call UI with connecting state
                callContainer.classList.add('active');
                callConnecting.style.display = 'flex';
                callAvatar.style.display = 'none';
                remoteVideo.style.display = 'none';
                localVideo.style.display = 'none';
                toggleCameraBtn.style.display = isVideoCall ? 'flex' : 'none';
                callStatus.textContent = 'Connecting...';
                
                // Use the global VoiceVideoCallingSDK that was initialized in initializeVoiceVideoCallingSDK
                if (!VoiceVideoCallingSDK) {
                    throw new Error('VoiceVideoCallingSDK not initialized');
                }
                
                // Accept the call using the SDK's acceptCall method
                // The SDK handles media permissions internally
                const acceptCallConfig = {
                    withVideo: isVideoCall // Accept with video if it's a video call
                };
                
                console.log('üìû Calling VoiceVideoCallingSDK.acceptCall with config:', acceptCallConfig);
                await VoiceVideoCallingSDK.acceptCall(acceptCallConfig);
                console.log('‚úÖ VoiceVideoCallingSDK.acceptCall completed successfully');
                
                // DEEP INSPECTION: Log all available SDK methods after call is accepted
                console.log('üìπ ========== POST-ACCEPT SDK INSPECTION ==========');
                console.log('üìπ SDK keys:', Object.keys(VoiceVideoCallingSDK));
                
                // Check for video rendering methods
                const videoMethods = [
                    'createView', 'disposeView', 'renderView',
                    'renderRemoteVideo', 'renderLocalVideo', 'renderVideoStreams',
                    'getRemoteVideoStream', 'getLocalVideoStream',
                    'getRemoteParticipants', 'getRemoteParticipant',
                    'getCall', 'getCurrentCall', 'getCallInfo',
                    'startLocalVideoStream', 'stopLocalVideoStream',
                    'startRemoteVideoStream', 'stopRemoteVideoStream',
                    'createLocalVideoStream', 'createRemoteVideoStream',
                    'getVideoDevices', 'getCameras', 'getSelectedCamera',
                    'attachVideo', 'detachVideo', 'bindVideo'
                ];
                
                for (const method of videoMethods) {
                    if (typeof VoiceVideoCallingSDK[method] === 'function') {
                        console.log(`üìπ SDK.${method} = function ‚úÖ`);
                    }
                }
                
                // Check if proxy has additional methods
                if (VoiceVideoCallingSDK.proxy) {
                    console.log('üìπ SDK.proxy exists, checking its methods...');
                    console.log('üìπ SDK.proxy keys:', Object.keys(VoiceVideoCallingSDK.proxy));
                }
                
                if (VoiceVideoCallingSDK.proxyInstance) {
                    console.log('üìπ SDK.proxyInstance exists, checking...');
                    console.log('üìπ SDK.proxyInstance type:', typeof VoiceVideoCallingSDK.proxyInstance);
                    if (typeof VoiceVideoCallingSDK.proxyInstance === 'object') {
                        console.log('üìπ SDK.proxyInstance keys:', Object.keys(VoiceVideoCallingSDK.proxyInstance));
                        
                        // KEY DISCOVERY: Check the video element IDs the SDK expects
                        const pi = VoiceVideoCallingSDK.proxyInstance;
                        console.log('üìπ _selfVideoHTMLElementId:', pi._selfVideoHTMLElementId);
                        console.log('üìπ _remoteVideoHTMLElementId:', pi._remoteVideoHTMLElementId);
                        
                        // Set our element IDs so the SDK knows where to render!
                        console.log('üìπ Setting our video element IDs on proxyInstance...');
                        pi._selfVideoHTMLElementId = 'localVideo';
                        pi._remoteVideoHTMLElementId = 'remoteVideo';
                        console.log('üìπ Element IDs set: localVideo, remoteVideo');
                        
                        // Check _voiceVideoCallingStream for actual stream
                        if (pi._voiceVideoCallingStream) {
                            console.log('üìπ _voiceVideoCallingStream exists!');
                            console.log('üìπ _voiceVideoCallingStream:', pi._voiceVideoCallingStream);
                            console.log('üìπ _voiceVideoCallingStream type:', typeof pi._voiceVideoCallingStream);
                            if (typeof pi._voiceVideoCallingStream === 'object') {
                                console.log('üìπ _voiceVideoCallingStream keys:', Object.keys(pi._voiceVideoCallingStream));
                            }
                        }
                        
                        // Check _callClients for active call
                        if (pi._callClients) {
                            console.log('üìπ _callClients:', pi._callClients);
                            if (pi._callClients instanceof Map) {
                                console.log('üìπ _callClients is a Map with', pi._callClients.size, 'entries');
                                pi._callClients.forEach((value, key) => {
                                    console.log(`üìπ _callClients[${key}]:`, value);
                                    if (value && typeof value === 'object') {
                                        console.log(`üìπ _callClients[${key}] keys:`, Object.keys(value));
                                    }
                                });
                            }
                        }
                    }
                }
                
                // Try to get call agent or call object
                if (VoiceVideoCallingSDK.callAgent) {
                    console.log('üìπ SDK.callAgent exists');
                    console.log('üìπ SDK.callAgent keys:', Object.keys(VoiceVideoCallingSDK.callAgent));
                }
                
                if (VoiceVideoCallingSDK.call) {
                    console.log('üìπ SDK.call exists');
                    console.log('üìπ SDK.call keys:', Object.keys(VoiceVideoCallingSDK.call));
                }
                
                console.log('üìπ ========== END POST-ACCEPT INSPECTION ==========');
                
                // Store reference for later use
                window.activeVoiceVideoCall = VoiceVideoCallingSDK;
                
                // Update state
                isInCall = true;
                callConnecting.style.display = 'none';
                callStatus.textContent = isVideoCall ? 'Video Call' : 'Voice Call';
                
                // Show appropriate UI based on call type
                if (!isVideoCall) {
                    callAvatar.style.display = 'flex';
                    callAvatar.textContent = getInitials(pendingCallData?.agentName || currentAgentName || 'Agent');
                }
                
                // For video calls, we need to explicitly start local video after accepting
                if (isVideoCall) {
                    console.log('üìπ Starting local video for video call...');
                    
                    // Try to start local video - the SDK should render to the configured element
                    if (VoiceVideoCallingSDK.startVideo) {
                        try {
                            await VoiceVideoCallingSDK.startVideo();
                            console.log('‚úÖ Local video started');
                            localVideo.style.display = 'block';
                        } catch (videoErr) {
                            console.warn('‚ö†Ô∏è Could not start local video:', videoErr);
                            // Continue with the call even if local video fails
                        }
                    } else if (VoiceVideoCallingSDK.toggleLocalVideo) {
                        // Fallback: use toggleLocalVideo if startVideo doesn't exist
                        try {
                            // Check if video is off and turn it on
                            const isVideoOn = VoiceVideoCallingSDK.isLocalVideoEnabled ? 
                                              VoiceVideoCallingSDK.isLocalVideoEnabled() : false;
                            if (!isVideoOn) {
                                await VoiceVideoCallingSDK.toggleLocalVideo();
                                console.log('‚úÖ Local video toggled on');
                            }
                            localVideo.style.display = 'block';
                        } catch (videoErr) {
                            console.warn('‚ö†Ô∏è Could not toggle local video:', videoErr);
                        }
                    }
                    
                    // The remote video should be handled by onRemoteVideoStreamAdded event
                    // But let's check if remote video is already available
                    if (VoiceVideoCallingSDK.isRemoteVideoEnabled) {
                        const remoteVideoEnabled = VoiceVideoCallingSDK.isRemoteVideoEnabled();
                        console.log('üìπ Remote video enabled:', remoteVideoEnabled);
                        if (remoteVideoEnabled) {
                            remoteVideo.style.display = 'block';
                            callAvatar.style.display = 'none';
                        }
                    }
                    
                    // Try to render video streams if the SDK has this method
                    // This is sometimes needed to attach streams to HTML elements
                    if (VoiceVideoCallingSDK.renderVideoStreams) {
                        try {
                            await VoiceVideoCallingSDK.renderVideoStreams();
                            console.log('‚úÖ Video streams rendered');
                        } catch (renderErr) {
                            console.warn('‚ö†Ô∏è Could not render video streams:', renderErr);
                        }
                    }
                    
                    // Also try createView for local and remote video if available
                    if (VoiceVideoCallingSDK.createLocalVideoStream) {
                        try {
                            const localStream = await VoiceVideoCallingSDK.createLocalVideoStream();
                            if (localStream && localStream.getMediaStream) {
                                localVideo.srcObject = localStream.getMediaStream();
                                console.log('‚úÖ Local video stream attached directly');
                            }
                        } catch (streamErr) {
                            console.warn('‚ö†Ô∏è Could not create local video stream:', streamErr);
                        }
                    }
                }
                
                startCallDuration();
                
                console.log('‚úÖ Call accepted and connected');
                
                // DEEP INSPECTION: Find the actual video streams after call connects
                console.log('üìπ ========== DEEP STREAM INSPECTION ==========');
                
                // Helper function to render remote video streams from ACS call object
                async function renderRemoteVideoFromCall(call) {
                    console.log('üìπ Attempting to render remote video from call object...');
                    console.log('üìπ Call:', call);
                    console.log('üìπ Call keys:', Object.keys(call));
                    
                    // Check for remoteParticipants
                    let participants = null;
                    if (call.remoteParticipants) {
                        participants = call.remoteParticipants;
                    } else if (call._remoteParticipants) {
                        participants = call._remoteParticipants;
                    } else if (typeof call.getRemoteParticipants === 'function') {
                        participants = call.getRemoteParticipants();
                    }
                    
                    if (participants) {
                        console.log('üìπ Remote participants found:', participants);
                        console.log('üìπ Participants type:', typeof participants);
                        
                        // Handle both array and Map
                        const participantList = participants instanceof Map 
                            ? Array.from(participants.values()) 
                            : (Array.isArray(participants) ? participants : [participants]);
                        
                        console.log('üìπ Participant count:', participantList.length);
                        
                        for (const participant of participantList) {
                            console.log('üìπ Processing participant:', participant);
                            if (participant && typeof participant === 'object') {
                                console.log('üìπ Participant keys:', Object.keys(participant));
                            }
                            
                            // Get video streams
                            let videoStreams = null;
                            if (participant.videoStreams) {
                                videoStreams = participant.videoStreams;
                            } else if (participant._videoStreams) {
                                videoStreams = participant._videoStreams;
                            } else if (typeof participant.getVideoStreams === 'function') {
                                videoStreams = participant.getVideoStreams();
                            }
                            
                            if (videoStreams) {
                                console.log('üìπ Video streams found:', videoStreams);
                                const streamList = Array.isArray(videoStreams) ? videoStreams : [videoStreams];
                                
                                for (const stream of streamList) {
                                    console.log('üìπ Processing video stream:', stream);
                                    if (stream && typeof stream === 'object') {
                                        console.log('üìπ Stream keys:', Object.keys(stream));
                                        console.log('üìπ Stream isAvailable:', stream.isAvailable);
                                        console.log('üìπ Stream mediaStreamType:', stream.mediaStreamType);
                                    }
                                    
                                    // Try to get MediaStream directly
                                    if (stream instanceof MediaStream) {
                                        console.log('üìπ Stream IS a MediaStream!');
                                        remoteVideo.srcObject = stream;
                                        remoteVideo.play().catch(e => console.log('Play error:', e));
                                        return true;
                                    }
                                    
                                    // Try getMediaStream() method
                                    if (typeof stream.getMediaStream === 'function') {
                                        try {
                                            const ms = await stream.getMediaStream();
                                            if (ms instanceof MediaStream) {
                                                console.log('üìπ Got MediaStream via getMediaStream()!');
                                                remoteVideo.srcObject = ms;
                                                remoteVideo.play().catch(e => console.log('Play error:', e));
                                                return true;
                                            }
                                        } catch (e) {
                                            console.log('üìπ getMediaStream error:', e);
                                        }
                                    }
                                    
                                    // Try createView() - ACS pattern for rendering
                                    if (call.createView || (stream && typeof stream.createView === 'function')) {
                                        try {
                                            console.log('üìπ Trying createView for remote stream...');
                                            const createViewFn = stream.createView || call.createView;
                                            const view = await createViewFn(stream, { scalingMode: 'Fit' });
                                            if (view && view.target) {
                                                console.log('üìπ createView succeeded, appending to DOM');
                                                // Clear existing content and append
                                                const container = remoteVideo.parentElement;
                                                view.target.style.width = '100%';
                                                view.target.style.height = '100%';
                                                view.target.style.objectFit = 'cover';
                                                container.appendChild(view.target);
                                                remoteVideo.style.display = 'none';
                                                return true;
                                            }
                                        } catch (e) {
                                            console.log('üìπ createView error:', e);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return false;
                }
                
                if (VoiceVideoCallingSDK.proxyInstance) {
                    const pi = VoiceVideoCallingSDK.proxyInstance;
                    
                    // CRITICAL: Access the _calls Map inside _callClients
                    if (pi._callClients && pi._callClients instanceof Map) {
                        console.log('üìπ _callClients Map found, size:', pi._callClients.size);
                        
                        for (const [clientName, client] of pi._callClients) {
                            console.log(`üìπ Processing callClient: ${clientName}`);
                            console.log(`üìπ Client keys:`, Object.keys(client));
                            
                            // Access the _calls Map inside the client
                            if (client._calls && client._calls instanceof Map) {
                                console.log(`üìπ Found _calls Map, size:`, client._calls.size);
                                
                                for (const [callId, call] of client._calls) {
                                    console.log(`üìπ Found call: ${callId}`);
                                    console.log(`üìπ Call object:`, call);
                                    
                                    if (call && typeof call === 'object') {
                                        console.log(`üìπ Call keys:`, Object.keys(call));
                                        
                                        // Store reference for later use
                                        window.activeACSCall = call;
                                        
                                        // Try to render remote video
                                        const rendered = await renderRemoteVideoFromCall(call);
                                        if (rendered) {
                                            console.log('‚úÖ Remote video rendered from call object!');
                                        }
                                    }
                                }
                            }
                            
                            // Also check _callAgent - this has the REAL ACS call object
                            if (client._callAgent) {
                                console.log('üìπ Found _callAgent:', client._callAgent);
                                console.log('üìπ _callAgent keys:', Object.keys(client._callAgent));
                                
                                // Check for _calls on callAgent
                                if (client._callAgent._calls) {
                                    console.log('üìπ _callAgent._calls:', client._callAgent._calls);
                                }
                                
                                // Check for calls property - THIS is the real ACS call!
                                if (client._callAgent.calls && client._callAgent.calls.length > 0) {
                                    console.log('üìπ _callAgent.calls:', client._callAgent.calls);
                                    for (const call of client._callAgent.calls) {
                                        console.log('üìπ REAL ACS call found!');
                                        console.log('üìπ ACS call keys:', Object.keys(call));
                                        
                                        // Store the REAL ACS call (with 59+ keys) for camera control
                                        window.activeACSCall = call;
                                        console.log('üìπ Stored real ACS call in window.activeACSCall');
                                        
                                        await renderRemoteVideoFromCall(call);
                                        
                                        // AUTO-START LOCAL CAMERA for video calls
                                        if (isVideoCall && client._deviceManager) {
                                            console.log('üìπ Auto-starting local camera for video call...');
                                            try {
                                                let cameras = [];
                                                if (typeof client._deviceManager.getCameras === 'function') {
                                                    cameras = await client._deviceManager.getCameras();
                                                } else if (client._deviceManager.cameras) {
                                                    cameras = client._deviceManager.cameras;
                                                }
                                                
                                                if (cameras && cameras.length > 0) {
                                                    console.log('üìπ Available cameras:', cameras.length);
                                                    
                                                    // Get local video via getUserMedia for preview
                                                    try {
                                                        const stream = await navigator.mediaDevices.getUserMedia({
                                                            video: true,
                                                            audio: false
                                                        });
                                                        localVideo.srcObject = stream;
                                                        localVideo.style.display = 'block';
                                                        localStream = stream;
                                                        isCameraOff = false;
                                                        console.log('‚úÖ Local camera started for customer preview');
                                                        
                                                        // Update UI
                                                        toggleCameraBtn.classList.remove('muted');
                                                        toggleCameraBtn.title = 'Turn off camera';
                                                        toggleCameraBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>';
                                                    } catch (mediaErr) {
                                                        console.log('üìπ Could not get camera:', mediaErr.message);
                                                    }
                                                }
                                            } catch (camErr) {
                                                console.log('üìπ Camera auto-start error:', camErr);
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // Check _deviceManager for streams
                            if (client._deviceManager) {
                                console.log('üìπ Found _deviceManager:', client._deviceManager);
                                console.log('üìπ _deviceManager keys:', Object.keys(client._deviceManager));
                            }
                        }
                    }
                    
                    // Inspect _voiceVideoCallingStream
                    if (pi._voiceVideoCallingStream) {
                        console.log('üìπ _voiceVideoCallingStream found:', pi._voiceVideoCallingStream);
                    }
                }
                
                console.log('üìπ ========== END DEEP INSPECTION ==========');
                
                // Set up a delayed inspection to catch streams that appear later
                setTimeout(async () => {
                    console.log('üìπ ========== DELAYED INSPECTION (3s) ==========');
                    
                    // Re-check the call object for remote participants
                    if (window.activeACSCall) {
                        console.log('üìπ [3s] Re-checking activeACSCall...');
                        const call = window.activeACSCall;
                        console.log('üìπ [3s] Call state:', call.state);
                        console.log('üìπ [3s] Call keys:', Object.keys(call));
                        
                        // Check for remoteParticipants (ACS standard property)
                        if (call.remoteParticipants && call.remoteParticipants.length > 0) {
                            console.log('üìπ [3s] Remote participants:', call.remoteParticipants.length);
                            for (const participant of call.remoteParticipants) {
                                console.log('üìπ [3s] Participant:', participant);
                                console.log('üìπ [3s] Participant keys:', Object.keys(participant));
                                
                                // Check videoStreams
                                if (participant.videoStreams && participant.videoStreams.length > 0) {
                                    console.log('üìπ [3s] Participant videoStreams:', participant.videoStreams);
                                    
                                    for (const stream of participant.videoStreams) {
                                        console.log('üìπ [3s] Stream:', stream);
                                        console.log('üìπ [3s] Stream.isAvailable:', stream.isAvailable);
                                        console.log('üìπ [3s] Stream keys:', Object.keys(stream));
                                        
                                        // If stream is available, try to render it
                                        if (stream.isAvailable) {
                                            // Check for createView method on the call
                                            if (typeof call.createRemoteVideoView === 'function') {
                                                try {
                                                    console.log('üìπ [3s] Calling createRemoteVideoView...');
                                                    const view = await call.createRemoteVideoView(stream);
                                                    if (view && view.target) {
                                                        const container = remoteVideo.parentElement;
                                                        view.target.style.width = '100%';
                                                        view.target.style.height = '100%';
                                                        container.appendChild(view.target);
                                                        remoteVideo.style.display = 'none';
                                                        console.log('‚úÖ [3s] Remote video rendered via createRemoteVideoView');
                                                    }
                                                } catch (e) {
                                                    console.log('üìπ [3s] createRemoteVideoView error:', e);
                                                }
                                            }
                                            
                                            // Try getMediaStream
                                            if (typeof stream.getMediaStream === 'function') {
                                                try {
                                                    const ms = await stream.getMediaStream();
                                                    if (ms instanceof MediaStream) {
                                                        console.log('üìπ [3s] Got MediaStream!', ms);
                                                        remoteVideo.srcObject = ms;
                                                        remoteVideo.play().catch(e => console.log('Play error:', e));
                                                    }
                                                } catch (e) {
                                                    console.log('üìπ [3s] getMediaStream error:', e);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Set up event listener for when video streams are added
                        if (call.on && typeof call.on === 'function') {
                            console.log('üìπ [3s] Setting up call.on event listeners...');
                            
                            call.on('remoteParticipantsUpdated', (e) => {
                                console.log('üìπ remoteParticipantsUpdated event:', e);
                                if (e.added) {
                                    for (const participant of e.added) {
                                        console.log('üìπ New participant added:', participant);
                                        setupParticipantVideoListener(participant);
                                    }
                                }
                            });
                        }
                        
                        // Check existing participants and set up listeners
                        if (call.remoteParticipants) {
                            for (const participant of call.remoteParticipants) {
                                setupParticipantVideoListener(participant);
                            }
                        }
                    }
                    
                    // Check if remoteVideo has srcObject now
                    console.log('üìπ [3s] remoteVideo.srcObject:', remoteVideo.srcObject);
                    console.log('üìπ [3s] localVideo.srcObject:', localVideo.srcObject);
                    
                    // Look for any video elements that might have been created by SDK
                    const allVideos = document.querySelectorAll('video');
                    console.log('üìπ [3s] All video elements:', allVideos.length);
                    allVideos.forEach((v, i) => {
                        console.log(`üìπ [3s] Video ${i}: id=${v.id}, srcObject=`, v.srcObject);
                        if (v.srcObject && v !== remoteVideo && v !== localVideo) {
                            console.log('üìπ [3s] Found video with stream! Copying to remoteVideo...');
                            remoteVideo.srcObject = v.srcObject;
                        }
                    });
                    
                    console.log('üìπ ========== END DELAYED INSPECTION ==========');
                }, 3000);
                
                // Helper function to listen for video streams on a participant
                function setupParticipantVideoListener(participant) {
                    console.log('üìπ Setting up video listener for participant:', participant.identifier);
                    
                    if (participant.on && typeof participant.on === 'function') {
                        participant.on('videoStreamsUpdated', async (e) => {
                            console.log('üìπ videoStreamsUpdated event:', e);
                            if (e.added) {
                                for (const stream of e.added) {
                                    console.log('üìπ New video stream added:', stream);
                                    await handleRemoteVideoStream(stream);
                                }
                            }
                        });
                    }
                    
                    // Check existing streams
                    if (participant.videoStreams) {
                        for (const stream of participant.videoStreams) {
                            if (stream.isAvailable) {
                                handleRemoteVideoStream(stream);
                            }
                            
                            // Listen for availability changes
                            if (stream.on) {
                                stream.on('isAvailableChanged', async () => {
                                    console.log('üìπ Stream isAvailableChanged:', stream.isAvailable);
                                    if (stream.isAvailable) {
                                        await handleRemoteVideoStream(stream);
                                    }
                                });
                            }
                        }
                    }
                }
                
                // Helper function to handle a remote video stream
                async function handleRemoteVideoStream(stream) {
                    console.log('üìπ Handling remote video stream:', stream);
                    console.log('üìπ Stream keys:', Object.keys(stream));
                    console.log('üìπ Stream.isAvailable:', stream.isAvailable);
                    
                    // Try getMediaStream
                    if (typeof stream.getMediaStream === 'function') {
                        try {
                            const ms = await stream.getMediaStream();
                            if (ms instanceof MediaStream) {
                                console.log('‚úÖ Got MediaStream from remote stream!');
                                remoteVideo.srcObject = ms;
                                remoteVideo.style.display = 'block';
                                callAvatar.style.display = 'none';
                                remoteVideo.play().catch(e => console.log('Play error:', e));
                                return;
                            }
                        } catch (e) {
                            console.log('üìπ getMediaStream error:', e);
                        }
                    }
                    
                    // Check if stream itself is MediaStream
                    if (stream instanceof MediaStream) {
                        console.log('‚úÖ Stream IS MediaStream!');
                        remoteVideo.srcObject = stream;
                        remoteVideo.style.display = 'block';
                        callAvatar.style.display = 'none';
                        remoteVideo.play().catch(e => console.log('Play error:', e));
                    }
                }
                
            } catch (error) {
                console.error('‚ùå Failed to accept call:', error);
                alert('Could not connect to call: ' + error.message);
                callContainer.classList.remove('active');
                endCall();
            }
        }
        
        async function declineIncomingCall() {
            console.log('‚ùå Declining incoming call');
            incomingCallNotification.style.display = 'none';
            
            // Use the global VoiceVideoCallingSDK to reject the call
            if (VoiceVideoCallingSDK && VoiceVideoCallingSDK.rejectCall) {
                try {
                    await VoiceVideoCallingSDK.rejectCall();
                    console.log('‚úÖ Call rejected successfully');
                } catch (err) {
                    console.log('‚ö†Ô∏è Could not reject call:', err);
                }
            }
            
            pendingCallData = null;
        }
        
        function playNotificationSound() {
            // Create a simple beep sound
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                gainNode.gain.value = 0.3;
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            } catch (e) {
                console.log('Could not play notification sound:', e);
            }
        }
        
        // ============ OUTGOING CALL FUNCTIONS (Customer-Initiated) ============
        // Note: These may not work if SDK doesn't support client-initiated calling
        
        // Voice/Video Call Functions
        async function startVoiceCall() {
            if (!chatSDK || !chatStarted || isInCall) return;
            
            try {
                console.log('üé§ Starting voice call...');
                console.log('Available SDK methods:', Object.keys(chatSDK));
                
                // Check if calling is available through SDK
                // Note: D365 voice/video calling may require specific Omnichannel configuration
                // and might not be available through the headless chat SDK
                const hasCallingSupport = typeof chatSDK.getVoiceVideoCalling === 'function' ||
                                         typeof chatSDK.requestVoiceCall === 'function' ||
                                         typeof chatSDK.initiateCall === 'function';
                
                if (!hasCallingSupport) {
                    throw new Error('Voice/Video calling is not available through the chat SDK.\n\n' +
                        'This feature requires:\n' +
                        '1. Voice/Video channel enabled in D365 Omnichannel Admin Center\n' +
                        '2. Proper licensing (Digital Messaging + Voice add-on)\n' +
                        '3. Native D365 widget or supported calling SDK\n\n' +
                        'The headless chat SDK may not support direct client-initiated calling.\n' +
                        'Consider using the native D365 widget or contact Microsoft support.');
                }
                
                isVideoCall = false;
                callContainer.classList.add('active');
                callConnecting.style.display = 'flex';
                callAvatar.style.display = 'none';
                remoteVideo.style.display = 'none';
                localVideo.style.display = 'none';
                toggleCameraBtn.style.display = 'none';
                callStatus.textContent = 'Connecting...';
                
                // Try to get the voice/video calling object from SDK
                let voiceVideoCall = null;
                if (chatSDK.getVoiceVideoCalling) {
                    voiceVideoCall = await chatSDK.getVoiceVideoCalling();
                }
                console.log('Voice/Video calling object:', voiceVideoCall);
                
                // Request microphone access
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true, 
                    video: false 
                });
                
                // Start voice calling using SDK
                if (voiceVideoCall && voiceVideoCall.startCall) {
                    await voiceVideoCall.startCall({ 
                        video: false, 
                        audio: true 
                    });
                } else {
                    throw new Error('Calling API not available. Please check Omnichannel configuration.');
                }
                
                console.log('‚úÖ Voice call started');
                isInCall = true;
                callConnecting.style.display = 'none';
                callAvatar.style.display = 'flex';
                callAvatar.textContent = getInitials(headerTitle.textContent);
                callStatus.textContent = 'Voice Call';
                
                // Voice call is now active
                startCallDuration();
                
                // Setup call event listeners
                if (voiceVideoCall.onCallConnected) {
                    voiceVideoCall.onCallConnected(() => {
                        console.log('üìû Call connected');
                        callStatus.textContent = 'Connected';
                    });
                }
                
                if (voiceVideoCall.onCallDisconnected) {
                    voiceVideoCall.onCallDisconnected(() => {
                        console.log('üìû Call disconnected');
                        endCall();
                    });
                }
                
                if (voiceVideoCall.onRemoteVideoStreamAdded) {
                    voiceVideoCall.onRemoteVideoStreamAdded((stream) => {
                        console.log('üìπ Remote stream added');
                        remoteStream = stream;
                        remoteVideo.srcObject = stream;
                    });
                }
                
                // Store the calling object for later use
                window.activeVoiceVideoCall = voiceVideoCall;
                
            } catch (error) {
                console.error('‚ùå Voice call failed:', error);
                alert('Could not start voice call: ' + error.message);
                callContainer.classList.remove('active');
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
            }
        }
        
        async function startVideoCall() {
            if (!chatSDK || !chatStarted || isInCall) return;
            
            try {
                console.log('üìπ Starting video call...');
                console.log('Available SDK methods:', Object.keys(chatSDK));
                
                // Check if calling is available through SDK
                const hasCallingSupport = typeof chatSDK.getVoiceVideoCalling === 'function' ||
                                         typeof chatSDK.requestVideoCall === 'function' ||
                                         typeof chatSDK.initiateCall === 'function';
                
                if (!hasCallingSupport) {
                    throw new Error('Voice/Video calling is not available through the chat SDK.\n\n' +
                        'This feature requires:\n' +
                        '1. Voice/Video channel enabled in D365 Omnichannel Admin Center\n' +
                        '2. Proper licensing (Digital Messaging + Voice add-on)\n' +
                        '3. Native D365 widget or supported calling SDK\n\n' +
                        'The headless chat SDK may not support direct client-initiated calling.\n' +
                        'Consider using the native D365 widget or contact Microsoft support.');
                }
                
                isVideoCall = true;
                callContainer.classList.add('active');
                callConnecting.style.display = 'flex';
                callAvatar.style.display = 'none';
                remoteVideo.style.display = 'none';
                localVideo.style.display = 'none';
                toggleCameraBtn.style.display = 'flex';
                callStatus.textContent = 'Connecting...';
                
                // Try to get the voice/video calling object from SDK
                let voiceVideoCall = null;
                if (chatSDK.getVoiceVideoCalling) {
                    voiceVideoCall = await chatSDK.getVoiceVideoCalling();
                }
                console.log('Voice/Video calling object:', voiceVideoCall);
                
                // Request camera and microphone access
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true, 
                    video: { 
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 } 
                    } 
                });
                
                localVideo.srcObject = localStream;
                localVideo.style.display = 'block';
                
                // Start video calling using SDK
                if (voiceVideoCall && voiceVideoCall.startCall) {
                    await voiceVideoCall.startCall({ 
                        video: true, 
                        audio: true 
                    });
                } else {
                    throw new Error('Calling API not available. Please check Omnichannel configuration.');
                }
                
                console.log('‚úÖ Video call started');
                isInCall = true;
                callConnecting.style.display = 'none';
                remoteVideo.style.display = 'block';
                callStatus.textContent = 'Video Call';
                
                // Video call is now active
                startCallDuration();
                
                // Setup call event listeners
                if (voiceVideoCall.onCallConnected) {
                    voiceVideoCall.onCallConnected(() => {
                        console.log('üìû Call connected');
                        callStatus.textContent = 'Connected';
                    });
                }
                
                if (voiceVideoCall.onCallDisconnected) {
                    voiceVideoCall.onCallDisconnected(() => {
                        console.log('üìû Call disconnected');
                        endCall();
                    });
                }
                
                if (voiceVideoCall.onRemoteVideoStreamAdded) {
                    voiceVideoCall.onRemoteVideoStreamAdded((stream) => {
                        console.log('üìπ Remote stream added');
                        remoteStream = stream;
                        remoteVideo.srcObject = stream;
                    });
                }
                
                // Store the calling object for later use
                window.activeVoiceVideoCall = voiceVideoCall;
                
            } catch (error) {
                console.error('‚ùå Video call failed:', error);
                alert('Could not start video call: ' + error.message);
                callContainer.classList.remove('active');
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
            }
        }
        
        function startCallDuration() {
            callStartTime = Date.now();
            callDurationInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                callDuration.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }
        
        async function toggleMic() {
            if (!isInCall) return;
            
            try {
                // Use the VoiceVideoCallingSDK to toggle mute
                if (VoiceVideoCallingSDK && VoiceVideoCallingSDK.toggleMute) {
                    await VoiceVideoCallingSDK.toggleMute();
                    
                    // Check the mute state from SDK
                    isMicMuted = VoiceVideoCallingSDK.isMicrophoneMuted ? 
                                 VoiceVideoCallingSDK.isMicrophoneMuted() : !isMicMuted;
                    
                    muteMicBtn.classList.toggle('muted', isMicMuted);
                    muteMicBtn.title = isMicMuted ? 'Unmute microphone' : 'Mute microphone';
                    
                    // Update mic icon
                    if (isMicMuted) {
                        muteMicBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M19 11h-1.7c0 .74-.16 1.43-.43 2.05l1.23 1.23c.56-.98.9-2.09.9-3.28zm-4.02.17c0-.06.02-.11.02-.17V5c0-1.66-1.34-3-3-3S9 3.34 9 5v.18l5.98 5.99zM4.27 3L3 4.27l6.01 6.01V11c0 1.66 1.33 3 2.99 3 .22 0 .44-.03.65-.08l1.66 1.66c-.71.33-1.5.52-2.31.52-2.76 0-5.3-2.1-5.3-5.1H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c.91-.13 1.77-.45 2.54-.9L19.73 21 21 19.73 4.27 3z"/></svg>';
                    } else {
                        muteMicBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>';
                    }
                    
                    console.log(isMicMuted ? 'üîá Microphone muted' : 'üé§ Microphone unmuted');
                }
            } catch (error) {
                console.error('Failed to toggle mute:', error);
            }
        }
        
        async function toggleCamera() {
            if (!isInCall || !isVideoCall) return;
            
            try {
                console.log('üìπ toggleCamera called, isCameraOff:', isCameraOff);
                
                // Try using the ACS call object directly
                if (window.activeACSCall) {
                    const call = window.activeACSCall;
                    console.log('üìπ Using activeACSCall for camera toggle');
                    
                    // Get device manager from the SDK
                    let deviceManager = null;
                    if (VoiceVideoCallingSDK?.proxyInstance?._callClients) {
                        for (const [name, client] of VoiceVideoCallingSDK.proxyInstance._callClients) {
                            if (client._deviceManager) {
                                deviceManager = client._deviceManager;
                                break;
                            }
                        }
                    }
                    
                    if (isCameraOff) {
                        // Turn camera ON
                        console.log('üìπ Turning camera ON...');
                        
                        if (deviceManager) {
                            console.log('üìπ Got deviceManager');
                            
                            // Get available cameras
                            let cameras = [];
                            if (typeof deviceManager.getCameras === 'function') {
                                cameras = await deviceManager.getCameras();
                            } else if (deviceManager.cameras) {
                                cameras = deviceManager.cameras;
                            }
                            console.log('üìπ Available cameras:', cameras);
                            
                            if (cameras && cameras.length > 0) {
                                const camera = cameras[0];
                                console.log('üìπ Using camera:', camera.name || camera.id);
                                
                                // Create LocalVideoStream
                                // Check if there's a LocalVideoStream class available
                                let localVideoStream = null;
                                
                                // Try different ways to create local video stream
                                if (call.startVideo) {
                                    // ACS way: create stream and start video
                                    try {
                                        // First check if call has localVideoStreams we can use
                                        if (call.localVideoStreams && call.localVideoStreams.length > 0) {
                                            console.log('üìπ Restarting existing local video stream');
                                            await call.startVideo(call.localVideoStreams[0]);
                                        } else {
                                            // Create new stream - need LocalVideoStream class
                                            // Try to find it from ACS bundle
                                            const LocalVideoStream = window.ACS?.LocalVideoStream || 
                                                                    window.LocalVideoStream;
                                            
                                            if (LocalVideoStream) {
                                                localVideoStream = new LocalVideoStream(camera);
                                                console.log('üìπ Created LocalVideoStream');
                                                await call.startVideo(localVideoStream);
                                            } else {
                                                console.log('üìπ LocalVideoStream class not found, trying SDK method');
                                            }
                                        }
                                        console.log('‚úÖ Camera started via call.startVideo');
                                        isCameraOff = false;
                                    } catch (e) {
                                        console.log('üìπ call.startVideo error:', e);
                                    }
                                }
                                
                                // Also try to get media stream directly for preview
                                try {
                                    const stream = await navigator.mediaDevices.getUserMedia({ 
                                        video: { deviceId: camera.id ? { exact: camera.id } : undefined },
                                        audio: false 
                                    });
                                    localVideo.srcObject = stream;
                                    localVideo.style.display = 'block';
                                    localStream = stream;
                                    console.log('‚úÖ Local video preview started');
                                    isCameraOff = false;
                                } catch (e) {
                                    console.log('üìπ getUserMedia error:', e);
                                }
                            }
                        }
                        
                        // Fallback: try SDK method
                        if (isCameraOff && VoiceVideoCallingSDK?.toggleLocalVideo) {
                            try {
                                const result = await VoiceVideoCallingSDK.toggleLocalVideo();
                                console.log('üìπ SDK toggleLocalVideo result:', result);
                                if (result !== undefined) {
                                    isCameraOff = false;
                                }
                            } catch (e) {
                                console.log('üìπ SDK toggleLocalVideo error:', e);
                            }
                        }
                        
                        // Another fallback: try startLocalVideo
                        if (isCameraOff && VoiceVideoCallingSDK?.startLocalVideo) {
                            try {
                                await VoiceVideoCallingSDK.startLocalVideo();
                                console.log('‚úÖ Local video started via SDK.startLocalVideo');
                                isCameraOff = false;
                            } catch (e) {
                                console.log('üìπ SDK startLocalVideo error:', e);
                            }
                        }
                    } else {
                        // Turn camera OFF
                        console.log('üìπ Turning camera OFF...');
                        
                        // Stop via call object
                        if (call.stopVideo && call.localVideoStreams && call.localVideoStreams.length > 0) {
                            try {
                                await call.stopVideo(call.localVideoStreams[0]);
                                console.log('‚úÖ Camera stopped via call.stopVideo');
                            } catch (e) {
                                console.log('üìπ call.stopVideo error:', e);
                            }
                        }
                        
                        // Stop local stream
                        if (localStream) {
                            localStream.getVideoTracks().forEach(track => track.stop());
                        }
                        if (localVideo.srcObject) {
                            localVideo.srcObject.getVideoTracks().forEach(track => track.stop());
                            localVideo.srcObject = null;
                        }
                        
                        // Try SDK method
                        if (VoiceVideoCallingSDK?.toggleLocalVideo) {
                            try {
                                await VoiceVideoCallingSDK.toggleLocalVideo();
                            } catch (e) {
                                console.log('üìπ SDK toggleLocalVideo error:', e);
                            }
                        }
                        
                        isCameraOff = true;
                        localVideo.style.display = 'none';
                    }
                } else {
                    // Fallback to original SDK method
                    if (VoiceVideoCallingSDK && VoiceVideoCallingSDK.toggleLocalVideo) {
                        await VoiceVideoCallingSDK.toggleLocalVideo();
                        isCameraOff = !isCameraOff;
                    }
                }
                
                // Update UI
                toggleCameraBtn.classList.toggle('muted', isCameraOff);
                toggleCameraBtn.title = isCameraOff ? 'Turn on camera' : 'Turn off camera';
                
                // Update camera icon
                if (isCameraOff) {
                    toggleCameraBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M21 6.5l-4 4V7c0-.55-.45-1-1-1H9.82L21 17.18V6.5zM3.27 2L2 3.27 4.73 6H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.21 0 .39-.08.54-.18L19.73 21 21 19.73 3.27 2z"/></svg>';
                } else {
                    toggleCameraBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>';
                }
                
                localVideo.style.display = isCameraOff ? 'none' : 'block';
                console.log(isCameraOff ? 'üì∑ Camera off' : 'üìπ Camera on');
                
            } catch (error) {
                console.error('Failed to toggle camera:', error);
            }
        }
        
        async function endCall() {
            console.log('üî¥ Ending call...');
            
            // Stop call via VoiceVideoCallingSDK
            if (VoiceVideoCallingSDK && isInCall) {
                try {
                    if (typeof VoiceVideoCallingSDK.stopCall === 'function') {
                        await VoiceVideoCallingSDK.stopCall();
                        console.log('‚úÖ Call stopped via VoiceVideoCallingSDK');
                    }
                } catch (error) {
                    console.error('Error stopping call via SDK:', error);
                }
            }
            
            // Stop local media streams (fallback cleanup)
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('Stopped track:', track.kind);
                });
                localStream = null;
            }
            
            // Clear remote stream
            if (remoteVideo.srcObject) {
                remoteVideo.srcObject = null;
            }
            if (localVideo.srcObject) {
                localVideo.srcObject = null;
            }
            
            // Clear stored calling object reference
            window.activeVoiceVideoCall = null;
            
            // Reset UI
            callContainer.classList.remove('active');
            muteMicBtn.classList.remove('muted');
            toggleCameraBtn.classList.remove('muted');
            
            // Clear call duration timer
            if (callDurationInterval) {
                clearInterval(callDurationInterval);
                callDurationInterval = null;
            }
            
            // Reset state
            isInCall = false;
            isVideoCall = false;
            isMicMuted = false;
            isCameraOff = false;
            callStartTime = null;
            callDuration.textContent = '00:00';
            
            console.log('‚úÖ Call ended');
        }

        async function sendMessage() {
            const text = messageInput.value.trim();
            if (!text) return;
            messageInput.value = '';
            await sendMessageText(text);
        }

        // Emoji picker - Use native OS emoji picker
        emojiBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Focus the message input first
            messageInput.focus();
            
            // Try to trigger native emoji picker using keyboard simulation
            // Windows: Win + . (period) | Mac: Cmd + Ctrl + Space
            try {
                // Create and dispatch the keyboard event for emoji picker
                const isWindows = navigator.platform.indexOf('Win') > -1;
                const isMac = navigator.platform.indexOf('Mac') > -1;
                
                if (isWindows) {
                    // For Windows, we show a helpful tooltip since we can't programmatically trigger Win+.
                    const tooltip = document.createElement('div');
                    tooltip.style.cssText = `
                        position: fixed; bottom: 120px; right: 30px; background: #1e293b; color: white;
                        padding: 12px 16px; border-radius: 8px; font-size: 13px; z-index: 10000;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3); animation: fadeIn 0.2s ease;
                    `;
                    tooltip.innerHTML = `<strong>üí° Tip:</strong> Press <kbd style="background:#374151;padding:2px 6px;border-radius:4px;margin:0 2px;">Win</kbd> + <kbd style="background:#374151;padding:2px 6px;border-radius:4px;margin:0 2px;">.</kbd> for emojis`;
                    document.body.appendChild(tooltip);
                    setTimeout(() => tooltip.remove(), 3000);
                } else if (isMac) {
                    const tooltip = document.createElement('div');
                    tooltip.style.cssText = `
                        position: fixed; bottom: 120px; right: 30px; background: #1e293b; color: white;
                        padding: 12px 16px; border-radius: 8px; font-size: 13px; z-index: 10000;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3); animation: fadeIn 0.2s ease;
                    `;
                    tooltip.innerHTML = `<strong>üí° Tip:</strong> Press <kbd style="background:#374151;padding:2px 6px;border-radius:4px;margin:0 2px;">Cmd</kbd> + <kbd style="background:#374151;padding:2px 6px;border-radius:4px;margin:0 2px;">Ctrl</kbd> + <kbd style="background:#374151;padding:2px 6px;border-radius:4px;margin:0 2px;">Space</kbd> for emojis`;
                    document.body.appendChild(tooltip);
                    setTimeout(() => tooltip.remove(), 3000);
                }
            } catch (err) {
                console.log('Emoji picker error:', err);
            }
        });

        // Voice input with visual indicator
        let recognition = null;
        let isRecording = false;

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isRecording = true;
                voiceBtn.classList.add('recording');
                voiceRecording.classList.add('show');
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                messageInput.value += transcript;
            };

            recognition.onend = () => {
                isRecording = false;
                voiceBtn.classList.remove('recording');
                voiceRecording.classList.remove('show');
            };

            recognition.onerror = (event) => {
                console.log('Speech recognition error:', event.error);
                isRecording = false;
                voiceBtn.classList.remove('recording');
                voiceRecording.classList.remove('show');
            };

            voiceBtn.addEventListener('click', () => {
                if (isRecording) {
                    recognition.stop();
                } else {
                    recognition.start();
                }
            });

            stopVoiceBtn.addEventListener('click', () => {
                recognition.stop();
            });
        } else {
            voiceBtn.style.display = 'none';
        }

        // New chat button
        newChatBtn.addEventListener('click', () => {
            chatSDK = null; chatStarted = false;
            processedMessageIds.clear(); // Clear processed message IDs
            chatMessages = []; // Clear messages array
            localStorage.removeItem('chatWidgetSession'); // Clear saved session
            messagesContainer.querySelectorAll('.message-wrapper').forEach(el => el.remove());
            document.getElementById('userName').value = '';
            document.getElementById('userEmail').value = '';
            document.getElementById('userQuestion').value = '';
            startBtn.disabled = false; startBtn.textContent = adminSettings?.startBtnText || 'Start Chat';
            headerAvatar.innerHTML = '<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/></svg>';
            showView('prechat');
        });

        // ============ APPLY ADMIN THEME SETTINGS ============
        function applyAdminTheme() {
            if (!adminSettings) {
                console.log('?? No admin settings found - using default theme');
                return;
            }

            console.log('? Applying admin theme with settings:', adminSettings);
            const s = adminSettings;
            
            // Font family mapping
            const fontMap = {
                // System
                'system': '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                // Sans-Serif
                'inter': '"Inter", sans-serif',
                'roboto': '"Roboto", sans-serif',
                'opensans': '"Open Sans", sans-serif',
                'lato': '"Lato", sans-serif',
                'poppins': '"Poppins", sans-serif',
                'montserrat': '"Montserrat", sans-serif',
                'nunito': '"Nunito", sans-serif',
                'sourcesans': '"Source Sans Pro", sans-serif',
                'raleway': '"Raleway", sans-serif',
                'ubuntu': '"Ubuntu", sans-serif',
                'rubik': '"Rubik", sans-serif',
                'worksans': '"Work Sans", sans-serif',
                'firasans': '"Fira Sans", sans-serif',
                'dmsans': '"DM Sans", sans-serif',
                'manrope': '"Manrope", sans-serif',
                'plusjakarta': '"Plus Jakarta Sans", sans-serif',
                'outfit': '"Outfit", sans-serif',
                'lexend': '"Lexend", sans-serif',
                // Serif
                'playfair': '"Playfair Display", serif',
                'merriweather': '"Merriweather", serif',
                'lora': '"Lora", serif',
                'crimson': '"Crimson Text", serif',
                'libre': '"Libre Baskerville", serif',
                // Monospace
                'jetbrains': '"JetBrains Mono", monospace',
                'firacode': '"Fira Code", monospace',
                'sourcecodepro': '"Source Code Pro", monospace',
                // Display
                'quicksand': '"Quicksand", sans-serif',
                'comfortaa': '"Comfortaa", cursive',
                'righteous': '"Righteous", cursive'
            };
            const fontFamily = fontMap[s.fontFamily] || fontMap['system'];
            
            // Determine gradient or solid color
            const gradient = s.useGradient 
                ? `linear-gradient(135deg, ${s.gradientStart || '#667eea'} 0%, ${s.gradientEnd || '#764ba2'} 100%)`
                : s.primaryColor || '#667eea';
            
            const launcherBg = s.launcherColor || gradient;

            // Create dynamic style element
            const styleEl = document.createElement('style');
            styleEl.id = 'admin-theme';
            styleEl.textContent = `
                /* Font */
                .chat-container, .chat-launcher { font-family: ${fontFamily} !important; }
                
                /* Header & Launcher */
                .chat-header { background: ${gradient} !important; }
                .chat-launcher { background: ${launcherBg} !important; }
                .chat-launcher:hover { box-shadow: 0 6px 30px ${s.gradientStart || '#667eea'}66 !important; }

                /* Messages */
                .chat-messages { background: ${s.chatBgColor || '#f8fafc'} !important; }
                .message.user { background: ${s.useGradient ? gradient : (s.userBubbleColor || '#667eea')} !important; color: ${s.userTextColor || '#ffffff'} !important; }
                .message.agent { background: ${s.agentBubbleColor || '#ffffff'} !important; color: ${s.agentTextColor || '#2d3748'} !important; }
                .message.system { background: ${s.systemMsgColor || '#e2e8f0'} !important; color: ${s.systemTextColor || '#64748b'} !important; }
                .message-avatar.agent { background: ${gradient} !important; }

                /* Input Area */
                .chat-input-area { background: ${s.inputBgColor || '#ffffff'} !important; }
                .message-input { border-color: ${s.inputBorderColor || '#e2e8f0'} !important; }
                .message-input:focus { border-color: ${s.gradientStart || '#667eea'} !important; box-shadow: 0 0 0 3px ${s.gradientStart || '#667eea'}1a !important; }
                .send-btn { color: ${s.sendBtnColor || '#667eea'} !important; }
                .send-btn:hover { background: ${s.sendBtnColor || '#667eea'}1a !important; }

                /* Buttons */
                .start-btn { background: ${gradient} !important; }
                .start-btn:hover { box-shadow: 0 4px 15px ${s.gradientStart || '#667eea'}66 !important; }
                .new-chat-btn { background: ${gradient} !important; }
                
                /* Badge */
                .chat-badge { background: ${s.badgeColor || '#ff4757'} !important; }
            `;
            document.head.appendChild(styleEl);

            // Apply header text
            if (s.headerTitle) {
                headerTitle.textContent = s.headerTitle;
            }
            if (s.headerSubtitle) {
                headerStatus.textContent = s.headerSubtitle;
            }

            // Apply header logo if set
            if (s.headerLogo) {
                headerAvatar.innerHTML = `<img src="${s.headerLogo}" alt="Logo" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
            }

            // Apply pre-chat form labels
            if (s.welcomeTitle) {
                const formTitle = document.querySelector('.form-title');
                if (formTitle) formTitle.textContent = s.welcomeTitle;
            }
            if (s.welcomeMessage) {
                const formSubtitle = document.querySelector('.form-subtitle');
                if (formSubtitle) formSubtitle.textContent = s.welcomeMessage;
            }
            if (s.nameFieldLabel) {
                const nameLabel = document.querySelector('label[for="userName"]');
                if (nameLabel) nameLabel.textContent = s.nameFieldLabel + ' *';
            }
            if (s.emailFieldLabel) {
                const emailLabel = document.querySelector('label[for="userEmail"]');
                if (emailLabel) emailLabel.textContent = s.emailFieldLabel + ' *';
            }
            if (s.questionFieldLabel) {
                const questionLabel = document.querySelector('label[for="userQuestion"]');
                if (questionLabel) questionLabel.textContent = s.questionFieldLabel + ' (optional)';
            }
            if (s.startBtnText) {
                startBtn.textContent = s.startBtnText;
            }

            console.log('‚úÖ Admin theme applied successfully');
        }

        // Apply theme on load
        applyAdminTheme();
        
        // Restore previous chat session if available (async)
        (async function initPage() {
            const sessionRestored = await restoreChatSession();
            if (!sessionRestored) {
                showView('prechat');
            }
        })();
    </script>
</body>
</html>
